{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"liquidpy A port of liquid template engine for python This is compatible with standard Liquid template engine. Variations, such as Shopify and Jekyll are not fully supported yet. Install pip install -U liquidpy Baisic usage from liquid import Liquid liq = Liquid ( '{{a}}' ) ret = liq . render ( a = 1 ) # ret == '1' # with environments pre-loaded liq = Liquid ( '{{a}}' , a = 1 ) ret = liq . render () # ret == '1' # With debug on: liq = Liquid ( '{{a}}' , liquid_config = { 'debug' : True }) Python mode We also support a python mode template engine, which acts more pythonic and powerful. from liquid import Liquid # standard liquid doesn't support this liq = Liquid ( '{{a + 1}}' , { 'mode' : 'python' }) ret = liq . render ( a = 1 ) # ret == '2' Both modes can accept a path, a file-like object or a stream for the template: Liquid ( '/path/to/template' ) # or with open ( '/path/to/template' ) as f : Liquid ( f ) Full Documentation Liquid's documentation Liquidpy's documentation Backward compatiblility warning v0.6.0+ is a remodeled version to make it compatible with standard liquid engine. If you are using a previous version, stick with it. 0.6.0+ is not fully compatible with previous versions.","title":"Home"},{"location":"#liquidpy","text":"A port of liquid template engine for python This is compatible with standard Liquid template engine. Variations, such as Shopify and Jekyll are not fully supported yet.","title":"liquidpy"},{"location":"#install","text":"pip install -U liquidpy","title":"Install"},{"location":"#baisic-usage","text":"from liquid import Liquid liq = Liquid ( '{{a}}' ) ret = liq . render ( a = 1 ) # ret == '1' # with environments pre-loaded liq = Liquid ( '{{a}}' , a = 1 ) ret = liq . render () # ret == '1' # With debug on: liq = Liquid ( '{{a}}' , liquid_config = { 'debug' : True })","title":"Baisic usage"},{"location":"#python-mode","text":"We also support a python mode template engine, which acts more pythonic and powerful. from liquid import Liquid # standard liquid doesn't support this liq = Liquid ( '{{a + 1}}' , { 'mode' : 'python' }) ret = liq . render ( a = 1 ) # ret == '2' Both modes can accept a path, a file-like object or a stream for the template: Liquid ( '/path/to/template' ) # or with open ( '/path/to/template' ) as f : Liquid ( f )","title":"Python mode"},{"location":"#full-documentation","text":"Liquid's documentation Liquidpy's documentation","title":"Full Documentation"},{"location":"#backward-compatiblility-warning","text":"v0.6.0+ is a remodeled version to make it compatible with standard liquid engine. If you are using a previous version, stick with it. 0.6.0+ is not fully compatible with previous versions.","title":"Backward compatiblility warning"},{"location":"additional_tags/","text":"Tag block A block tag is to define a block for a parent template as a placeholder or a block in a inherited template to replace the corresponding one in the parent template. The tags in a block will not be parsed immediately until it's been replaced by the one from child template or replaces the one from parent template. To define a block tag: {% block blockname %} ... {% endblock %} Tag include You can also include a sub-template in a template. The syntax is similar to the one from Jekyll: {% include <path/to/sub-template.liquid> arg1 = value 1 arg2 = value 2 ... %} We don't support variables for the path of the sub-template. So here you have to pass the path directly. It can be either quoted or not. If you have spaces in the path, you need to quote it. Like Jekyll's include tag, you can also templatize the content and use each variables passed in a parameters: The arg1 is {{ include . arg1 }} The arg2 is {{ include . arg2 }} Tag extends The extends tag is used to extend a sub-template from a parent one by replacing the content wrapped with the block tag with the ones in the parent. The full syntax is like: parent.liquid : <html> <head> {% block title %} Default title {% endblock %} </head> <body> {% block body %} {% endblock %} </body> </html> sub.liquid {% extends parent.liquid %} {% block title %} Title of the sub-template {% endblock %} {% block body %} Awesome body content of the sub-template {% endblock %} Then the template will be compiled as: <html> <head> {% block title %} Title of the sub-template {% endblock %} </head> <body> {% block body %} Awesome body content of the sub-template {% endblock %} </body> </html> Note About the paths of include and extends : We support both relative and absolute paths for those two tags. For the relative ones, liquidpy will look for the template in the directory specifiied by Liquid(..., liquid_config={'include_dir': [...]} and Liquid(..., liquid_config={'extends_dir': [...]} , respectively. If nothing found there, it will look for the template in the directory where the one cites them. If the template citing them is from a string, it will search in the current working directory ( ./ , the directory the main program is running from) One can also specify include_dir and extends_dir by config tag when strict is off while constructing the Liquid object: Liquid ( ... , liquid_config = { 'strict' : False }) strict is True by default. See Configuration for more details. Tag config See Configuration","title":"Additional Tags"},{"location":"additional_tags/#tag-block","text":"A block tag is to define a block for a parent template as a placeholder or a block in a inherited template to replace the corresponding one in the parent template. The tags in a block will not be parsed immediately until it's been replaced by the one from child template or replaces the one from parent template. To define a block tag: {% block blockname %} ... {% endblock %}","title":"Tag block"},{"location":"additional_tags/#tag-include","text":"You can also include a sub-template in a template. The syntax is similar to the one from Jekyll: {% include <path/to/sub-template.liquid> arg1 = value 1 arg2 = value 2 ... %} We don't support variables for the path of the sub-template. So here you have to pass the path directly. It can be either quoted or not. If you have spaces in the path, you need to quote it. Like Jekyll's include tag, you can also templatize the content and use each variables passed in a parameters: The arg1 is {{ include . arg1 }} The arg2 is {{ include . arg2 }}","title":"Tag include"},{"location":"additional_tags/#tag-extends","text":"The extends tag is used to extend a sub-template from a parent one by replacing the content wrapped with the block tag with the ones in the parent. The full syntax is like: parent.liquid : <html> <head> {% block title %} Default title {% endblock %} </head> <body> {% block body %} {% endblock %} </body> </html> sub.liquid {% extends parent.liquid %} {% block title %} Title of the sub-template {% endblock %} {% block body %} Awesome body content of the sub-template {% endblock %} Then the template will be compiled as: <html> <head> {% block title %} Title of the sub-template {% endblock %} </head> <body> {% block body %} Awesome body content of the sub-template {% endblock %} </body> </html> Note About the paths of include and extends : We support both relative and absolute paths for those two tags. For the relative ones, liquidpy will look for the template in the directory specifiied by Liquid(..., liquid_config={'include_dir': [...]} and Liquid(..., liquid_config={'extends_dir': [...]} , respectively. If nothing found there, it will look for the template in the directory where the one cites them. If the template citing them is from a string, it will search in the current working directory ( ./ , the directory the main program is running from) One can also specify include_dir and extends_dir by config tag when strict is off while constructing the Liquid object: Liquid ( ... , liquid_config = { 'strict' : False }) strict is True by default. See Configuration for more details.","title":"Tag extends"},{"location":"additional_tags/#tag-config","text":"See Configuration","title":"Tag config"},{"location":"changelog/","text":"0.6.3 Allow tag for to have output(test | filter) in python mode. Fix stacks not print in some cases. Avoid closing stream after parsing Add better error message for attribute error while rendering Print 'KeyError' for render error if it is a KeyError. 0.6.2 Update dependency versions 0.6.1 Fix use of LiquidPython Add getitem and render filter for python mode Fix EmptyDrop for variable segment in python mode Fix re-rendering error for extends tag (#29) 0.6.0 Remodel the package to use a lexer to scan the nodes first and then lark-parse to parse the tag. 0.5.0 Extract major model of node to allow register_node (#18) Introduce config node and deprecate mode Allow specification of directories to scan for include and extends (#19) Add loglevel detail to enable verbosity between info and debug Allow passing variables to included templates (#8) Disallow variables in parent templates to be modified in included templates Require backtick ( ` ) for liquidpy expression to be used in statement nodes Add API documentations 0.4.0 Implement issue #13: Adding ternary end modifier ( $ ) Expand list/dict context in debug information 0.3.0 Force explict modifiers (=/!) for True/False action in ternary filters Add combined ternary filters Add shortcut ? for ?bool Use the maximum lineno on traceback instead of the last one. 0.2.3 Fix parsing errors when unicode in a template loaded from text #10 (thanks to vermeeca) 0.2.2 Show shortened context in debug information Fix #9: stream cursor shifted when unicode in the template. 0.2.1 Fix #7: forloop problem with nesting for statements Fix other bugs 0.2.0 Add inclusion and inheritance support Add cycle for for loop 0.1.0 Rewrite whole engine using a stream parser Support multi-line for statements, expressions and tag comments (#1) Support wrapper (instead of a single prefix) for statement comments Add from and import shortcuts to import python modules Support expressions in if/unless/while statements Support liquid forloop object for for statement (#2) Improve debug information Add arguemtn position specification for filters Add tenary filters Remove & modifiers 0.0.7 Allow {% mode %} block to be anywhere in the source code Full the coverage Change support only for python3.5+ 0.0.6 Add modifiers & and * to allow chaining and expanding arguments","title":"Change log"},{"location":"changelog/#063","text":"Allow tag for to have output(test | filter) in python mode. Fix stacks not print in some cases. Avoid closing stream after parsing Add better error message for attribute error while rendering Print 'KeyError' for render error if it is a KeyError.","title":"0.6.3"},{"location":"changelog/#062","text":"Update dependency versions","title":"0.6.2"},{"location":"changelog/#061","text":"Fix use of LiquidPython Add getitem and render filter for python mode Fix EmptyDrop for variable segment in python mode Fix re-rendering error for extends tag (#29)","title":"0.6.1"},{"location":"changelog/#060","text":"Remodel the package to use a lexer to scan the nodes first and then lark-parse to parse the tag.","title":"0.6.0"},{"location":"changelog/#050","text":"Extract major model of node to allow register_node (#18) Introduce config node and deprecate mode Allow specification of directories to scan for include and extends (#19) Add loglevel detail to enable verbosity between info and debug Allow passing variables to included templates (#8) Disallow variables in parent templates to be modified in included templates Require backtick ( ` ) for liquidpy expression to be used in statement nodes Add API documentations","title":"0.5.0"},{"location":"changelog/#040","text":"Implement issue #13: Adding ternary end modifier ( $ ) Expand list/dict context in debug information","title":"0.4.0"},{"location":"changelog/#030","text":"Force explict modifiers (=/!) for True/False action in ternary filters Add combined ternary filters Add shortcut ? for ?bool Use the maximum lineno on traceback instead of the last one.","title":"0.3.0"},{"location":"changelog/#023","text":"Fix parsing errors when unicode in a template loaded from text #10 (thanks to vermeeca)","title":"0.2.3"},{"location":"changelog/#022","text":"Show shortened context in debug information Fix #9: stream cursor shifted when unicode in the template.","title":"0.2.2"},{"location":"changelog/#021","text":"Fix #7: forloop problem with nesting for statements Fix other bugs","title":"0.2.1"},{"location":"changelog/#020","text":"Add inclusion and inheritance support Add cycle for for loop","title":"0.2.0"},{"location":"changelog/#010","text":"Rewrite whole engine using a stream parser Support multi-line for statements, expressions and tag comments (#1) Support wrapper (instead of a single prefix) for statement comments Add from and import shortcuts to import python modules Support expressions in if/unless/while statements Support liquid forloop object for for statement (#2) Improve debug information Add arguemtn position specification for filters Add tenary filters Remove & modifiers","title":"0.1.0"},{"location":"changelog/#007","text":"Allow {% mode %} block to be anywhere in the source code Full the coverage Change support only for python3.5+","title":"0.0.7"},{"location":"changelog/#006","text":"Add modifiers & and * to allow chaining and expanding arguments","title":"0.0.6"},{"location":"configuration/","text":"Configuration from Liquid constructor Initial configurations can be set via liquid_config argument: Liquid ( template , liquid_config = { 'item1' : 'value1' , 'item2' : 'value2' , ... }, ** envs ) Avaiable items are: mode : Specify the mode of the engine, either standard or python . strict : If True, some insecure tags, where potentially arbitrary code can be run, will not be allowed, including config , python , from and import . debug : Show debug information for parsing and rendering the template. extends_dir : A list of base directories to find the relative path of parent templates specified in extends tag. First directory has the highest priority. include_dir : Similar to extends_dir , but for include tag. Configuration from config tag One can also override some of the configuration items with a config tag in a template: {% config item1 = value 1 item2 = value 2 ... %} If you want to set an item to True, then you can omit the value part, like this: {% config item 1 item 2 %} Configuration item strict is NOT allowed to overriden in config tag. And extends_dir and include_dir support only single value instead of a list. debug only affects the template where the config tag is located. Note Only constants are allowed for the values (numbers, strings, None (nil), True (true), and False (false))","title":"Configuration"},{"location":"configuration/#configuration-from-liquid-constructor","text":"Initial configurations can be set via liquid_config argument: Liquid ( template , liquid_config = { 'item1' : 'value1' , 'item2' : 'value2' , ... }, ** envs ) Avaiable items are: mode : Specify the mode of the engine, either standard or python . strict : If True, some insecure tags, where potentially arbitrary code can be run, will not be allowed, including config , python , from and import . debug : Show debug information for parsing and rendering the template. extends_dir : A list of base directories to find the relative path of parent templates specified in extends tag. First directory has the highest priority. include_dir : Similar to extends_dir , but for include tag.","title":"Configuration from Liquid constructor"},{"location":"configuration/#configuration-from-config-tag","text":"One can also override some of the configuration items with a config tag in a template: {% config item1 = value 1 item2 = value 2 ... %} If you want to set an item to True, then you can omit the value part, like this: {% config item 1 item 2 %} Configuration item strict is NOT allowed to overriden in config tag. And extends_dir and include_dir support only single value instead of a list. debug only affects the template where the config tag is located. Note Only constants are allowed for the values (numbers, strings, None (nil), True (true), and False (false))","title":"Configuration from config tag"},{"location":"extending/","text":"One can extend liquidpy in both modes by adding or removing tags and filters. Registering tags To define a new tag, one should subclass the Tag class ( TagPython for tags in python mode). from liquid import Tag , tag_manager @tag_manager . register class TagEcho ( Tag ): # the start rule START = 'tag_echo' # the grammar based on the base_grammar GRAMMAR = 'tag_echo: output' def parse ( self , force = False ): # Use the default parser to parse the output rule return super () . parse ( force ) def _render ( self , local_vars , global_vars ): # render the parsed rule return self . parsed . render ( local_vars , global_vars ) You would like to check grammar for lark-parser, as well as the base grammar at tags/grammar.lark or python/tags/grammar.lark for python mode Also check the implementation for the bulting tags. The above tag implements the same function as the output tag {{ ... }} by {% echo ... %} . To register the tag with different names, you can add names to the tag_manager.register function: @tag_manager . register ( 'print, echo' ) # or @tag_manager . register ([ 'print' , 'echo' ]) # or Then you can do {% print ... %} or {% echo ... %} To create and register a tag for python mode: from liquid import tag_manager , TagPython @tag_manager . register ( mode = 'python' ) class TagEcho ( TagPython ): ... # or from python import tag_manager_python , TagPython @tag_manager_python . register class TagEcho ( TagPython ): ... Unregistering tags If you want to unregister/disable a tag: tag_class = tag_manager . unregister ( 'echo' ) The class is returned from unregister function, which, later on, in a case you want to register it back: tag_manager . register ( 'echo' )( tag_class ) Note If you registered a tag with multiple names (say echo and print ), and only unregistered echo , then print tag is still avaliable in the template. To unregister both of them: tag_manager . unregister ( 'echo' ) tag_manager . unregister ( 'print' ) If you want to do this for python mode, use tag_manager_python or tag_manager.register(..., mode='python') / tag_manager.unregister(..., mode='python') Registering filters Filters are just functions: from liquid import filter_manager @filter_manager . register def incr ( base , inc = 1 ): return base + inc {{ 1 | incr }} {% comment %} // 2 {% end comment%} {{ 1 | incr : 2 }} {% comment %} // 3 {% end comment%} Similar to tag register, filters can also be registered with different names: from liquid import filter_manager @filter_manager . register ( 'increment' ) def incr ( base , inc = 1 ): return base + inc # use it in template: # {{ 1 | increment }} For standard mode, the base value has to be the first argument of a filter. But for python mode, filters are more flexible. For the above filter, to register it for python mode: @filter_manager . register ( mode = 'python' ) # or from liquid import filter_manager_python @filter_manager_python . register It is available to pass the base value as the second argument: {{ 2 | incr : 1 , _ }} {% comment %} // 3 {% end comment%} See filters for more information. Additionally, in python mode, callables in locals/globals are also available working as filters {{ \"foo\" | len }} {% comment %} // 3 {% end comment%} One can also define a lambda function in the template to work as a filter: {% assign len_plus_1 = lambda x : len(x) + 1 %} {{ \"foo\" | len_plus_1 }} {% comment %} // 4 {% end comment%} Unregistering filters Same as tag unregister, a function is returned from filter_manager.unregester for later re-register. Warning Unregistering a filter in python model is only available for the filters registered by filter_manager or filter_manager_python .","title":"Extending liquidpy"},{"location":"extending/#registering-tags","text":"To define a new tag, one should subclass the Tag class ( TagPython for tags in python mode). from liquid import Tag , tag_manager @tag_manager . register class TagEcho ( Tag ): # the start rule START = 'tag_echo' # the grammar based on the base_grammar GRAMMAR = 'tag_echo: output' def parse ( self , force = False ): # Use the default parser to parse the output rule return super () . parse ( force ) def _render ( self , local_vars , global_vars ): # render the parsed rule return self . parsed . render ( local_vars , global_vars ) You would like to check grammar for lark-parser, as well as the base grammar at tags/grammar.lark or python/tags/grammar.lark for python mode Also check the implementation for the bulting tags. The above tag implements the same function as the output tag {{ ... }} by {% echo ... %} . To register the tag with different names, you can add names to the tag_manager.register function: @tag_manager . register ( 'print, echo' ) # or @tag_manager . register ([ 'print' , 'echo' ]) # or Then you can do {% print ... %} or {% echo ... %} To create and register a tag for python mode: from liquid import tag_manager , TagPython @tag_manager . register ( mode = 'python' ) class TagEcho ( TagPython ): ... # or from python import tag_manager_python , TagPython @tag_manager_python . register class TagEcho ( TagPython ): ...","title":"Registering tags"},{"location":"extending/#unregistering-tags","text":"If you want to unregister/disable a tag: tag_class = tag_manager . unregister ( 'echo' ) The class is returned from unregister function, which, later on, in a case you want to register it back: tag_manager . register ( 'echo' )( tag_class ) Note If you registered a tag with multiple names (say echo and print ), and only unregistered echo , then print tag is still avaliable in the template. To unregister both of them: tag_manager . unregister ( 'echo' ) tag_manager . unregister ( 'print' ) If you want to do this for python mode, use tag_manager_python or tag_manager.register(..., mode='python') / tag_manager.unregister(..., mode='python')","title":"Unregistering tags"},{"location":"extending/#registering-filters","text":"Filters are just functions: from liquid import filter_manager @filter_manager . register def incr ( base , inc = 1 ): return base + inc {{ 1 | incr }} {% comment %} // 2 {% end comment%} {{ 1 | incr : 2 }} {% comment %} // 3 {% end comment%} Similar to tag register, filters can also be registered with different names: from liquid import filter_manager @filter_manager . register ( 'increment' ) def incr ( base , inc = 1 ): return base + inc # use it in template: # {{ 1 | increment }} For standard mode, the base value has to be the first argument of a filter. But for python mode, filters are more flexible. For the above filter, to register it for python mode: @filter_manager . register ( mode = 'python' ) # or from liquid import filter_manager_python @filter_manager_python . register It is available to pass the base value as the second argument: {{ 2 | incr : 1 , _ }} {% comment %} // 3 {% end comment%} See filters for more information. Additionally, in python mode, callables in locals/globals are also available working as filters {{ \"foo\" | len }} {% comment %} // 3 {% end comment%} One can also define a lambda function in the template to work as a filter: {% assign len_plus_1 = lambda x : len(x) + 1 %} {{ \"foo\" | len_plus_1 }} {% comment %} // 4 {% end comment%}","title":"Registering filters"},{"location":"extending/#unregistering-filters","text":"Same as tag unregister, a function is returned from filter_manager.unregester for later re-register. Warning Unregistering a filter in python model is only available for the filters registered by filter_manager or filter_manager_python .","title":"Unregistering filters"},{"location":"filters/","text":"Filters in python mode are more flexible then the ones in standard mode: Base value does not have to be the first argument of the filter. One can use _ as a placeholder for the base value Keyword arguments are allowed to call the filter from liquid import filter_manager_python @filter_manager_python . register ( 'sum' ) def filter_sum ( a = 1 , b = 2 , c = 3 ): return a + b + c To call it with base value as second argument: {{ 4 | filter_sum : 1 , _ }} {% comment %} // 1 + 4 + 3 = 8 {% endcomment %} To call it with keyword arguments: {{ 4 | filter_sum : b = 1 }} {% comment %} // 4 + 1 + 3 = 8 {% endcomment %} Liquid filters liquidpy support all Liquid filters. However, for some of them, there is no EmptyDrop object returned. Instead, it returns the object, which is treated empty in python. For example: Liquid ( '{{ x | sort }}' ) . render ( x = []) # x will be an EmptyDrop object if rendered in standard mode, but # still [] if rendered in python mode Simple filters These filters are callable object from python builtins or defined in the template with a simple name. For example: Liquid ( '{{\"foo\" | len}}' , { 'mode' : 'python' }) . render () # // 3 One can also pass in a filter: Liquid ( '{{\"foo\" | concat}}' , { 'mode' : 'python' }) . render ( concat = lambda x : x + 'bar' ) # // foobar A filter can be even defined from inside the template: Liquid ( \"\"\" { %- a ssign concat = lambda x: x + 'bar' -%} {{ \"foo\" | concat }}\"\"\" , { 'mode' : 'python' }) . render () # // foobar However, when you have a filter that is not with a simple name, for example, in a list, you have to use a complex filter. render This filter allows one to render a template in pythom mode from inside a template: LiquidPython ( '{{ tpl | render }}' ) . render ( tpl = \"{{x}}\" , x = 1 ) # // '1' LiquidPython ( '{{ tpl | render: x=2 }}' ) . render ( tpl = \"{{x}}\" , x = 1 ) # // '2' Complex filters They are nothing but just filters with a @ modifier, when the filter needs to be computed (ie, an attribute of an object, an element of a list, etc): from os import path Liquid ( '{{ \"/path\" | @path.join: \"to\" }}' , { 'mode' : 'python' } ) . render ( path = path ) # // /path/to from os import path filters = [ path . join ] Liquid ( '{{ \"/path\" | @filters[0]: \"to\" }}' , { 'mode' : 'python' } ) . render ( filters = filters ) # // /path/to Since the base value from the output tag ( {{ ... }} ) can also be an iterable or a dictionary, we also support * and ** modifiers for simple and complex filters to expand the values: from os import path Liquid ( '{{ (\"/path\", \"to\") | *@path.join }}' , { 'mode' : 'python' } ) . render ( path = path ) # // /path/to Liquid ( ''' { % a ssign add = lambda a, b: a + b %} {{ {\"a\": 1, \"b\": 2} | **add }} ''' , { 'mode' : 'python' }) . render () # // 3 For filters in standard mode, the single base value has to be passed as the first argument of the filter. However, in python mode, you can specify it explictly in a different position: from os import path Liquid ( ''' {{ \"to\" | @path.join: \"/path\", _ }}' ''' , { 'mode' : 'python' }) . render ( path = path ) # // /path/to The underscore changes the position of the base value ( \"to\" ) from the first argument to the second. Without it, we will get to//path Note The base value placeholder ( _ ) doesn't work with expanding modifiers ( * , ** ) when you have an iteratable value or a dictionary-like object as the base value. Dot filters/Attribute filters Sometimes, we also want to use the attribute of the base value as a filter, since it can be a callable too. For example: Liquid ( '{{ \", \" | .join: [\"a\", \"b\", \"c\"] }}' , { 'mode' : 'python' }) . render () # // a, b, c You could even access some magic methods: Liquid ( '{{ \"foo\" | .__len__ }}' , { 'mode' : 'python' }) . render () # // 3 Tip To get an attribute as a value from an object, you can use getattr filter: from pathlib import Path LiquidPython ( '{{ path | getattr: \"stem\"}}' ) . render ( path = Path ( 'a/b/c.txt' ) ) # // c Subscript filters Similar to dot filters, sometimes, we also want to use the callables that are accessed by subscriptting the base value: Liquid ( '{{ base | [0] }}' , { 'mode' : 'python' }) . render ( base : [ lambda : 'Hello' ] ) # // Hello To get the first element of the list: Liquid ( '{{ base | .__getitem__: 0 }}' , { 'mode' : 'python' }) . render ( base = [ 'Hello' ] ) # // Hello Or you can also use the shortcut: LiquidPython ( '{{ base | getitem: 0 }}' ) . render ( base = [ 'Hello' ] ) # // Hello Ternary filters We also support ternary filters in python mode. The syntax is like: {{ base | [filter] ? [filter | constant] ! [filter | constant] }} {# ^^^^^^^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^ #} {# part1 part2 part3 #} You can use a filter for part1 to modify the base value, which will then be the condition value for the ternary filter. part2 could either be a filter to modify the base value when the condition value is True or just constant, including numbers, strings, None, True or False. It is the same for part3 when condition value is False. All the three parts marked above are optional. When part1 is not give, it will use the base value itself as the condition value. When part2 is not given, it will return the base value, same for part3 . So theoriatially, you can (but are not recommended to) write something like: {{ base | ? ! }} It basically means tell me if base is True or not. If it is True, return base value, and if it is False, return the base value, too. Arguments are supported for the filters, for example: tpl = '{{ base | isinstance: int ? | plus: 1 | append: \".liquid\"}}' Liquid ( tpl , { 'mode' : 'python' }) . render ( base = 1 ) # // 2 Liquid ( tpl , { 'mode' : 'python' }) . render ( base = \"1\" ) # // 1.liquid Lambda filters If all of the above filters don't meet your needs, you can also use lambda filters, which allow you to operate the base value pretty arbitrarily: tpl = '{{ base | lambda a: a ** 2 }}' Liquid ( tpl , { 'mode' : 'python' }) . render ( base = 3 ) # // 9","title":"Filters"},{"location":"filters/#liquid-filters","text":"liquidpy support all Liquid filters. However, for some of them, there is no EmptyDrop object returned. Instead, it returns the object, which is treated empty in python. For example: Liquid ( '{{ x | sort }}' ) . render ( x = []) # x will be an EmptyDrop object if rendered in standard mode, but # still [] if rendered in python mode","title":"Liquid filters"},{"location":"filters/#simple-filters","text":"These filters are callable object from python builtins or defined in the template with a simple name. For example: Liquid ( '{{\"foo\" | len}}' , { 'mode' : 'python' }) . render () # // 3 One can also pass in a filter: Liquid ( '{{\"foo\" | concat}}' , { 'mode' : 'python' }) . render ( concat = lambda x : x + 'bar' ) # // foobar A filter can be even defined from inside the template: Liquid ( \"\"\" { %- a ssign concat = lambda x: x + 'bar' -%} {{ \"foo\" | concat }}\"\"\" , { 'mode' : 'python' }) . render () # // foobar However, when you have a filter that is not with a simple name, for example, in a list, you have to use a complex filter.","title":"Simple filters"},{"location":"filters/#render","text":"This filter allows one to render a template in pythom mode from inside a template: LiquidPython ( '{{ tpl | render }}' ) . render ( tpl = \"{{x}}\" , x = 1 ) # // '1' LiquidPython ( '{{ tpl | render: x=2 }}' ) . render ( tpl = \"{{x}}\" , x = 1 ) # // '2'","title":"render"},{"location":"filters/#complex-filters","text":"They are nothing but just filters with a @ modifier, when the filter needs to be computed (ie, an attribute of an object, an element of a list, etc): from os import path Liquid ( '{{ \"/path\" | @path.join: \"to\" }}' , { 'mode' : 'python' } ) . render ( path = path ) # // /path/to from os import path filters = [ path . join ] Liquid ( '{{ \"/path\" | @filters[0]: \"to\" }}' , { 'mode' : 'python' } ) . render ( filters = filters ) # // /path/to Since the base value from the output tag ( {{ ... }} ) can also be an iterable or a dictionary, we also support * and ** modifiers for simple and complex filters to expand the values: from os import path Liquid ( '{{ (\"/path\", \"to\") | *@path.join }}' , { 'mode' : 'python' } ) . render ( path = path ) # // /path/to Liquid ( ''' { % a ssign add = lambda a, b: a + b %} {{ {\"a\": 1, \"b\": 2} | **add }} ''' , { 'mode' : 'python' }) . render () # // 3 For filters in standard mode, the single base value has to be passed as the first argument of the filter. However, in python mode, you can specify it explictly in a different position: from os import path Liquid ( ''' {{ \"to\" | @path.join: \"/path\", _ }}' ''' , { 'mode' : 'python' }) . render ( path = path ) # // /path/to The underscore changes the position of the base value ( \"to\" ) from the first argument to the second. Without it, we will get to//path Note The base value placeholder ( _ ) doesn't work with expanding modifiers ( * , ** ) when you have an iteratable value or a dictionary-like object as the base value.","title":"Complex filters"},{"location":"filters/#dot-filtersattribute-filters","text":"Sometimes, we also want to use the attribute of the base value as a filter, since it can be a callable too. For example: Liquid ( '{{ \", \" | .join: [\"a\", \"b\", \"c\"] }}' , { 'mode' : 'python' }) . render () # // a, b, c You could even access some magic methods: Liquid ( '{{ \"foo\" | .__len__ }}' , { 'mode' : 'python' }) . render () # // 3 Tip To get an attribute as a value from an object, you can use getattr filter: from pathlib import Path LiquidPython ( '{{ path | getattr: \"stem\"}}' ) . render ( path = Path ( 'a/b/c.txt' ) ) # // c","title":"Dot filters/Attribute filters"},{"location":"filters/#subscript-filters","text":"Similar to dot filters, sometimes, we also want to use the callables that are accessed by subscriptting the base value: Liquid ( '{{ base | [0] }}' , { 'mode' : 'python' }) . render ( base : [ lambda : 'Hello' ] ) # // Hello To get the first element of the list: Liquid ( '{{ base | .__getitem__: 0 }}' , { 'mode' : 'python' }) . render ( base = [ 'Hello' ] ) # // Hello Or you can also use the shortcut: LiquidPython ( '{{ base | getitem: 0 }}' ) . render ( base = [ 'Hello' ] ) # // Hello","title":"Subscript filters"},{"location":"filters/#ternary-filters","text":"We also support ternary filters in python mode. The syntax is like: {{ base | [filter] ? [filter | constant] ! [filter | constant] }} {# ^^^^^^^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^ #} {# part1 part2 part3 #} You can use a filter for part1 to modify the base value, which will then be the condition value for the ternary filter. part2 could either be a filter to modify the base value when the condition value is True or just constant, including numbers, strings, None, True or False. It is the same for part3 when condition value is False. All the three parts marked above are optional. When part1 is not give, it will use the base value itself as the condition value. When part2 is not given, it will return the base value, same for part3 . So theoriatially, you can (but are not recommended to) write something like: {{ base | ? ! }} It basically means tell me if base is True or not. If it is True, return base value, and if it is False, return the base value, too. Arguments are supported for the filters, for example: tpl = '{{ base | isinstance: int ? | plus: 1 | append: \".liquid\"}}' Liquid ( tpl , { 'mode' : 'python' }) . render ( base = 1 ) # // 2 Liquid ( tpl , { 'mode' : 'python' }) . render ( base = \"1\" ) # // 1.liquid","title":"Ternary filters"},{"location":"filters/#lambda-filters","text":"If all of the above filters don't meet your needs, you can also use lambda filters, which allow you to operate the base value pretty arbitrarily: tpl = '{{ base | lambda a: a ** 2 }}' Liquid ( tpl , { 'mode' : 'python' }) . render ( base = 3 ) # // 9","title":"Lambda filters"},{"location":"intro/","text":"liquidpy is compatible with standard liquid template engine . Variations such as Shopify and Jekyll are not fully supported yet. Other than that, we have some additional tags supported, including block, include, extends and config. We also have a python mode to support syntax more close to python. To check the documentation for standard liquid template engine, see here . For additional tags to the standard mode, see Additional Tags For documentation for python mode, check the rest of this documentation. Python mode has the exactly same whitespace control as the standard mode does (the standard liquid template engine). To enable python mode, you can either specify mode to python: from liquid import Liquid Liquid ( template , liquid_config = { 'mode' : 'python' }) or use LiquidPython from liquid import LiquidPython LiquidPython ( template )","title":"Introduction"},{"location":"tags/","text":"Except for the tags introducted in Additional Tags , python mode also support following tags, some of which act exactly the same as the ones from standard mode, but some not. Comment Any content in {# ... #} will be intepreted as a comment, and will be ignored in rendering. It works like a shortcut for {% comment %} ... {% endcomment %} with the difference that no other tags allowed inside {# ... #} It also has whitespace-control verions: {#- ... #} {# Right whitespaces of prior literals are trimmed #} {# ... -#} {# Left whitespaces of next literals are trimmed #} {#- ... -#} {# Right whitespaces of prior literals and #} {# left whitespaces of next literals are trimmed #} Control flow if Executes a block of code only if a certain condition is True {% if condition %} Executed when condition is True {% endif %} Filters are also allowed for the condition : {% if condition | filter : args | another_filter : args %} ... {% endif %} unless Executes a block of code only if a certain condition is False It's equvalent to {% if not (condition) %} else/elsif/elif/else if Adds more conditions within if/unless block. else also works with for and while blocks elif is an alias for elseif to make it more like a python syntax else if works the same as elif/elsif . {% if customer . name == \"kevin\" %} Hey Kevin! {% elif customer.name = = \"anonymous\" %} Hey Anonymous! {% else %} Hi Stranger! {% endif %} case/when Creates a switch statement to compare a variable with different values. case initializes the switch statement, and when compares its values. {% assign handle = \"cake\" %} {% case handle %} {% when \"cake\" %} This is a cake {% when \"cookie\" %} This is a cookie {% else %} This is not a cake nor a cookie {% endcase %} Filters are also allowed for case and when tag. Iteration tablerow tag is abandoned in python mode for for tag works a little differently than it does in standard mode. We don't have forloop object inside the block, but we enable multiple-variable iteration and filters in the variable to loop over: No parameters are allowed for for tag like in standard mode. {% for key , val in d.items() : %} ... {% endfor %} {% for i , elem in elements | enumerate %} ... {% endfor %} {% else %} is also allowed within the block, which works just like the for ... else pair in python. while Works similar to for . Filters are allowed, and with {% else %} , it works like the while ... else pair in python. {% assign a = 10 %} {% while a %} a is now: {{ a }} {% if a == 3 %} {% break %} {% endif %} {% assign a = a - 1 %} {% endwhile %} cycle Works the same as it in standard mode. See cycle . Raw raw tag works exactly like it in standard mode. See raw Variable assign Creates or modifies a new variable. Filters allowed for the value. Note Variables created by this tag is only available in the same block where it is defined. But the variable it modifies is still available in the block where it is initially defined. capture Works the same as it does in standard mode. See capture . increment Works the same as it does in standard mode. See increment decrement Works the same as it does in standard mode. See decrement Python-related tags python A block to execute python codes. Danger Arbitrary codes may be executed in the block, so it is not allowed when strict is True. Use it only when you know what will be executed. Single-line code: {% python func = lambda a : a+ 1 %} Multiple-line code: {% python %} def func(a): return a + 1 {% endpython %} You may also include other tags in the multi-line python tag: {% python %} {% if x | isinstance : int %} def func(a): return a + 1 {% else %} def func(a): return a + ' is a string.' {% endif %} {% endpython %} import A shortcut for {% python import ... %} to import packages/modules from python {% import os %} Danger import tag is not allowed when strict is True. from A shortcut for {% python from ... import ... %} to import packages/modules from python {% from os import path %} Danger from tag is not allowed when strict is True. Config See Configuration","title":"Tags"},{"location":"tags/#comment","text":"Any content in {# ... #} will be intepreted as a comment, and will be ignored in rendering. It works like a shortcut for {% comment %} ... {% endcomment %} with the difference that no other tags allowed inside {# ... #} It also has whitespace-control verions: {#- ... #} {# Right whitespaces of prior literals are trimmed #} {# ... -#} {# Left whitespaces of next literals are trimmed #} {#- ... -#} {# Right whitespaces of prior literals and #} {# left whitespaces of next literals are trimmed #}","title":"Comment"},{"location":"tags/#control-flow","text":"","title":"Control flow"},{"location":"tags/#if","text":"Executes a block of code only if a certain condition is True {% if condition %} Executed when condition is True {% endif %} Filters are also allowed for the condition : {% if condition | filter : args | another_filter : args %} ... {% endif %}","title":"if"},{"location":"tags/#unless","text":"Executes a block of code only if a certain condition is False It's equvalent to {% if not (condition) %}","title":"unless"},{"location":"tags/#elseelsifelifelse-if","text":"Adds more conditions within if/unless block. else also works with for and while blocks elif is an alias for elseif to make it more like a python syntax else if works the same as elif/elsif . {% if customer . name == \"kevin\" %} Hey Kevin! {% elif customer.name = = \"anonymous\" %} Hey Anonymous! {% else %} Hi Stranger! {% endif %}","title":"else/elsif/elif/else if"},{"location":"tags/#casewhen","text":"Creates a switch statement to compare a variable with different values. case initializes the switch statement, and when compares its values. {% assign handle = \"cake\" %} {% case handle %} {% when \"cake\" %} This is a cake {% when \"cookie\" %} This is a cookie {% else %} This is not a cake nor a cookie {% endcase %} Filters are also allowed for case and when tag.","title":"case/when"},{"location":"tags/#iteration","text":"tablerow tag is abandoned in python mode","title":"Iteration"},{"location":"tags/#for","text":"for tag works a little differently than it does in standard mode. We don't have forloop object inside the block, but we enable multiple-variable iteration and filters in the variable to loop over: No parameters are allowed for for tag like in standard mode. {% for key , val in d.items() : %} ... {% endfor %} {% for i , elem in elements | enumerate %} ... {% endfor %} {% else %} is also allowed within the block, which works just like the for ... else pair in python.","title":"for"},{"location":"tags/#while","text":"Works similar to for . Filters are allowed, and with {% else %} , it works like the while ... else pair in python. {% assign a = 10 %} {% while a %} a is now: {{ a }} {% if a == 3 %} {% break %} {% endif %} {% assign a = a - 1 %} {% endwhile %}","title":"while"},{"location":"tags/#cycle","text":"Works the same as it in standard mode. See cycle .","title":"cycle"},{"location":"tags/#raw","text":"raw tag works exactly like it in standard mode. See raw","title":"Raw"},{"location":"tags/#variable","text":"","title":"Variable"},{"location":"tags/#assign","text":"Creates or modifies a new variable. Filters allowed for the value. Note Variables created by this tag is only available in the same block where it is defined. But the variable it modifies is still available in the block where it is initially defined.","title":"assign"},{"location":"tags/#capture","text":"Works the same as it does in standard mode. See capture .","title":"capture"},{"location":"tags/#increment","text":"Works the same as it does in standard mode. See increment","title":"increment"},{"location":"tags/#decrement","text":"Works the same as it does in standard mode. See decrement","title":"decrement"},{"location":"tags/#python-related-tags","text":"","title":"Python-related tags"},{"location":"tags/#python","text":"A block to execute python codes. Danger Arbitrary codes may be executed in the block, so it is not allowed when strict is True. Use it only when you know what will be executed. Single-line code: {% python func = lambda a : a+ 1 %} Multiple-line code: {% python %} def func(a): return a + 1 {% endpython %} You may also include other tags in the multi-line python tag: {% python %} {% if x | isinstance : int %} def func(a): return a + 1 {% else %} def func(a): return a + ' is a string.' {% endif %} {% endpython %}","title":"python"},{"location":"tags/#import","text":"A shortcut for {% python import ... %} to import packages/modules from python {% import os %} Danger import tag is not allowed when strict is True.","title":"import"},{"location":"tags/#from","text":"A shortcut for {% python from ... import ... %} to import packages/modules from python {% from os import path %} Danger from tag is not allowed when strict is True.","title":"from"},{"location":"tags/#config","text":"See Configuration","title":"Config"},{"location":"api/liquid.config/","text":"module liquid . config </> The configuration for liquidpy Attributes DEFAULT_CONFIG \u2014 The default configuration LIQUID_EXC_CODE_CONTEXT \u2014 The number of context lines to show codes in exceptions when debug is on LIQUID_EXC_MAX_STACKS \u2014 The stacks to show in exceptions when debug is on LIQUID_FILTERS_ENVNAME \u2014 The variable containing all filters LIQUID_LOGGER_NAME \u2014 The name of the logger LIQUID_LOG_INDENT \u2014 Indentions to show the tree structure in logging Classes Config \u2014 The configurations for liquidpy </> class liquid.config . Config ( *args , **kwargs ) </> Bases diot.diot.Diot dict The configurations for liquidpy Parameters *args \u2014 Anything that can be sent to dict construct **kwargs \u2014 keyword argument that can be sent to dict construct Some diot configurations can also be passed, including: diot_nest: Types to nestly convert values diot_transform: The transforms for keys diot_frozen: Whether to generate a frozen diot. True: freeze the object recursively if there are Diot objects in descendants False: Don'f freeze 'shallow': Only freeze at depth = 1 Methods __contains__ ( name ) (bool) \u2014 True if the dictionary has the specified key, else False. </> __delitem__ ( name ) \u2014 Delete self[key]. </> __delitem__ ( name ) \u2014 Delete self[key]. </> __getitem__ ( name ) (any) \u2014 x. getitem (y) <==> x[y] </> __setitem__ ( name , value ) \u2014 Set self[key] to value. </> accessible_keys ( ) (iterable of str) \u2014 Get the converted keys </> clear ( ) \u2014 Clear the object </> copy ( ) (Diot) \u2014 Shallow copy the object </> copy ( ) (Diot) \u2014 Shallow copy the object </> freeze ( frozen ) \u2014 Freeze the diot object </> from_namespace ( namespace , recursive , diot_nest , diot_transform , diot_frozen ) (Diot) \u2014 Get a Diot object from an argparse namespace </> get ( name , value ) (any) \u2014 Get the value of a key name </> pop ( name , *value ) (any) \u2014 Pop a key from the object and return the value. If key does not exist, return the given default value </> popitem ( ) (str, any) \u2014 Pop last item from the object </> setdefault ( name , value ) (any) \u2014 Set a default value to a key </> thaw ( recursive ) \u2014 A context manager for temporarily change the diot </> to_dict ( ) (dict(str: any)) \u2014 Turn the Box and sub Boxes back into a native python dictionary. </> to_dict ( ) (dict(str: any)) \u2014 Turn the Box and sub Boxes back into a native python dictionary. </> to_dict ( ) (dict(str: any)) \u2014 Turn the Box and sub Boxes back into a native python dictionary. </> to_json ( filename , encoding , errors , **json_kwargs ) (str, optional) \u2014 Convert to a json string or save it to json file </> to_json ( filename , encoding , errors , **json_kwargs ) (str, optional) \u2014 Convert to a json string or save it to json file </> to_json ( filename , encoding , errors , **json_kwargs ) (str, optional) \u2014 Convert to a json string or save it to json file </> to_toml ( filename , encoding , errors ) (str, optional) \u2014 Convert to a toml string or save it to toml file </> to_toml ( filename , encoding , errors ) (str, optional) \u2014 Convert to a toml string or save it to toml file </> to_toml ( filename , encoding , errors ) (str, optional) \u2014 Convert to a toml string or save it to toml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (str, optional) \u2014 Convert to a yaml string or save it to yaml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (str, optional) \u2014 Convert to a yaml string or save it to yaml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (str, optional) \u2014 Convert to a yaml string or save it to yaml file </> unfreeze ( recursive ) \u2014 Unfreeze the diot object </> update ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> update_logger ( ) \u2014 Update the logger configuration according to the configuration </> classmethod from_namespace ( namespace , recursive=True , diot_nest=True , diot_transform='safe' , diot_frozen=False ) </> Get a Diot object from an argparse namespace Example >>> from argparse import Namespace >>> Diot . from_namespace ( Namespace ( a = 1 , b = 2 )) Parameters namespace (Namespace) \u2014 The namespace object recursive (bool, optional) \u2014 Do it recursively? diot_nest (Union(bool, iterable of type), optional) \u2014 Types to nestly convert values diot_transform (Union(callable(str: str), str), optional) \u2014 The transforms for keys diot_frozen (bool or str, optional) \u2014 Whether to generate a frozen diot. True: freeze the object recursively if there are Diot objects in descendants False: Don'f freeze 'shallow': Only freeze at depth = 1 Returns (Diot) The converted diot object. method __setitem__ ( name , value ) </> Set self[key] to value. method __getitem__ ( name ) \u2192 any </> x. getitem (y) <==> x[y] method pop ( name , *value ) </> Pop a key from the object and return the value. If key does not exist, return the given default value Parameters name (str) \u2014 The key Returns (any) The value corresponding to the name or the default value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method popitem ( ) </> Pop last item from the object Returns (str, any) A tuple of key and value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method update ( *value , **kwargs ) </> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method __delitem__ ( name ) </> Delete self[key]. method __delitem__ ( name ) </> Delete self[key]. method freeze ( frozen='shallow' ) </> Freeze the diot object Parameters frozen (str or bool, optional) \u2014 The frozen argument indicating how to freeze: shallow: only freeze at depth=1 True: freeze recursively if there are diot objects in children False: Disable freezing method unfreeze ( recursive=False ) </> Unfreeze the diot object Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively generator thaw ( recursive=False ) </> A context manager for temporarily change the diot Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively Yields self, the reference to this diot. method setdefault ( name , value ) </> Set a default value to a key Parameters name (str) \u2014 The key name value (any) \u2014 The default value Returns (any) The existing value or the value passed in Raises DiotFrozenError \u2014 when try to set default to a frozen diot method accessible_keys ( ) </> Get the converted keys Returns (iterable of str) The accessible (transformed) keys method get ( name , value=None ) </> Get the value of a key name Parameters name (str) \u2014 The key name value (any, optional) \u2014 The value to return if the key does not exist Returns (any) The corresponding value or the value passed in if the key does not exist method __contains__ ( name ) \u2192 bool </> True if the dictionary has the specified key, else False. method clear ( ) </> Clear the object method copy ( ) </> Shallow copy the object Returns (Diot) The copied object method copy ( ) </> Shallow copy the object Returns (Diot) The copied object method to_dict ( ) </> Turn the Box and sub Boxes back into a native python dictionary. Returns (dict(str: any)) The converted python dictionary method to_dict ( ) </> Turn the Box and sub Boxes back into a native python dictionary. Returns (dict(str: any)) The converted python dictionary method to_dict ( ) </> Turn the Box and sub Boxes back into a native python dictionary. Returns (dict(str: any)) The converted python dictionary method to_json ( filename=None , encoding='utf-8' , errors='strict' , **json_kwargs ) </> Convert to a json string or save it to json file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the json to, if not given a json string will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (str, optional) The json string with filename is not given method to_json ( filename=None , encoding='utf-8' , errors='strict' , **json_kwargs ) </> Convert to a json string or save it to json file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the json to, if not given a json string will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (str, optional) The json string with filename is not given method to_json ( filename=None , encoding='utf-8' , errors='strict' , **json_kwargs ) </> Convert to a json string or save it to json file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the json to, if not given a json string will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (str, optional) The json string with filename is not given method to_yaml ( filename=None , default_flow_style=False , encoding='utf-8' , errors='strict' , **yaml_kwargs ) </> Convert to a yaml string or save it to yaml file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the yaml to, if not given a yaml string will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumping See yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (str, optional) The yaml string with filename is not given method to_yaml ( filename=None , default_flow_style=False , encoding='utf-8' , errors='strict' , **yaml_kwargs ) </> Convert to a yaml string or save it to yaml file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the yaml to, if not given a yaml string will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumping See yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (str, optional) The yaml string with filename is not given method to_yaml ( filename=None , default_flow_style=False , encoding='utf-8' , errors='strict' , **yaml_kwargs ) </> Convert to a yaml string or save it to yaml file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the yaml to, if not given a yaml string will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumping See yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (str, optional) The yaml string with filename is not given method to_toml ( filename=None , encoding='utf-8' , errors='strict' ) </> Convert to a toml string or save it to toml file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the toml to, if not given a toml string will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function Returns (str, optional) The toml string with filename is not given method to_toml ( filename=None , encoding='utf-8' , errors='strict' ) </> Convert to a toml string or save it to toml file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the toml to, if not given a toml string will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function Returns (str, optional) The toml string with filename is not given method to_toml ( filename=None , encoding='utf-8' , errors='strict' ) </> Convert to a toml string or save it to toml file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the toml to, if not given a toml string will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function Returns (str, optional) The toml string with filename is not given method update_logger ( ) </> Update the logger configuration according to the configuration","title":"liquid.config"},{"location":"api/liquid.config/#liquidconfig","text":"</> The configuration for liquidpy Attributes DEFAULT_CONFIG \u2014 The default configuration LIQUID_EXC_CODE_CONTEXT \u2014 The number of context lines to show codes in exceptions when debug is on LIQUID_EXC_MAX_STACKS \u2014 The stacks to show in exceptions when debug is on LIQUID_FILTERS_ENVNAME \u2014 The variable containing all filters LIQUID_LOGGER_NAME \u2014 The name of the logger LIQUID_LOG_INDENT \u2014 Indentions to show the tree structure in logging Classes Config \u2014 The configurations for liquidpy </> class","title":"liquid.config"},{"location":"api/liquid.config/#liquidconfigconfig","text":"</> Bases diot.diot.Diot dict The configurations for liquidpy Parameters *args \u2014 Anything that can be sent to dict construct **kwargs \u2014 keyword argument that can be sent to dict construct Some diot configurations can also be passed, including: diot_nest: Types to nestly convert values diot_transform: The transforms for keys diot_frozen: Whether to generate a frozen diot. True: freeze the object recursively if there are Diot objects in descendants False: Don'f freeze 'shallow': Only freeze at depth = 1 Methods __contains__ ( name ) (bool) \u2014 True if the dictionary has the specified key, else False. </> __delitem__ ( name ) \u2014 Delete self[key]. </> __delitem__ ( name ) \u2014 Delete self[key]. </> __getitem__ ( name ) (any) \u2014 x. getitem (y) <==> x[y] </> __setitem__ ( name , value ) \u2014 Set self[key] to value. </> accessible_keys ( ) (iterable of str) \u2014 Get the converted keys </> clear ( ) \u2014 Clear the object </> copy ( ) (Diot) \u2014 Shallow copy the object </> copy ( ) (Diot) \u2014 Shallow copy the object </> freeze ( frozen ) \u2014 Freeze the diot object </> from_namespace ( namespace , recursive , diot_nest , diot_transform , diot_frozen ) (Diot) \u2014 Get a Diot object from an argparse namespace </> get ( name , value ) (any) \u2014 Get the value of a key name </> pop ( name , *value ) (any) \u2014 Pop a key from the object and return the value. If key does not exist, return the given default value </> popitem ( ) (str, any) \u2014 Pop last item from the object </> setdefault ( name , value ) (any) \u2014 Set a default value to a key </> thaw ( recursive ) \u2014 A context manager for temporarily change the diot </> to_dict ( ) (dict(str: any)) \u2014 Turn the Box and sub Boxes back into a native python dictionary. </> to_dict ( ) (dict(str: any)) \u2014 Turn the Box and sub Boxes back into a native python dictionary. </> to_dict ( ) (dict(str: any)) \u2014 Turn the Box and sub Boxes back into a native python dictionary. </> to_json ( filename , encoding , errors , **json_kwargs ) (str, optional) \u2014 Convert to a json string or save it to json file </> to_json ( filename , encoding , errors , **json_kwargs ) (str, optional) \u2014 Convert to a json string or save it to json file </> to_json ( filename , encoding , errors , **json_kwargs ) (str, optional) \u2014 Convert to a json string or save it to json file </> to_toml ( filename , encoding , errors ) (str, optional) \u2014 Convert to a toml string or save it to toml file </> to_toml ( filename , encoding , errors ) (str, optional) \u2014 Convert to a toml string or save it to toml file </> to_toml ( filename , encoding , errors ) (str, optional) \u2014 Convert to a toml string or save it to toml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (str, optional) \u2014 Convert to a yaml string or save it to yaml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (str, optional) \u2014 Convert to a yaml string or save it to yaml file </> to_yaml ( filename , default_flow_style , encoding , errors , **yaml_kwargs ) (str, optional) \u2014 Convert to a yaml string or save it to yaml file </> unfreeze ( recursive ) \u2014 Unfreeze the diot object </> update ( *value , **kwargs ) \u2014 Update the object. Shortcut: |= </> update_logger ( ) \u2014 Update the logger configuration according to the configuration </> classmethod","title":"liquid.config.Config"},{"location":"api/liquid.config/#diotdiotdiotfrom_namespace","text":"</> Get a Diot object from an argparse namespace Example >>> from argparse import Namespace >>> Diot . from_namespace ( Namespace ( a = 1 , b = 2 )) Parameters namespace (Namespace) \u2014 The namespace object recursive (bool, optional) \u2014 Do it recursively? diot_nest (Union(bool, iterable of type), optional) \u2014 Types to nestly convert values diot_transform (Union(callable(str: str), str), optional) \u2014 The transforms for keys diot_frozen (bool or str, optional) \u2014 Whether to generate a frozen diot. True: freeze the object recursively if there are Diot objects in descendants False: Don'f freeze 'shallow': Only freeze at depth = 1 Returns (Diot) The converted diot object. method","title":"diot.diot.Diot.from_namespace"},{"location":"api/liquid.config/#diotdiotdiotsetitem","text":"</> Set self[key] to value. method","title":"diot.diot.Diot.setitem"},{"location":"api/liquid.config/#diotdiotdiotgetitem","text":"</> x. getitem (y) <==> x[y] method","title":"diot.diot.Diot.getitem"},{"location":"api/liquid.config/#diotdiotdiotpop","text":"</> Pop a key from the object and return the value. If key does not exist, return the given default value Parameters name (str) \u2014 The key Returns (any) The value corresponding to the name or the default value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method","title":"diot.diot.Diot.pop"},{"location":"api/liquid.config/#diotdiotdiotpopitem","text":"</> Pop last item from the object Returns (str, any) A tuple of key and value Raises DiotFrozenError \u2014 when try to pop from a frozen diot method","title":"diot.diot.Diot.popitem"},{"location":"api/liquid.config/#diotdiotdiotupdate","text":"</> Update the object. Shortcut: |= Raises DiotFrozenError \u2014 when try to update a frozen diot method","title":"diot.diot.Diot.update"},{"location":"api/liquid.config/#diotdiotdiotdelitem","text":"</> Delete self[key]. method","title":"diot.diot.Diot.delitem"},{"location":"api/liquid.config/#diotdiotdiotdelitem_1","text":"</> Delete self[key]. method","title":"diot.diot.Diot.delitem"},{"location":"api/liquid.config/#diotdiotdiotfreeze","text":"</> Freeze the diot object Parameters frozen (str or bool, optional) \u2014 The frozen argument indicating how to freeze: shallow: only freeze at depth=1 True: freeze recursively if there are diot objects in children False: Disable freezing method","title":"diot.diot.Diot.freeze"},{"location":"api/liquid.config/#diotdiotdiotunfreeze","text":"</> Unfreeze the diot object Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively generator","title":"diot.diot.Diot.unfreeze"},{"location":"api/liquid.config/#diotdiotdiotthaw","text":"</> A context manager for temporarily change the diot Parameters recursive (bool, optional) \u2014 Whether unfreeze all diot objects recursively Yields self, the reference to this diot. method","title":"diot.diot.Diot.thaw"},{"location":"api/liquid.config/#diotdiotdiotsetdefault","text":"</> Set a default value to a key Parameters name (str) \u2014 The key name value (any) \u2014 The default value Returns (any) The existing value or the value passed in Raises DiotFrozenError \u2014 when try to set default to a frozen diot method","title":"diot.diot.Diot.setdefault"},{"location":"api/liquid.config/#diotdiotdiotaccessible_keys","text":"</> Get the converted keys Returns (iterable of str) The accessible (transformed) keys method","title":"diot.diot.Diot.accessible_keys"},{"location":"api/liquid.config/#diotdiotdiotget","text":"</> Get the value of a key name Parameters name (str) \u2014 The key name value (any, optional) \u2014 The value to return if the key does not exist Returns (any) The corresponding value or the value passed in if the key does not exist method","title":"diot.diot.Diot.get"},{"location":"api/liquid.config/#diotdiotdiotcontains","text":"</> True if the dictionary has the specified key, else False. method","title":"diot.diot.Diot.contains"},{"location":"api/liquid.config/#diotdiotdiotclear","text":"</> Clear the object method","title":"diot.diot.Diot.clear"},{"location":"api/liquid.config/#diotdiotdiotcopy","text":"</> Shallow copy the object Returns (Diot) The copied object method","title":"diot.diot.Diot.copy"},{"location":"api/liquid.config/#diotdiotdiotcopy_1","text":"</> Shallow copy the object Returns (Diot) The copied object method","title":"diot.diot.Diot.copy"},{"location":"api/liquid.config/#diotdiotdiotto_dict","text":"</> Turn the Box and sub Boxes back into a native python dictionary. Returns (dict(str: any)) The converted python dictionary method","title":"diot.diot.Diot.to_dict"},{"location":"api/liquid.config/#diotdiotdiotto_dict_1","text":"</> Turn the Box and sub Boxes back into a native python dictionary. Returns (dict(str: any)) The converted python dictionary method","title":"diot.diot.Diot.to_dict"},{"location":"api/liquid.config/#diotdiotdiotto_dict_2","text":"</> Turn the Box and sub Boxes back into a native python dictionary. Returns (dict(str: any)) The converted python dictionary method","title":"diot.diot.Diot.to_dict"},{"location":"api/liquid.config/#diotdiotdiotto_json","text":"</> Convert to a json string or save it to json file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the json to, if not given a json string will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (str, optional) The json string with filename is not given method","title":"diot.diot.Diot.to_json"},{"location":"api/liquid.config/#diotdiotdiotto_json_1","text":"</> Convert to a json string or save it to json file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the json to, if not given a json string will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (str, optional) The json string with filename is not given method","title":"diot.diot.Diot.to_json"},{"location":"api/liquid.config/#diotdiotdiotto_json_2","text":"</> Convert to a json string or save it to json file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the json to, if not given a json string will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function **json_kwargs \u2014 Other kwargs for json.dumps Returns (str, optional) The json string with filename is not given method","title":"diot.diot.Diot.to_json"},{"location":"api/liquid.config/#diotdiotdiotto_yaml","text":"</> Convert to a yaml string or save it to yaml file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the yaml to, if not given a yaml string will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumping See yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (str, optional) The yaml string with filename is not given method","title":"diot.diot.Diot.to_yaml"},{"location":"api/liquid.config/#diotdiotdiotto_yaml_1","text":"</> Convert to a yaml string or save it to yaml file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the yaml to, if not given a yaml string will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumping See yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (str, optional) The yaml string with filename is not given method","title":"diot.diot.Diot.to_yaml"},{"location":"api/liquid.config/#diotdiotdiotto_yaml_2","text":"</> Convert to a yaml string or save it to yaml file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the yaml to, if not given a yaml string will be returned default_flow_style (bool, optional) \u2014 The default flow style for yaml dumping See yaml.dump encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function **yaml_kwargs \u2014 Other kwargs for yaml.dump Returns (str, optional) The yaml string with filename is not given method","title":"diot.diot.Diot.to_yaml"},{"location":"api/liquid.config/#diotdiotdiotto_toml","text":"</> Convert to a toml string or save it to toml file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the toml to, if not given a toml string will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function Returns (str, optional) The toml string with filename is not given method","title":"diot.diot.Diot.to_toml"},{"location":"api/liquid.config/#diotdiotdiotto_toml_1","text":"</> Convert to a toml string or save it to toml file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the toml to, if not given a toml string will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function Returns (str, optional) The toml string with filename is not given method","title":"diot.diot.Diot.to_toml"},{"location":"api/liquid.config/#diotdiotdiotto_toml_2","text":"</> Convert to a toml string or save it to toml file Parameters filename (str, PathLike, or NoneType, optional) \u2014 The filename to save the toml to, if not given a toml string will be returned encoding (str, optional) \u2014 The encoding for saving to file errors (str, optional) \u2014 The errors handling for saveing to file See python's open function Returns (str, optional) The toml string with filename is not given method","title":"diot.diot.Diot.to_toml"},{"location":"api/liquid.config/#liquidconfigconfigupdate_logger","text":"</> Update the logger configuration according to the configuration","title":"liquid.config.Config.update_logger"},{"location":"api/liquid.exceptions/","text":"module liquid . exceptions </> Exceptions for liquidpy, all based on LiquidException Classes LiquidException \u2014 The base class for all liquidpy exceptions </> LiquidNameError \u2014 When wrong name or preserved keyword passed </> LiquidFilterRegistryException \u2014 Raises when operate the filter registry incorrectly </> LiquidTagRegistryException \u2014 Raises when operate the tag registry incorrectly </> LiquidSyntaxError \u2014 Template syntax error </> LiquidRenderError \u2014 Template render error </> class liquid.exceptions . LiquidException ( ) </> Bases Exception BaseException The base class for all liquidpy exceptions class liquid.exceptions . LiquidNameError ( ) </> Bases liquid.exceptions.LiquidException Exception BaseException When wrong name or preserved keyword passed class liquid.exceptions . LiquidFilterRegistryException ( ) </> Bases liquid.exceptions.LiquidException Exception BaseException Raises when operate the filter registry incorrectly class liquid.exceptions . LiquidTagRegistryException ( ) </> Bases liquid.exceptions.LiquidException Exception BaseException Raises when operate the tag registry incorrectly class liquid.exceptions . LiquidSyntaxError ( msg , context=None , parser=None ) </> Bases liquid.exceptions.LiquidException Exception BaseException Template syntax error Parameters msg \u2014 The message for the exception context (optional) \u2014 The context parser (optional) \u2014 The parser class liquid.exceptions . LiquidRenderError ( msg , context=None , parser=None ) </> Bases liquid.exceptions.LiquidException Exception BaseException Template render error Parameters msg \u2014 The message for the exception context (optional) \u2014 The context parser (optional) \u2014 The parser","title":"liquid.exceptions"},{"location":"api/liquid.exceptions/#liquidexceptions","text":"</> Exceptions for liquidpy, all based on LiquidException Classes LiquidException \u2014 The base class for all liquidpy exceptions </> LiquidNameError \u2014 When wrong name or preserved keyword passed </> LiquidFilterRegistryException \u2014 Raises when operate the filter registry incorrectly </> LiquidTagRegistryException \u2014 Raises when operate the tag registry incorrectly </> LiquidSyntaxError \u2014 Template syntax error </> LiquidRenderError \u2014 Template render error </> class","title":"liquid.exceptions"},{"location":"api/liquid.exceptions/#liquidexceptionsliquidexception","text":"</> Bases Exception BaseException The base class for all liquidpy exceptions class","title":"liquid.exceptions.LiquidException"},{"location":"api/liquid.exceptions/#liquidexceptionsliquidnameerror","text":"</> Bases liquid.exceptions.LiquidException Exception BaseException When wrong name or preserved keyword passed class","title":"liquid.exceptions.LiquidNameError"},{"location":"api/liquid.exceptions/#liquidexceptionsliquidfilterregistryexception","text":"</> Bases liquid.exceptions.LiquidException Exception BaseException Raises when operate the filter registry incorrectly class","title":"liquid.exceptions.LiquidFilterRegistryException"},{"location":"api/liquid.exceptions/#liquidexceptionsliquidtagregistryexception","text":"</> Bases liquid.exceptions.LiquidException Exception BaseException Raises when operate the tag registry incorrectly class","title":"liquid.exceptions.LiquidTagRegistryException"},{"location":"api/liquid.exceptions/#liquidexceptionsliquidsyntaxerror","text":"</> Bases liquid.exceptions.LiquidException Exception BaseException Template syntax error Parameters msg \u2014 The message for the exception context (optional) \u2014 The context parser (optional) \u2014 The parser class","title":"liquid.exceptions.LiquidSyntaxError"},{"location":"api/liquid.exceptions/#liquidexceptionsliquidrendererror","text":"</> Bases liquid.exceptions.LiquidException Exception BaseException Template render error Parameters msg \u2014 The message for the exception context (optional) \u2014 The context parser (optional) \u2014 The parser","title":"liquid.exceptions.LiquidRenderError"},{"location":"api/liquid.filters/","text":"module liquid . filters </> The filters used in liquidpy Attributes filter_manager \u2014 The filter manager Classes FilterManager \u2014 A manager for filters </> EmptyDrop \u2014 The EmptyDrop class borrowed from liquid </> Functions append ( base , suffix ) \u2014 Append a suffix to a string </> ceil ( base ) \u2014 Get the ceil of a number </> compact ( base ) \u2014 Remove empties from a list </> default ( base , deft ) \u2014 Return the deft value if base is not set. Otherwise, return base </> divided_by ( base , dvdby ) \u2014 Implementation of / or // </> escape_once ( base ) \u2014 Escapse html characters only once of the string </> first ( base ) \u2014 Get the first element of the list </> floor ( base ) \u2014 Get the floor of a number </> join ( base , sep ) \u2014 Join a list by the sep </> last ( base ) \u2014 Get the last element of the list </> liquid_date ( base , fmt ) \u2014 Format a date/datetime </> liquid_map ( base , prop ) \u2014 Map a property to a list of objects </> liquid_slice ( base , start , length ) \u2014 Slice a list </> minus ( base , sep ) \u2014 Implementation of - </> modulo ( base , sep ) \u2014 Implementation of % </> newline_to_br ( base ) \u2014 Replace newline with <br /> </> plus ( base , sep ) \u2014 Implementation of + </> prepend ( base , prefix ) \u2014 Prepend a prefix to a string </> remove ( base , string ) \u2014 Remove a substring from a string </> remove_first ( base , string ) \u2014 Remove the first substring from a string </> replace_first ( base , old , new ) \u2014 Replace the first substring with new string </> reverse ( base ) \u2014 Get the reversed list </> sort ( base ) \u2014 Get the sorted list </> sort_natural ( base ) \u2014 Get the sorted list in a case-insensitive manner </> split ( base , sep ) \u2014 Split a string into a list If the sep is empty, return the list of characters </> strip_html ( base ) \u2014 Strip html tags from a string </> strip_newlines ( base ) \u2014 Strip newlines from a string </> times ( base , sep ) \u2014 Implementation of * </> truncate ( base , length , ellipsis ) \u2014 Truncate a string </> truncatewords ( base , length , ellipsis ) \u2014 Truncate a string by words </> uniq ( base ) \u2014 Get the unique elements from a list </> url_decode ( base ) \u2014 Url-decode a string </> url_encode ( base ) \u2014 Url-encode a string </> where ( base , prop , value ) \u2014 Query a list of objects with a given property value </> class liquid.filters . FilterManager ( *args , **kwargs ) </> Bases liquid.utils.Singleton A manager for filters Attributes INSTANCE \u2014 The instance of the class, since it's a signleton filters \u2014 The filters database Methods register ( name_or_filter , mode ) \u2014 Register a filter </> unregister ( name , mode ) \u2014 Unregister a filter </> method register ( name_or_filter=None , mode='standard' ) </> Register a filter This can be used as a decorator >>> @filter_manager . register >>> def add ( a , b ): >>> return a + b >>> # register it with an alias: >>> @filter_manager . register ( 'addfunc' ) >>> def add ( a , b ): >>> return a + b Parameters name_or_filter (optional) \u2014 The filter to register if name is given, will be treated as alias mode (optional) \u2014 Whether do it for given mode Returns The registered function or the decorator method unregister ( name , mode='standard' ) </> Unregister a filter Parameters name \u2014 The name of the filter to unregister mode (optional) \u2014 Whether do it for given mode Returns The unregistered filter or None if name does not exist class liquid.filters . EmptyDrop ( ) </> The EmptyDrop class borrowed from liquid function liquid.filters . split ( base , sep ) </> Split a string into a list If the sep is empty, return the list of characters function liquid.filters . append ( base , suffix ) </> Append a suffix to a string function liquid.filters . prepend ( base , prefix ) </> Prepend a prefix to a string function liquid.filters . times ( base , sep ) </> Implementation of * function liquid.filters . minus ( base , sep ) </> Implementation of - function liquid.filters . plus ( base , sep ) </> Implementation of + function liquid.filters . modulo ( base , sep ) </> Implementation of % function liquid.filters . ceil ( base ) </> Get the ceil of a number function liquid.filters . floor ( base ) </> Get the floor of a number function liquid.filters . liquid_date ( base , fmt ) </> Format a date/datetime function liquid.filters . default ( base , deft ) </> Return the deft value if base is not set. Otherwise, return base function liquid.filters . divided_by ( base , dvdby ) </> Implementation of / or // function liquid.filters . escape_once ( base ) </> Escapse html characters only once of the string function liquid.filters . newline_to_br ( base ) </> Replace newline with <br /> function liquid.filters . remove ( base , string ) </> Remove a substring from a string function liquid.filters . remove_first ( base , string ) </> Remove the first substring from a string function liquid.filters . replace_first ( base , old , new ) </> Replace the first substring with new string function liquid.filters . reverse ( base ) </> Get the reversed list function liquid.filters . sort ( base ) </> Get the sorted list function liquid.filters . sort_natural ( base ) </> Get the sorted list in a case-insensitive manner function liquid.filters . liquid_slice ( base , start , length=1 ) </> Slice a list function liquid.filters . strip_html ( base ) </> Strip html tags from a string function liquid.filters . strip_newlines ( base ) </> Strip newlines from a string function liquid.filters . truncate ( base , length , ellipsis='...' ) </> Truncate a string function liquid.filters . truncatewords ( base , length , ellipsis='...' ) </> Truncate a string by words function liquid.filters . uniq ( base ) </> Get the unique elements from a list function liquid.filters . url_decode ( base ) </> Url-decode a string function liquid.filters . url_encode ( base ) </> Url-encode a string function liquid.filters . where ( base , prop , value ) </> Query a list of objects with a given property value function liquid.filters . liquid_map ( base , prop ) </> Map a property to a list of objects function liquid.filters . join ( base , sep ) </> Join a list by the sep function liquid.filters . first ( base ) </> Get the first element of the list function liquid.filters . last ( base ) </> Get the last element of the list function liquid.filters . compact ( base ) </> Remove empties from a list","title":"liquid.filters"},{"location":"api/liquid.filters/#liquidfilters","text":"</> The filters used in liquidpy Attributes filter_manager \u2014 The filter manager Classes FilterManager \u2014 A manager for filters </> EmptyDrop \u2014 The EmptyDrop class borrowed from liquid </> Functions append ( base , suffix ) \u2014 Append a suffix to a string </> ceil ( base ) \u2014 Get the ceil of a number </> compact ( base ) \u2014 Remove empties from a list </> default ( base , deft ) \u2014 Return the deft value if base is not set. Otherwise, return base </> divided_by ( base , dvdby ) \u2014 Implementation of / or // </> escape_once ( base ) \u2014 Escapse html characters only once of the string </> first ( base ) \u2014 Get the first element of the list </> floor ( base ) \u2014 Get the floor of a number </> join ( base , sep ) \u2014 Join a list by the sep </> last ( base ) \u2014 Get the last element of the list </> liquid_date ( base , fmt ) \u2014 Format a date/datetime </> liquid_map ( base , prop ) \u2014 Map a property to a list of objects </> liquid_slice ( base , start , length ) \u2014 Slice a list </> minus ( base , sep ) \u2014 Implementation of - </> modulo ( base , sep ) \u2014 Implementation of % </> newline_to_br ( base ) \u2014 Replace newline with <br /> </> plus ( base , sep ) \u2014 Implementation of + </> prepend ( base , prefix ) \u2014 Prepend a prefix to a string </> remove ( base , string ) \u2014 Remove a substring from a string </> remove_first ( base , string ) \u2014 Remove the first substring from a string </> replace_first ( base , old , new ) \u2014 Replace the first substring with new string </> reverse ( base ) \u2014 Get the reversed list </> sort ( base ) \u2014 Get the sorted list </> sort_natural ( base ) \u2014 Get the sorted list in a case-insensitive manner </> split ( base , sep ) \u2014 Split a string into a list If the sep is empty, return the list of characters </> strip_html ( base ) \u2014 Strip html tags from a string </> strip_newlines ( base ) \u2014 Strip newlines from a string </> times ( base , sep ) \u2014 Implementation of * </> truncate ( base , length , ellipsis ) \u2014 Truncate a string </> truncatewords ( base , length , ellipsis ) \u2014 Truncate a string by words </> uniq ( base ) \u2014 Get the unique elements from a list </> url_decode ( base ) \u2014 Url-decode a string </> url_encode ( base ) \u2014 Url-encode a string </> where ( base , prop , value ) \u2014 Query a list of objects with a given property value </> class","title":"liquid.filters"},{"location":"api/liquid.filters/#liquidfiltersfiltermanager","text":"</> Bases liquid.utils.Singleton A manager for filters Attributes INSTANCE \u2014 The instance of the class, since it's a signleton filters \u2014 The filters database Methods register ( name_or_filter , mode ) \u2014 Register a filter </> unregister ( name , mode ) \u2014 Unregister a filter </> method","title":"liquid.filters.FilterManager"},{"location":"api/liquid.filters/#liquidfiltersfiltermanagerregister","text":"</> Register a filter This can be used as a decorator >>> @filter_manager . register >>> def add ( a , b ): >>> return a + b >>> # register it with an alias: >>> @filter_manager . register ( 'addfunc' ) >>> def add ( a , b ): >>> return a + b Parameters name_or_filter (optional) \u2014 The filter to register if name is given, will be treated as alias mode (optional) \u2014 Whether do it for given mode Returns The registered function or the decorator method","title":"liquid.filters.FilterManager.register"},{"location":"api/liquid.filters/#liquidfiltersfiltermanagerunregister","text":"</> Unregister a filter Parameters name \u2014 The name of the filter to unregister mode (optional) \u2014 Whether do it for given mode Returns The unregistered filter or None if name does not exist class","title":"liquid.filters.FilterManager.unregister"},{"location":"api/liquid.filters/#liquidfiltersemptydrop","text":"</> The EmptyDrop class borrowed from liquid function","title":"liquid.filters.EmptyDrop"},{"location":"api/liquid.filters/#liquidfilterssplit","text":"</> Split a string into a list If the sep is empty, return the list of characters function","title":"liquid.filters.split"},{"location":"api/liquid.filters/#liquidfiltersappend","text":"</> Append a suffix to a string function","title":"liquid.filters.append"},{"location":"api/liquid.filters/#liquidfiltersprepend","text":"</> Prepend a prefix to a string function","title":"liquid.filters.prepend"},{"location":"api/liquid.filters/#liquidfilterstimes","text":"</> Implementation of * function","title":"liquid.filters.times"},{"location":"api/liquid.filters/#liquidfiltersminus","text":"</> Implementation of - function","title":"liquid.filters.minus"},{"location":"api/liquid.filters/#liquidfiltersplus","text":"</> Implementation of + function","title":"liquid.filters.plus"},{"location":"api/liquid.filters/#liquidfiltersmodulo","text":"</> Implementation of % function","title":"liquid.filters.modulo"},{"location":"api/liquid.filters/#liquidfiltersceil","text":"</> Get the ceil of a number function","title":"liquid.filters.ceil"},{"location":"api/liquid.filters/#liquidfiltersfloor","text":"</> Get the floor of a number function","title":"liquid.filters.floor"},{"location":"api/liquid.filters/#liquidfiltersliquid_date","text":"</> Format a date/datetime function","title":"liquid.filters.liquid_date"},{"location":"api/liquid.filters/#liquidfiltersdefault","text":"</> Return the deft value if base is not set. Otherwise, return base function","title":"liquid.filters.default"},{"location":"api/liquid.filters/#liquidfiltersdivided_by","text":"</> Implementation of / or // function","title":"liquid.filters.divided_by"},{"location":"api/liquid.filters/#liquidfiltersescape_once","text":"</> Escapse html characters only once of the string function","title":"liquid.filters.escape_once"},{"location":"api/liquid.filters/#liquidfiltersnewline_to_br","text":"</> Replace newline with <br /> function","title":"liquid.filters.newline_to_br"},{"location":"api/liquid.filters/#liquidfiltersremove","text":"</> Remove a substring from a string function","title":"liquid.filters.remove"},{"location":"api/liquid.filters/#liquidfiltersremove_first","text":"</> Remove the first substring from a string function","title":"liquid.filters.remove_first"},{"location":"api/liquid.filters/#liquidfiltersreplace_first","text":"</> Replace the first substring with new string function","title":"liquid.filters.replace_first"},{"location":"api/liquid.filters/#liquidfiltersreverse","text":"</> Get the reversed list function","title":"liquid.filters.reverse"},{"location":"api/liquid.filters/#liquidfilterssort","text":"</> Get the sorted list function","title":"liquid.filters.sort"},{"location":"api/liquid.filters/#liquidfilterssort_natural","text":"</> Get the sorted list in a case-insensitive manner function","title":"liquid.filters.sort_natural"},{"location":"api/liquid.filters/#liquidfiltersliquid_slice","text":"</> Slice a list function","title":"liquid.filters.liquid_slice"},{"location":"api/liquid.filters/#liquidfiltersstrip_html","text":"</> Strip html tags from a string function","title":"liquid.filters.strip_html"},{"location":"api/liquid.filters/#liquidfiltersstrip_newlines","text":"</> Strip newlines from a string function","title":"liquid.filters.strip_newlines"},{"location":"api/liquid.filters/#liquidfilterstruncate","text":"</> Truncate a string function","title":"liquid.filters.truncate"},{"location":"api/liquid.filters/#liquidfilterstruncatewords","text":"</> Truncate a string by words function","title":"liquid.filters.truncatewords"},{"location":"api/liquid.filters/#liquidfiltersuniq","text":"</> Get the unique elements from a list function","title":"liquid.filters.uniq"},{"location":"api/liquid.filters/#liquidfiltersurl_decode","text":"</> Url-decode a string function","title":"liquid.filters.url_decode"},{"location":"api/liquid.filters/#liquidfiltersurl_encode","text":"</> Url-encode a string function","title":"liquid.filters.url_encode"},{"location":"api/liquid.filters/#liquidfilterswhere","text":"</> Query a list of objects with a given property value function","title":"liquid.filters.where"},{"location":"api/liquid.filters/#liquidfiltersliquid_map","text":"</> Map a property to a list of objects function","title":"liquid.filters.liquid_map"},{"location":"api/liquid.filters/#liquidfiltersjoin","text":"</> Join a list by the sep function","title":"liquid.filters.join"},{"location":"api/liquid.filters/#liquidfiltersfirst","text":"</> Get the first element of the list function","title":"liquid.filters.first"},{"location":"api/liquid.filters/#liquidfilterslast","text":"</> Get the last element of the list function","title":"liquid.filters.last"},{"location":"api/liquid.filters/#liquidfilterscompact","text":"</> Remove empties from a list","title":"liquid.filters.compact"},{"location":"api/liquid.liquid/","text":"module liquid . liquid </> Provides Liquid, LiquidPython and LiquidJekyll classes Classes Liquid \u2014 The main class for external use </> LiquidPython \u2014 Support for extended mode of liquidpy </> class liquid.liquid . Liquid ( liquid_template , liquid_config=None , **envs ) </> The main class for external use One could provide a config says liquid_config['extended'] = True to switch this object to be initialized as a LiquidPython object. Examples >>> liq1 = Liquid ( \"{{a}}\" ) >>> liq1 . __class__ # -> Liquid >>> liq2 = Liquid ( \"{{a}}\" , { 'mode' : 'python' }) >>> liq2 . __class__ # -> LiquidPython >>> isinstance ( liq2 , Liquid ) # -> True Attributes FILTER_MANAGER \u2014 The filter manager PARSER_CLASS \u2014 The root parser class Parameters liquid_template \u2014 The template that can be rendered. It could be a string template, a path to a file contains the template or an IO object with the template liquid_config (optional) \u2014 The configuration for this liquid object - extended: Whether use the extended mode - **envs \u2014 Other environment variables for template rendering. Methods __new__ ( cls , liquid_template , liquid_config , **envs ) \u2014 Works as a router to determine returning a Liquid or LiquidPython object according to liquid_config['extended'] </> render ( **context ) \u2014 Render the template with given context The parsed is a TagRoot object, whose render gives a string </> staticmethod __new__ ( cls , liquid_template , liquid_config=None , **envs ) </> Works as a router to determine returning a Liquid or LiquidPython object according to liquid_config['extended'] method render ( **context ) </> Render the template with given context The parsed is a TagRoot object, whose render gives a string Parameters context \u2014 The context used to render the template Returns The rendered content class liquid.liquid . LiquidPython ( *args , **kwargs ) </> Bases liquid.liquid.Liquid Support for extended mode of liquidpy Attributes FILTER_MANAGER \u2014 The filter manager PARSER_CLASS \u2014 The root parser class Methods __new__ ( cls , *args , **kwargs ) \u2014 Works as a router to determine returning a Liquid or LiquidPython object according to liquid_config['extended'] </> render ( **context ) \u2014 Render the template with given context The parsed is a TagRoot object, whose render gives a string </> staticmethod __new__ ( cls , *args , **kwargs ) </> Works as a router to determine returning a Liquid or LiquidPython object according to liquid_config['extended'] method render ( **context ) </> Render the template with given context The parsed is a TagRoot object, whose render gives a string Returns The rendered content","title":"liquid.liquid"},{"location":"api/liquid.liquid/#liquidliquid","text":"</> Provides Liquid, LiquidPython and LiquidJekyll classes Classes Liquid \u2014 The main class for external use </> LiquidPython \u2014 Support for extended mode of liquidpy </> class","title":"liquid.liquid"},{"location":"api/liquid.liquid/#liquidliquidliquid","text":"</> The main class for external use One could provide a config says liquid_config['extended'] = True to switch this object to be initialized as a LiquidPython object. Examples >>> liq1 = Liquid ( \"{{a}}\" ) >>> liq1 . __class__ # -> Liquid >>> liq2 = Liquid ( \"{{a}}\" , { 'mode' : 'python' }) >>> liq2 . __class__ # -> LiquidPython >>> isinstance ( liq2 , Liquid ) # -> True Attributes FILTER_MANAGER \u2014 The filter manager PARSER_CLASS \u2014 The root parser class Parameters liquid_template \u2014 The template that can be rendered. It could be a string template, a path to a file contains the template or an IO object with the template liquid_config (optional) \u2014 The configuration for this liquid object - extended: Whether use the extended mode - **envs \u2014 Other environment variables for template rendering. Methods __new__ ( cls , liquid_template , liquid_config , **envs ) \u2014 Works as a router to determine returning a Liquid or LiquidPython object according to liquid_config['extended'] </> render ( **context ) \u2014 Render the template with given context The parsed is a TagRoot object, whose render gives a string </> staticmethod","title":"liquid.liquid.Liquid"},{"location":"api/liquid.liquid/#liquidliquidliquidnew","text":"</> Works as a router to determine returning a Liquid or LiquidPython object according to liquid_config['extended'] method","title":"liquid.liquid.Liquid.new"},{"location":"api/liquid.liquid/#liquidliquidliquidrender","text":"</> Render the template with given context The parsed is a TagRoot object, whose render gives a string Parameters context \u2014 The context used to render the template Returns The rendered content class","title":"liquid.liquid.Liquid.render"},{"location":"api/liquid.liquid/#liquidliquidliquidpython","text":"</> Bases liquid.liquid.Liquid Support for extended mode of liquidpy Attributes FILTER_MANAGER \u2014 The filter manager PARSER_CLASS \u2014 The root parser class Methods __new__ ( cls , *args , **kwargs ) \u2014 Works as a router to determine returning a Liquid or LiquidPython object according to liquid_config['extended'] </> render ( **context ) \u2014 Render the template with given context The parsed is a TagRoot object, whose render gives a string </> staticmethod","title":"liquid.liquid.LiquidPython"},{"location":"api/liquid.liquid/#liquidliquidliquidpythonnew","text":"</> Works as a router to determine returning a Liquid or LiquidPython object according to liquid_config['extended'] method","title":"liquid.liquid.LiquidPython.new"},{"location":"api/liquid.liquid/#liquidliquidliquidpythonrender","text":"</> Render the template with given context The parsed is a TagRoot object, whose render gives a string Returns The rendered content","title":"liquid.liquid.LiquidPython.render"},{"location":"api/liquid/","text":"package liquid </> A port of liquid template engine in python module liquid . parser </> The parser for liquidpy Classes Visitor \u2014 Vistor to visit parsed node </> Parser \u2014 The root parser for liquidpy </> module liquid . utils </> Utilities for liquidpy Classes TemplateMeta \u2014 TemplateMeta(name, path, stream, should_close) </> Nothing \u2014 A unique object to identify a NOTHING other than None </> OptionalTags \u2014 Indicates the arguments are optional </> RequiredTags \u2014 Indicates the arguments are required </> Singleton \u2014 An abstract base class for signleton classes </> Functions analyze_leading_spaces ( string ) \u2014 Analyze the leading spaces of a string </> check_name ( names ) \u2014 Check whether the name is allowed </> excmsg_with_context ( msg , context , parser ) \u2014 Assemble the exception message with context </> find_dir ( path , curr_path ) \u2014 Find the directory by given path </> find_template ( path , curr_path , config_paths ) \u2014 Find the template by given path </> get_tag_parser ( start , grammar , transformer , base_grammar ) \u2014 Get the lark parser for tags </> shorten ( text , width , placeholder ) \u2014 Wrap textwrap.shorten </> template_meta ( template ) \u2014 Get the metadata of a template </> module liquid . nodes </> Definition of nodes and node scanner Classes Node \u2014 A node of liquidpy </> NodeLiteral \u2014 The literal node </> NodeOutput \u2014 The output node </> NodeTag \u2014 The opening of a tag node </> NodeScanner \u2014 Scanning for the nodes </> module liquid . liquid </> Provides Liquid, LiquidPython and LiquidJekyll classes Classes Liquid \u2014 The main class for external use </> LiquidPython \u2014 Support for extended mode of liquidpy </> package liquid . tags </> All stuff about liquidpy tags module liquid . config </> The configuration for liquidpy Attributes DEFAULT_CONFIG \u2014 The default configuration LIQUID_EXC_CODE_CONTEXT \u2014 The number of context lines to show codes in exceptions when debug is on LIQUID_EXC_MAX_STACKS \u2014 The stacks to show in exceptions when debug is on LIQUID_FILTERS_ENVNAME \u2014 The variable containing all filters LIQUID_LOGGER_NAME \u2014 The name of the logger LIQUID_LOG_INDENT \u2014 Indentions to show the tree structure in logging Classes Config \u2014 The configurations for liquidpy </> module liquid . filters </> The filters used in liquidpy Attributes filter_manager \u2014 The filter manager Classes FilterManager \u2014 A manager for filters </> EmptyDrop \u2014 The EmptyDrop class borrowed from liquid </> Functions append ( base , suffix ) \u2014 Append a suffix to a string </> ceil ( base ) \u2014 Get the ceil of a number </> compact ( base ) \u2014 Remove empties from a list </> default ( base , deft ) \u2014 Return the deft value if base is not set. Otherwise, return base </> divided_by ( base , dvdby ) \u2014 Implementation of / or // </> escape_once ( base ) \u2014 Escapse html characters only once of the string </> first ( base ) \u2014 Get the first element of the list </> floor ( base ) \u2014 Get the floor of a number </> join ( base , sep ) \u2014 Join a list by the sep </> last ( base ) \u2014 Get the last element of the list </> liquid_date ( base , fmt ) \u2014 Format a date/datetime </> liquid_map ( base , prop ) \u2014 Map a property to a list of objects </> liquid_slice ( base , start , length ) \u2014 Slice a list </> minus ( base , sep ) \u2014 Implementation of - </> modulo ( base , sep ) \u2014 Implementation of % </> newline_to_br ( base ) \u2014 Replace newline with <br /> </> plus ( base , sep ) \u2014 Implementation of + </> prepend ( base , prefix ) \u2014 Prepend a prefix to a string </> remove ( base , string ) \u2014 Remove a substring from a string </> remove_first ( base , string ) \u2014 Remove the first substring from a string </> replace_first ( base , old , new ) \u2014 Replace the first substring with new string </> reverse ( base ) \u2014 Get the reversed list </> sort ( base ) \u2014 Get the sorted list </> sort_natural ( base ) \u2014 Get the sorted list in a case-insensitive manner </> split ( base , sep ) \u2014 Split a string into a list If the sep is empty, return the list of characters </> strip_html ( base ) \u2014 Strip html tags from a string </> strip_newlines ( base ) \u2014 Strip newlines from a string </> times ( base , sep ) \u2014 Implementation of * </> truncate ( base , length , ellipsis ) \u2014 Truncate a string </> truncatewords ( base , length , ellipsis ) \u2014 Truncate a string by words </> uniq ( base ) \u2014 Get the unique elements from a list </> url_decode ( base ) \u2014 Url-decode a string </> url_encode ( base ) \u2014 Url-encode a string </> where ( base , prop , value ) \u2014 Query a list of objects with a given property value </> module liquid . exceptions </> Exceptions for liquidpy, all based on LiquidException Classes LiquidException \u2014 The base class for all liquidpy exceptions </> LiquidNameError \u2014 When wrong name or preserved keyword passed </> LiquidFilterRegistryException \u2014 Raises when operate the filter registry incorrectly </> LiquidTagRegistryException \u2014 Raises when operate the tag registry incorrectly </> LiquidSyntaxError \u2014 Template syntax error </> LiquidRenderError \u2014 Template render error </>","title":"liquid"},{"location":"api/liquid/#liquid","text":"</> A port of liquid template engine in python module","title":"liquid"},{"location":"api/liquid/#liquidparser","text":"</> The parser for liquidpy Classes Visitor \u2014 Vistor to visit parsed node </> Parser \u2014 The root parser for liquidpy </> module","title":"liquid.parser"},{"location":"api/liquid/#liquidutils","text":"</> Utilities for liquidpy Classes TemplateMeta \u2014 TemplateMeta(name, path, stream, should_close) </> Nothing \u2014 A unique object to identify a NOTHING other than None </> OptionalTags \u2014 Indicates the arguments are optional </> RequiredTags \u2014 Indicates the arguments are required </> Singleton \u2014 An abstract base class for signleton classes </> Functions analyze_leading_spaces ( string ) \u2014 Analyze the leading spaces of a string </> check_name ( names ) \u2014 Check whether the name is allowed </> excmsg_with_context ( msg , context , parser ) \u2014 Assemble the exception message with context </> find_dir ( path , curr_path ) \u2014 Find the directory by given path </> find_template ( path , curr_path , config_paths ) \u2014 Find the template by given path </> get_tag_parser ( start , grammar , transformer , base_grammar ) \u2014 Get the lark parser for tags </> shorten ( text , width , placeholder ) \u2014 Wrap textwrap.shorten </> template_meta ( template ) \u2014 Get the metadata of a template </> module","title":"liquid.utils"},{"location":"api/liquid/#liquidnodes","text":"</> Definition of nodes and node scanner Classes Node \u2014 A node of liquidpy </> NodeLiteral \u2014 The literal node </> NodeOutput \u2014 The output node </> NodeTag \u2014 The opening of a tag node </> NodeScanner \u2014 Scanning for the nodes </> module","title":"liquid.nodes"},{"location":"api/liquid/#liquidliquid","text":"</> Provides Liquid, LiquidPython and LiquidJekyll classes Classes Liquid \u2014 The main class for external use </> LiquidPython \u2014 Support for extended mode of liquidpy </> package","title":"liquid.liquid"},{"location":"api/liquid/#liquidtags","text":"</> All stuff about liquidpy tags module","title":"liquid.tags"},{"location":"api/liquid/#liquidconfig","text":"</> The configuration for liquidpy Attributes DEFAULT_CONFIG \u2014 The default configuration LIQUID_EXC_CODE_CONTEXT \u2014 The number of context lines to show codes in exceptions when debug is on LIQUID_EXC_MAX_STACKS \u2014 The stacks to show in exceptions when debug is on LIQUID_FILTERS_ENVNAME \u2014 The variable containing all filters LIQUID_LOGGER_NAME \u2014 The name of the logger LIQUID_LOG_INDENT \u2014 Indentions to show the tree structure in logging Classes Config \u2014 The configurations for liquidpy </> module","title":"liquid.config"},{"location":"api/liquid/#liquidfilters","text":"</> The filters used in liquidpy Attributes filter_manager \u2014 The filter manager Classes FilterManager \u2014 A manager for filters </> EmptyDrop \u2014 The EmptyDrop class borrowed from liquid </> Functions append ( base , suffix ) \u2014 Append a suffix to a string </> ceil ( base ) \u2014 Get the ceil of a number </> compact ( base ) \u2014 Remove empties from a list </> default ( base , deft ) \u2014 Return the deft value if base is not set. Otherwise, return base </> divided_by ( base , dvdby ) \u2014 Implementation of / or // </> escape_once ( base ) \u2014 Escapse html characters only once of the string </> first ( base ) \u2014 Get the first element of the list </> floor ( base ) \u2014 Get the floor of a number </> join ( base , sep ) \u2014 Join a list by the sep </> last ( base ) \u2014 Get the last element of the list </> liquid_date ( base , fmt ) \u2014 Format a date/datetime </> liquid_map ( base , prop ) \u2014 Map a property to a list of objects </> liquid_slice ( base , start , length ) \u2014 Slice a list </> minus ( base , sep ) \u2014 Implementation of - </> modulo ( base , sep ) \u2014 Implementation of % </> newline_to_br ( base ) \u2014 Replace newline with <br /> </> plus ( base , sep ) \u2014 Implementation of + </> prepend ( base , prefix ) \u2014 Prepend a prefix to a string </> remove ( base , string ) \u2014 Remove a substring from a string </> remove_first ( base , string ) \u2014 Remove the first substring from a string </> replace_first ( base , old , new ) \u2014 Replace the first substring with new string </> reverse ( base ) \u2014 Get the reversed list </> sort ( base ) \u2014 Get the sorted list </> sort_natural ( base ) \u2014 Get the sorted list in a case-insensitive manner </> split ( base , sep ) \u2014 Split a string into a list If the sep is empty, return the list of characters </> strip_html ( base ) \u2014 Strip html tags from a string </> strip_newlines ( base ) \u2014 Strip newlines from a string </> times ( base , sep ) \u2014 Implementation of * </> truncate ( base , length , ellipsis ) \u2014 Truncate a string </> truncatewords ( base , length , ellipsis ) \u2014 Truncate a string by words </> uniq ( base ) \u2014 Get the unique elements from a list </> url_decode ( base ) \u2014 Url-decode a string </> url_encode ( base ) \u2014 Url-encode a string </> where ( base , prop , value ) \u2014 Query a list of objects with a given property value </> module","title":"liquid.filters"},{"location":"api/liquid/#liquidexceptions","text":"</> Exceptions for liquidpy, all based on LiquidException Classes LiquidException \u2014 The base class for all liquidpy exceptions </> LiquidNameError \u2014 When wrong name or preserved keyword passed </> LiquidFilterRegistryException \u2014 Raises when operate the filter registry incorrectly </> LiquidTagRegistryException \u2014 Raises when operate the tag registry incorrectly </> LiquidSyntaxError \u2014 Template syntax error </> LiquidRenderError \u2014 Template render error </>","title":"liquid.exceptions"},{"location":"api/liquid.nodes/","text":"module liquid . nodes </> Definition of nodes and node scanner Classes Node \u2014 A node of liquidpy </> NodeLiteral \u2014 The literal node </> NodeOutput \u2014 The output node </> NodeTag \u2014 The opening of a tag node </> NodeScanner \u2014 Scanning for the nodes </> class liquid.nodes . Node ( content , context , parser , open_tag='' , close_tag='' ) </> A node of liquidpy Serves as a bridge between parser and tags for scanning Should be one of: - literal node: ... - output node: {{ ... }} - comment node: {# ... #} - tag node: {% ... %} Attributes CLOSE_TAG \u2014 The close tags for the node OPEN_TAG \u2014 The open tags for the node TAG_MANAGER \u2014 The tag manager close_compact \u2014 Whether close tag is compact content \u2014 The content of the node context \u2014 The context of the node name \u2014 The name of the node open_compact \u2014 Whether open tag is compact raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Parameters content \u2014 The content of the node context \u2014 The context of the node parser \u2014 The parser open_tag (optional) \u2014 The open tag of the node close_tag (optional) \u2014 The close tag of the node Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod __init_subclass__ ( tag_manager=<liquid.tags.manager.TagManager object at 0x7f0fc31dfa00> ) </> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. class liquid.nodes . NodeLiteral ( content , context , parser , open_tag='' , close_tag='' ) </> Bases liquid.nodes.Node The literal node Parameters content \u2014 The content of the node context \u2014 The context of the node parser \u2014 The parser open_tag (optional) \u2014 The open tag of the node close_tag (optional) \u2014 The close tag of the node Attributes CLOSE_TAG \u2014 The close tags for the node OPEN_TAG \u2014 The open tags for the node TAG_MANAGER \u2014 The tag manager close_compact \u2014 Whether close tag is compact content \u2014 The content of the node context \u2014 The context of the node name \u2014 The name of the node open_compact \u2014 Whether open tag is compact raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod __init_subclass__ ( tag_manager=<liquid.tags.manager.TagManager object at 0x7f0fc31dfa00> ) </> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. class liquid.nodes . NodeOutput ( content , context , parser , open_tag='' , close_tag='' ) </> Bases liquid.nodes.Node The output node Parameters content \u2014 The content of the node context \u2014 The context of the node parser \u2014 The parser open_tag (optional) \u2014 The open tag of the node close_tag (optional) \u2014 The close tag of the node Attributes CLOSE_TAG \u2014 The close tags for the node OPEN_TAG \u2014 The open tags for the node TAG_MANAGER \u2014 The tag manager close_compact \u2014 Whether close tag is compact content \u2014 The content of the node context \u2014 The context of the node name \u2014 The name of the node open_compact \u2014 Whether open tag is compact raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod __init_subclass__ ( tag_manager=<liquid.tags.manager.TagManager object at 0x7f0fc31dfa00> ) </> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. class liquid.nodes . NodeTag ( *args , **kwargs ) </> Bases liquid.nodes.Node The opening of a tag node Attributes CLOSE_TAG \u2014 The close tags for the node OPEN_TAG \u2014 The open tags for the node TAG_MANAGER \u2014 The tag manager close_compact \u2014 Whether close tag is compact content \u2014 The content of the node context \u2014 The context of the node name \u2014 The name of the node open_compact \u2014 Whether open tag is compact raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod __init_subclass__ ( tag_manager=<liquid.tags.manager.TagManager object at 0x7f0fc31dfa00> ) </> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. class liquid.nodes . NodeScanner ( context , parser ) </> Scanning for the nodes Attributes LITERAL \u2014 The literal node NODES \u2014 The possible nodes OPEN_CHARS \u2014 The start characters of open tags for those nodes This is to speed up the lookup for a potential hit of a node closetag_buffer \u2014 The buffer for close tags content_buffer \u2014 The buffer for content of potential nodes context \u2014 The context of the potential node escape \u2014 Whether the previous character is an escape ( \\ ) hit \u2014 The node we hit This will be only fit when there is only one type of node hit literal_buffer \u2014 The buffer for literal nodes This will not consume the potential node open_context \u2014 Where the open tag hits opentag_buffer \u2014 The buffer for open tags parser \u2014 The parser rawtag \u2014 The matched raw tag name Classes NodeLiteral \u2014 The literal node </> Methods consume ( stream ) (True) \u2014 Consume the character of a stream </> class liquid.nodes . NodeLiteral ( content , context , parser , open_tag='' , close_tag='' ) </> Bases liquid.nodes.Node The literal node Attributes raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod __init_subclass__ ( tag_manager=<liquid.tags.manager.TagManager object at 0x7f0fc31dfa00> ) </> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method consume ( stream ) </> Consume the character of a stream if it is empty, then we hit the end of the stream. Otherwise, we need to update the context, and add the character to the buffer. Parameters stream \u2014 The stream to consume Returns (True) we should continue consuming False: we should stop consuming (we hit the end of the stream) Node: A complete node hit","title":"liquid.nodes"},{"location":"api/liquid.nodes/#liquidnodes","text":"</> Definition of nodes and node scanner Classes Node \u2014 A node of liquidpy </> NodeLiteral \u2014 The literal node </> NodeOutput \u2014 The output node </> NodeTag \u2014 The opening of a tag node </> NodeScanner \u2014 Scanning for the nodes </> class","title":"liquid.nodes"},{"location":"api/liquid.nodes/#liquidnodesnode","text":"</> A node of liquidpy Serves as a bridge between parser and tags for scanning Should be one of: - literal node: ... - output node: {{ ... }} - comment node: {# ... #} - tag node: {% ... %} Attributes CLOSE_TAG \u2014 The close tags for the node OPEN_TAG \u2014 The open tags for the node TAG_MANAGER \u2014 The tag manager close_compact \u2014 Whether close tag is compact content \u2014 The content of the node context \u2014 The context of the node name \u2014 The name of the node open_compact \u2014 Whether open tag is compact raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Parameters content \u2014 The content of the node context \u2014 The context of the node parser \u2014 The parser open_tag (optional) \u2014 The open tag of the node close_tag (optional) \u2014 The close tag of the node Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod","title":"liquid.nodes.Node"},{"location":"api/liquid.nodes/#liquidnodesnodeinit_subclass","text":"</> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. class","title":"liquid.nodes.Node.init_subclass"},{"location":"api/liquid.nodes/#liquidnodesnodeliteral","text":"</> Bases liquid.nodes.Node The literal node Parameters content \u2014 The content of the node context \u2014 The context of the node parser \u2014 The parser open_tag (optional) \u2014 The open tag of the node close_tag (optional) \u2014 The close tag of the node Attributes CLOSE_TAG \u2014 The close tags for the node OPEN_TAG \u2014 The open tags for the node TAG_MANAGER \u2014 The tag manager close_compact \u2014 Whether close tag is compact content \u2014 The content of the node context \u2014 The context of the node name \u2014 The name of the node open_compact \u2014 Whether open tag is compact raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod","title":"liquid.nodes.NodeLiteral"},{"location":"api/liquid.nodes/#liquidnodesnodeinit_subclass_1","text":"</> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. class","title":"liquid.nodes.Node.init_subclass"},{"location":"api/liquid.nodes/#liquidnodesnodeoutput","text":"</> Bases liquid.nodes.Node The output node Parameters content \u2014 The content of the node context \u2014 The context of the node parser \u2014 The parser open_tag (optional) \u2014 The open tag of the node close_tag (optional) \u2014 The close tag of the node Attributes CLOSE_TAG \u2014 The close tags for the node OPEN_TAG \u2014 The open tags for the node TAG_MANAGER \u2014 The tag manager close_compact \u2014 Whether close tag is compact content \u2014 The content of the node context \u2014 The context of the node name \u2014 The name of the node open_compact \u2014 Whether open tag is compact raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod","title":"liquid.nodes.NodeOutput"},{"location":"api/liquid.nodes/#liquidnodesnodeinit_subclass_2","text":"</> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. class","title":"liquid.nodes.Node.init_subclass"},{"location":"api/liquid.nodes/#liquidnodesnodetag","text":"</> Bases liquid.nodes.Node The opening of a tag node Attributes CLOSE_TAG \u2014 The close tags for the node OPEN_TAG \u2014 The open tags for the node TAG_MANAGER \u2014 The tag manager close_compact \u2014 Whether close tag is compact content \u2014 The content of the node context \u2014 The context of the node name \u2014 The name of the node open_compact \u2014 Whether open tag is compact raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod","title":"liquid.nodes.NodeTag"},{"location":"api/liquid.nodes/#liquidnodesnodeinit_subclass_3","text":"</> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. class","title":"liquid.nodes.Node.init_subclass"},{"location":"api/liquid.nodes/#liquidnodesnodescanner","text":"</> Scanning for the nodes Attributes LITERAL \u2014 The literal node NODES \u2014 The possible nodes OPEN_CHARS \u2014 The start characters of open tags for those nodes This is to speed up the lookup for a potential hit of a node closetag_buffer \u2014 The buffer for close tags content_buffer \u2014 The buffer for content of potential nodes context \u2014 The context of the potential node escape \u2014 Whether the previous character is an escape ( \\ ) hit \u2014 The node we hit This will be only fit when there is only one type of node hit literal_buffer \u2014 The buffer for literal nodes This will not consume the potential node open_context \u2014 Where the open tag hits opentag_buffer \u2014 The buffer for open tags parser \u2014 The parser rawtag \u2014 The matched raw tag name Classes NodeLiteral \u2014 The literal node </> Methods consume ( stream ) (True) \u2014 Consume the character of a stream </> class","title":"liquid.nodes.NodeScanner"},{"location":"api/liquid.nodes/#liquidnodesnodeliteral_1","text":"</> Bases liquid.nodes.Node The literal node Attributes raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod __init_subclass__ ( tag_manager=<liquid.tags.manager.TagManager object at 0x7f0fc31dfa00> ) </> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method","title":"liquid.nodes.NodeLiteral"},{"location":"api/liquid.nodes/#liquidnodesnodescannerconsume","text":"</> Consume the character of a stream if it is empty, then we hit the end of the stream. Otherwise, we need to update the context, and add the character to the buffer. Parameters stream \u2014 The stream to consume Returns (True) we should continue consuming False: we should stop consuming (we hit the end of the stream) Node: A complete node hit","title":"liquid.nodes.NodeScanner.consume"},{"location":"api/liquid.parser/","text":"module liquid . parser </> The parser for liquidpy Classes Visitor \u2014 Vistor to visit parsed node </> Parser \u2014 The root parser for liquidpy </> class liquid.parser . Visitor ( root ) </> Vistor to visit parsed node Attributes blocks \u2014 The block tags, used to replace the mother's ones has_mother \u2014 Indicates whether this template is extended from a mother template root \u2014 The root tag stack \u2014 The tag stack, used to resolve the structure Parameters root \u2014 The root tag Methods visit ( tag ) \u2014 Visit the tag </> method visit ( tag ) </> Visit the tag Parameters tag \u2014 The tag class liquid.parser . Parser ( meta , config , context=None , level=0 ) </> The root parser for liquidpy This parses the stream into tags, and each tag will be handled by different parser using lark Attibutes: NODESCANNER_CLASS: The node scanner class VISITOR_CLASS: The visitor class config: The configuration context: The context parent: The parent parser nodescanner: The node scanner visitor: The visitor for tags Parameters meta \u2014 The template meta data config \u2014 The configuration context (optional) \u2014 The context level (optional) \u2014 The level of the parser Classes Visitor \u2014 Vistor to visit parsed node </> Methods parse ( ) \u2014 Parser the template for later rendering. </> class liquid.parser . Visitor ( root ) </> Vistor to visit parsed node Attributes blocks \u2014 The block tags, used to replace the mother's ones has_mother \u2014 Indicates whether this template is extended from a mother template root \u2014 The root tag stack \u2014 The tag stack, used to resolve the structure Parameters root \u2014 The root tag Methods visit ( tag ) \u2014 Visit the tag </> method visit ( tag ) </> Visit the tag Parameters tag \u2014 The tag method parse ( ) </> Parser the template for later rendering. Returns The root tag for later rendering","title":"liquid.parser"},{"location":"api/liquid.parser/#liquidparser","text":"</> The parser for liquidpy Classes Visitor \u2014 Vistor to visit parsed node </> Parser \u2014 The root parser for liquidpy </> class","title":"liquid.parser"},{"location":"api/liquid.parser/#liquidparservisitor","text":"</> Vistor to visit parsed node Attributes blocks \u2014 The block tags, used to replace the mother's ones has_mother \u2014 Indicates whether this template is extended from a mother template root \u2014 The root tag stack \u2014 The tag stack, used to resolve the structure Parameters root \u2014 The root tag Methods visit ( tag ) \u2014 Visit the tag </> method","title":"liquid.parser.Visitor"},{"location":"api/liquid.parser/#liquidparservisitorvisit","text":"</> Visit the tag Parameters tag \u2014 The tag class","title":"liquid.parser.Visitor.visit"},{"location":"api/liquid.parser/#liquidparserparser","text":"</> The root parser for liquidpy This parses the stream into tags, and each tag will be handled by different parser using lark Attibutes: NODESCANNER_CLASS: The node scanner class VISITOR_CLASS: The visitor class config: The configuration context: The context parent: The parent parser nodescanner: The node scanner visitor: The visitor for tags Parameters meta \u2014 The template meta data config \u2014 The configuration context (optional) \u2014 The context level (optional) \u2014 The level of the parser Classes Visitor \u2014 Vistor to visit parsed node </> Methods parse ( ) \u2014 Parser the template for later rendering. </> class","title":"liquid.parser.Parser"},{"location":"api/liquid.parser/#liquidparservisitor_1","text":"</> Vistor to visit parsed node Attributes blocks \u2014 The block tags, used to replace the mother's ones has_mother \u2014 Indicates whether this template is extended from a mother template root \u2014 The root tag stack \u2014 The tag stack, used to resolve the structure Parameters root \u2014 The root tag Methods visit ( tag ) \u2014 Visit the tag </> method visit ( tag ) </> Visit the tag Parameters tag \u2014 The tag method","title":"liquid.parser.Visitor"},{"location":"api/liquid.parser/#liquidparserparserparse","text":"</> Parser the template for later rendering. Returns The root tag for later rendering","title":"liquid.parser.Parser.parse"},{"location":"api/liquid.python.filters/","text":"module liquid.python . filters </> Management for filters in extended mode Classes FilterManager \u2014 A manager for filters in extended mode </> Functions getitem ( base , index ) \u2014 Get an item from the base value </> render ( base , **envs ) \u2014 Render a template in python mode </> class liquid.python.filters . FilterManager ( *args , **kwargs ) </> Bases liquid.filters.FilterManager liquid.utils.Singleton A manager for filters in extended mode Attributes INSTANCE \u2014 The instance of the class, since it's a signleton filters \u2014 The filters database Methods register ( name_or_filter , mode ) \u2014 Register a filter </> unregister ( name , mode ) \u2014 Unregister a filter </> method register ( name_or_filter=None , mode='standard' ) </> Register a filter This can be used as a decorator >>> @filter_manager . register >>> def add ( a , b ): >>> return a + b >>> # register it with an alias: >>> @filter_manager . register ( 'addfunc' ) >>> def add ( a , b ): >>> return a + b Parameters name_or_filter (optional) \u2014 The filter to register if name is given, will be treated as alias mode (optional) \u2014 Whether do it for given mode Returns The registered function or the decorator method unregister ( name , mode='standard' ) </> Unregister a filter Parameters name \u2014 The name of the filter to unregister mode (optional) \u2014 Whether do it for given mode Returns The unregistered filter or None if name does not exist function liquid.python.filters . getitem ( base , index ) </> Get an item from the base value function liquid.python.filters . render ( base , **envs ) </> Render a template in python mode","title":"liquid.python.filters"},{"location":"api/liquid.python.filters/#liquidpythonfilters","text":"</> Management for filters in extended mode Classes FilterManager \u2014 A manager for filters in extended mode </> Functions getitem ( base , index ) \u2014 Get an item from the base value </> render ( base , **envs ) \u2014 Render a template in python mode </> class","title":"liquid.python.filters"},{"location":"api/liquid.python.filters/#liquidpythonfiltersfiltermanager","text":"</> Bases liquid.filters.FilterManager liquid.utils.Singleton A manager for filters in extended mode Attributes INSTANCE \u2014 The instance of the class, since it's a signleton filters \u2014 The filters database Methods register ( name_or_filter , mode ) \u2014 Register a filter </> unregister ( name , mode ) \u2014 Unregister a filter </> method","title":"liquid.python.filters.FilterManager"},{"location":"api/liquid.python.filters/#liquidfiltersfiltermanagerregister","text":"</> Register a filter This can be used as a decorator >>> @filter_manager . register >>> def add ( a , b ): >>> return a + b >>> # register it with an alias: >>> @filter_manager . register ( 'addfunc' ) >>> def add ( a , b ): >>> return a + b Parameters name_or_filter (optional) \u2014 The filter to register if name is given, will be treated as alias mode (optional) \u2014 Whether do it for given mode Returns The registered function or the decorator method","title":"liquid.filters.FilterManager.register"},{"location":"api/liquid.python.filters/#liquidfiltersfiltermanagerunregister","text":"</> Unregister a filter Parameters name \u2014 The name of the filter to unregister mode (optional) \u2014 Whether do it for given mode Returns The unregistered filter or None if name does not exist function","title":"liquid.filters.FilterManager.unregister"},{"location":"api/liquid.python.filters/#liquidpythonfiltersgetitem","text":"</> Get an item from the base value function","title":"liquid.python.filters.getitem"},{"location":"api/liquid.python.filters/#liquidpythonfiltersrender","text":"</> Render a template in python mode","title":"liquid.python.filters.render"},{"location":"api/liquid.python/","text":"package liquid . python </> module liquid.python . parser </> BLock parser to parse the text into blocks in python mode Classes NodeTag \u2014 Node tag for python mode using a different tag manager </> NodeComment \u2014 Node comment for python mode </> NodeOutput \u2014 Node output for python mode using a different tag manager </> NodeScanner \u2014 Allows NodeComment: {# ... #} </> Parser \u2014 Parsing text into blocks in python mode </> package liquid.python . tags </> Tags related definitions for python mode module liquid.python . filters </> Management for filters in extended mode Classes FilterManager \u2014 A manager for filters in extended mode </> Functions getitem ( base , index ) \u2014 Get an item from the base value </> render ( base , **envs ) \u2014 Render a template in python mode </>","title":"liquid.python"},{"location":"api/liquid.python/#liquidpython","text":"</> module","title":"liquid.python"},{"location":"api/liquid.python/#liquidpythonparser","text":"</> BLock parser to parse the text into blocks in python mode Classes NodeTag \u2014 Node tag for python mode using a different tag manager </> NodeComment \u2014 Node comment for python mode </> NodeOutput \u2014 Node output for python mode using a different tag manager </> NodeScanner \u2014 Allows NodeComment: {# ... #} </> Parser \u2014 Parsing text into blocks in python mode </> package","title":"liquid.python.parser"},{"location":"api/liquid.python/#liquidpythontags","text":"</> Tags related definitions for python mode module","title":"liquid.python.tags"},{"location":"api/liquid.python/#liquidpythonfilters","text":"</> Management for filters in extended mode Classes FilterManager \u2014 A manager for filters in extended mode </> Functions getitem ( base , index ) \u2014 Get an item from the base value </> render ( base , **envs ) \u2014 Render a template in python mode </>","title":"liquid.python.filters"},{"location":"api/liquid.python.parser/","text":"module liquid.python . parser </> BLock parser to parse the text into blocks in python mode Classes NodeTag \u2014 Node tag for python mode using a different tag manager </> NodeComment \u2014 Node comment for python mode </> NodeOutput \u2014 Node output for python mode using a different tag manager </> NodeScanner \u2014 Allows NodeComment: {# ... #} </> Parser \u2014 Parsing text into blocks in python mode </> class liquid.python.parser . NodeTag ( *args , **kwargs ) </> Bases liquid.nodes.NodeTag liquid.nodes.Node Node tag for python mode using a different tag manager Attributes CLOSE_TAG \u2014 The close tags for the node OPEN_TAG \u2014 The open tags for the node TAG_MANAGER \u2014 The tag manager close_compact \u2014 Whether close tag is compact content \u2014 The content of the node context \u2014 The context of the node name \u2014 The name of the node open_compact \u2014 Whether open tag is compact raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod __init_subclass__ ( tag_manager=<liquid.tags.manager.TagManager object at 0x7f0fc31dfa00> ) </> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. class liquid.python.parser . NodeComment ( content , context , parser , open_tag='' , close_tag='' ) </> Bases liquid.nodes.Node Node comment for python mode Parameters content \u2014 The content of the node context \u2014 The context of the node parser \u2014 The parser open_tag (optional) \u2014 The open tag of the node close_tag (optional) \u2014 The close tag of the node Attributes CLOSE_TAG \u2014 The close tags for the node OPEN_TAG \u2014 The open tags for the node TAG_MANAGER \u2014 The tag manager close_compact \u2014 Whether close tag is compact content \u2014 The content of the node context \u2014 The context of the node name \u2014 The name of the node open_compact \u2014 Whether open tag is compact raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod __init_subclass__ ( tag_manager=<liquid.tags.manager.TagManager object at 0x7f0fc31dfa00> ) </> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. class liquid.python.parser . NodeOutput ( content , context , parser , open_tag='' , close_tag='' ) </> Bases liquid.nodes.NodeOutput liquid.nodes.Node Node output for python mode using a different tag manager Parameters content \u2014 The content of the node context \u2014 The context of the node parser \u2014 The parser open_tag (optional) \u2014 The open tag of the node close_tag (optional) \u2014 The close tag of the node Attributes CLOSE_TAG \u2014 The close tags for the node OPEN_TAG \u2014 The open tags for the node TAG_MANAGER \u2014 The tag manager close_compact \u2014 Whether close tag is compact content \u2014 The content of the node context \u2014 The context of the node name \u2014 The name of the node open_compact \u2014 Whether open tag is compact raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod __init_subclass__ ( tag_manager=<liquid.tags.manager.TagManager object at 0x7f0fc31dfa00> ) </> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. class liquid.python.parser . NodeScanner ( context , parser ) </> Bases liquid.nodes.NodeScanner Allows NodeComment: {# ... #} Attributes LITERAL \u2014 The literal node NODES \u2014 The possible nodes OPEN_CHARS \u2014 The start characters of open tags for those nodes This is to speed up the lookup for a potential hit of a node closetag_buffer \u2014 The buffer for close tags content_buffer \u2014 The buffer for content of potential nodes context \u2014 The context of the potential node escape \u2014 Whether the previous character is an escape ( \\ ) hit \u2014 The node we hit This will be only fit when there is only one type of node hit literal_buffer \u2014 The buffer for literal nodes This will not consume the potential node open_context \u2014 Where the open tag hits opentag_buffer \u2014 The buffer for open tags parser \u2014 The parser rawtag \u2014 The matched raw tag name Classes NodeLiteral \u2014 The literal node </> Methods consume ( stream ) (True) \u2014 Consume the character of a stream </> class liquid.nodes . NodeLiteral ( content , context , parser , open_tag='' , close_tag='' ) </> Bases liquid.nodes.Node The literal node Attributes raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod __init_subclass__ ( tag_manager=<liquid.tags.manager.TagManager object at 0x7f0fc31dfa00> ) </> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method consume ( stream ) </> Consume the character of a stream if it is empty, then we hit the end of the stream. Otherwise, we need to update the context, and add the character to the buffer. Parameters stream \u2014 The stream to consume Returns (True) we should continue consuming False: we should stop consuming (we hit the end of the stream) Node: A complete node hit class liquid.python.parser . Parser ( meta , config , context=None , level=0 ) </> Bases liquid.parser.Parser Parsing text into blocks in python mode Parameters meta \u2014 The template meta data config \u2014 The configuration context (optional) \u2014 The context level (optional) \u2014 The level of the parser Classes Visitor \u2014 Vistor to visit parsed node </> NodeScanner \u2014 Allows NodeComment: {# ... #} </> Methods parse ( ) \u2014 Parser the template for later rendering. </> class liquid.parser . Visitor ( root ) </> Vistor to visit parsed node Attributes blocks \u2014 The block tags, used to replace the mother's ones has_mother \u2014 Indicates whether this template is extended from a mother template root \u2014 The root tag stack \u2014 The tag stack, used to resolve the structure Parameters root \u2014 The root tag Methods visit ( tag ) \u2014 Visit the tag </> method visit ( tag ) </> Visit the tag Parameters tag \u2014 The tag method parse ( ) </> Parser the template for later rendering. Returns The root tag for later rendering class liquid.python.parser . NodeScanner ( context , parser ) </> Bases liquid.nodes.NodeScanner Allows NodeComment: {# ... #} Classes NodeLiteral \u2014 The literal node </> Methods consume ( stream ) (True) \u2014 Consume the character of a stream </> class liquid.nodes . NodeLiteral ( content , context , parser , open_tag='' , close_tag='' ) </> Bases liquid.nodes.Node The literal node Attributes raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod __init_subclass__ ( tag_manager=<liquid.tags.manager.TagManager object at 0x7f0fc31dfa00> ) </> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method consume ( stream ) </> Consume the character of a stream if it is empty, then we hit the end of the stream. Otherwise, we need to update the context, and add the character to the buffer. Parameters stream \u2014 The stream to consume Returns (True) we should continue consuming False: we should stop consuming (we hit the end of the stream) Node: A complete node hit","title":"liquid.python.parser"},{"location":"api/liquid.python.parser/#liquidpythonparser","text":"</> BLock parser to parse the text into blocks in python mode Classes NodeTag \u2014 Node tag for python mode using a different tag manager </> NodeComment \u2014 Node comment for python mode </> NodeOutput \u2014 Node output for python mode using a different tag manager </> NodeScanner \u2014 Allows NodeComment: {# ... #} </> Parser \u2014 Parsing text into blocks in python mode </> class","title":"liquid.python.parser"},{"location":"api/liquid.python.parser/#liquidpythonparsernodetag","text":"</> Bases liquid.nodes.NodeTag liquid.nodes.Node Node tag for python mode using a different tag manager Attributes CLOSE_TAG \u2014 The close tags for the node OPEN_TAG \u2014 The open tags for the node TAG_MANAGER \u2014 The tag manager close_compact \u2014 Whether close tag is compact content \u2014 The content of the node context \u2014 The context of the node name \u2014 The name of the node open_compact \u2014 Whether open tag is compact raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod","title":"liquid.python.parser.NodeTag"},{"location":"api/liquid.python.parser/#liquidnodesnodeinit_subclass","text":"</> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. class","title":"liquid.nodes.Node.init_subclass"},{"location":"api/liquid.python.parser/#liquidpythonparsernodecomment","text":"</> Bases liquid.nodes.Node Node comment for python mode Parameters content \u2014 The content of the node context \u2014 The context of the node parser \u2014 The parser open_tag (optional) \u2014 The open tag of the node close_tag (optional) \u2014 The close tag of the node Attributes CLOSE_TAG \u2014 The close tags for the node OPEN_TAG \u2014 The open tags for the node TAG_MANAGER \u2014 The tag manager close_compact \u2014 Whether close tag is compact content \u2014 The content of the node context \u2014 The context of the node name \u2014 The name of the node open_compact \u2014 Whether open tag is compact raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod","title":"liquid.python.parser.NodeComment"},{"location":"api/liquid.python.parser/#liquidnodesnodeinit_subclass_1","text":"</> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. class","title":"liquid.nodes.Node.init_subclass"},{"location":"api/liquid.python.parser/#liquidpythonparsernodeoutput","text":"</> Bases liquid.nodes.NodeOutput liquid.nodes.Node Node output for python mode using a different tag manager Parameters content \u2014 The content of the node context \u2014 The context of the node parser \u2014 The parser open_tag (optional) \u2014 The open tag of the node close_tag (optional) \u2014 The close tag of the node Attributes CLOSE_TAG \u2014 The close tags for the node OPEN_TAG \u2014 The open tags for the node TAG_MANAGER \u2014 The tag manager close_compact \u2014 Whether close tag is compact content \u2014 The content of the node context \u2014 The context of the node name \u2014 The name of the node open_compact \u2014 Whether open tag is compact raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod","title":"liquid.python.parser.NodeOutput"},{"location":"api/liquid.python.parser/#liquidnodesnodeinit_subclass_2","text":"</> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. class","title":"liquid.nodes.Node.init_subclass"},{"location":"api/liquid.python.parser/#liquidpythonparsernodescanner","text":"</> Bases liquid.nodes.NodeScanner Allows NodeComment: {# ... #} Attributes LITERAL \u2014 The literal node NODES \u2014 The possible nodes OPEN_CHARS \u2014 The start characters of open tags for those nodes This is to speed up the lookup for a potential hit of a node closetag_buffer \u2014 The buffer for close tags content_buffer \u2014 The buffer for content of potential nodes context \u2014 The context of the potential node escape \u2014 Whether the previous character is an escape ( \\ ) hit \u2014 The node we hit This will be only fit when there is only one type of node hit literal_buffer \u2014 The buffer for literal nodes This will not consume the potential node open_context \u2014 Where the open tag hits opentag_buffer \u2014 The buffer for open tags parser \u2014 The parser rawtag \u2014 The matched raw tag name Classes NodeLiteral \u2014 The literal node </> Methods consume ( stream ) (True) \u2014 Consume the character of a stream </> class","title":"liquid.python.parser.NodeScanner"},{"location":"api/liquid.python.parser/#liquidnodesnodeliteral","text":"</> Bases liquid.nodes.Node The literal node Attributes raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod __init_subclass__ ( tag_manager=<liquid.tags.manager.TagManager object at 0x7f0fc31dfa00> ) </> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method","title":"liquid.nodes.NodeLiteral"},{"location":"api/liquid.python.parser/#liquidnodesnodescannerconsume","text":"</> Consume the character of a stream if it is empty, then we hit the end of the stream. Otherwise, we need to update the context, and add the character to the buffer. Parameters stream \u2014 The stream to consume Returns (True) we should continue consuming False: we should stop consuming (we hit the end of the stream) Node: A complete node hit class","title":"liquid.nodes.NodeScanner.consume"},{"location":"api/liquid.python.parser/#liquidpythonparserparser","text":"</> Bases liquid.parser.Parser Parsing text into blocks in python mode Parameters meta \u2014 The template meta data config \u2014 The configuration context (optional) \u2014 The context level (optional) \u2014 The level of the parser Classes Visitor \u2014 Vistor to visit parsed node </> NodeScanner \u2014 Allows NodeComment: {# ... #} </> Methods parse ( ) \u2014 Parser the template for later rendering. </> class","title":"liquid.python.parser.Parser"},{"location":"api/liquid.python.parser/#liquidparservisitor","text":"</> Vistor to visit parsed node Attributes blocks \u2014 The block tags, used to replace the mother's ones has_mother \u2014 Indicates whether this template is extended from a mother template root \u2014 The root tag stack \u2014 The tag stack, used to resolve the structure Parameters root \u2014 The root tag Methods visit ( tag ) \u2014 Visit the tag </> method visit ( tag ) </> Visit the tag Parameters tag \u2014 The tag method","title":"liquid.parser.Visitor"},{"location":"api/liquid.python.parser/#liquidparserparserparse","text":"</> Parser the template for later rendering. Returns The root tag for later rendering class","title":"liquid.parser.Parser.parse"},{"location":"api/liquid.python.parser/#liquidpythonparsernodescanner_1","text":"</> Bases liquid.nodes.NodeScanner Allows NodeComment: {# ... #} Classes NodeLiteral \u2014 The literal node </> Methods consume ( stream ) (True) \u2014 Consume the character of a stream </> class liquid.nodes . NodeLiteral ( content , context , parser , open_tag='' , close_tag='' ) </> Bases liquid.nodes.Node The literal node Attributes raw \u2014 Check whether this node is in raw mode </> tag \u2014 Get the tag from the node </> Methods __init_subclass__ ( tag_manager ) \u2014 This method is called when a class is subclassed. </> classmethod __init_subclass__ ( tag_manager=<liquid.tags.manager.TagManager object at 0x7f0fc31dfa00> ) </> This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. method consume ( stream ) </> Consume the character of a stream if it is empty, then we hit the end of the stream. Otherwise, we need to update the context, and add the character to the buffer. Parameters stream \u2014 The stream to consume Returns (True) we should continue consuming False: we should stop consuming (we hit the end of the stream) Node: A complete node hit","title":"liquid.python.parser.NodeScanner"},{"location":"api/liquid.python.tags.inherited/","text":"module liquid.python.tags . inherited </> About tags inherited from standard mode Classes TagManager \u2014 Tag manager for tags in python mode </> Tag \u2014 The base tag class for tags in python mode </> class liquid.python.tags.inherited . TagManager ( *args , **kwargs ) </> Bases liquid.tags.manager.TagManager liquid.utils.Singleton Tag manager for tags in python mode Attributes INSTANCE \u2014 The instance of this singleton class tags \u2014 The tags database Methods get ( name ) \u2014 Get the tag class </> register ( tag_class_or_alias , mode ) \u2014 Register a tag </> unregister ( tagname , mode ) \u2014 Unregister a tag </> method register ( tag_class_or_alias=None , mode='standard' ) </> Register a tag This can be worked as a decorator Parameters tag_class_or_alias (optional) \u2014 The tag class or the alias for the tag class to decorate mode (optional) \u2014 Whether do it for given mode Returns The decorator or the decorated class method unregister ( tagname , mode='standard' ) </> Unregister a tag Parameters tagname \u2014 The name of the tag to unregister mode (optional) \u2014 Whether do it for given mode Returns The tag class unregistered. It can be used to be re-registered method get ( name ) </> Get the tag class Parameters name \u2014 The name of the tag Returns The tag class or None if name does not exist class liquid.python.tags.inherited . Tag ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag.Tag The base tag class for tags in python mode Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.python.tags.inherited"},{"location":"api/liquid.python.tags.inherited/#liquidpythontagsinherited","text":"</> About tags inherited from standard mode Classes TagManager \u2014 Tag manager for tags in python mode </> Tag \u2014 The base tag class for tags in python mode </> class","title":"liquid.python.tags.inherited"},{"location":"api/liquid.python.tags.inherited/#liquidpythontagsinheritedtagmanager","text":"</> Bases liquid.tags.manager.TagManager liquid.utils.Singleton Tag manager for tags in python mode Attributes INSTANCE \u2014 The instance of this singleton class tags \u2014 The tags database Methods get ( name ) \u2014 Get the tag class </> register ( tag_class_or_alias , mode ) \u2014 Register a tag </> unregister ( tagname , mode ) \u2014 Unregister a tag </> method","title":"liquid.python.tags.inherited.TagManager"},{"location":"api/liquid.python.tags.inherited/#liquidtagsmanagertagmanagerregister","text":"</> Register a tag This can be worked as a decorator Parameters tag_class_or_alias (optional) \u2014 The tag class or the alias for the tag class to decorate mode (optional) \u2014 Whether do it for given mode Returns The decorator or the decorated class method","title":"liquid.tags.manager.TagManager.register"},{"location":"api/liquid.python.tags.inherited/#liquidtagsmanagertagmanagerunregister","text":"</> Unregister a tag Parameters tagname \u2014 The name of the tag to unregister mode (optional) \u2014 Whether do it for given mode Returns The tag class unregistered. It can be used to be re-registered method","title":"liquid.tags.manager.TagManager.unregister"},{"location":"api/liquid.python.tags.inherited/#liquidtagsmanagertagmanagerget","text":"</> Get the tag class Parameters name \u2014 The name of the tag Returns The tag class or None if name does not exist class","title":"liquid.tags.manager.TagManager.get"},{"location":"api/liquid.python.tags.inherited/#liquidpythontagsinheritedtag","text":"</> Bases liquid.tags.tag.Tag The base tag class for tags in python mode Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.inherited.Tag"},{"location":"api/liquid.python.tags.inherited/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.inherited/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.python.tags.inherited/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.inherited/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.inherited/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.inherited/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.inherited/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.inherited/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.inherited/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags/","text":"package liquid.python . tags </> Tags related definitions for python mode module liquid.python.tags . tag_while </> Tag while Classes TagWhile \u2014 The for tag </> module liquid.python.tags . tag_python </> The python tag Classes TagPython \u2014 It can be either void or non-void </> module liquid.python.tags . tag_else </> Tag else Classes TagElseTransformer \u2014 The transformer for tag else </> TagElse \u2014 Tag else in python mode </> module liquid.python.tags . tag_from </> Tag from Classes TagFrom \u2014 Import submodules from python </> module liquid.python.tags . tag_unless </> Tag unless Classes TagUnless \u2014 Tag unless, with no emptydrop stuff </> module liquid.python.tags . tag_if </> Tag if Classes TagIf \u2014 Tag if. </> module liquid.python.tags . tag_for </> More pythonic for tag for python mode of liquidpy Classes TagForTransformer \u2014 Transformer for tag for </> TagFor \u2014 The for tag </> module liquid.python.tags . tag__inherited </> Tags inherited from standard mode Classes TagBreak \u2014 Tag break in python mode </> TagContinue \u2014 Tag continue in python mode </> TagCOMMENT \u2014 The {# ... #} tag </> TagOUTPUT \u2014 The output tag {{ ... }} </> TagCase \u2014 The case tag </> TagWhen \u2014 The when tag </> TagConfigTransformer \u2014 The transformer for tag config </> TagConfig \u2014 The tag config </> TagCycleTransformer \u2014 The transformer for tag assign </> TagCycle \u2014 The tag cycle </> TagElsif \u2014 The elif/elsif tag </> module liquid.python.tags . tag_assign </> Tag assign Classes TagAssignTransformer \u2014 The transformer for tag assign in python mode </> TagAssign \u2014 Tag assign in python mode </> module liquid.python.tags . tag_import </> Tag import Classes TagImport \u2014 Tag import to import a module from python </> module liquid.python.tags . inherited </> About tags inherited from standard mode Classes TagManager \u2014 Tag manager for tags in python mode </> Tag \u2014 The base tag class for tags in python mode </> module liquid.python.tags . transformer </> The segments and transformer for liquidpy in python mode Classes TagSegmentVar \u2014 Varaible segment in python mode. There will be no EmptyDrop object as rendered </> TagSegmentIfelse \u2014 The ternary operation in python: A if cond else B </> TagSegmentOr \u2014 Or statement in python </> TagSegmentAnd \u2014 And statement in python </> TagSegmentNot \u2014 Not statement in python </> TagSegmentGetAttr \u2014 Getattr operation in python </> TagSegmentGetItem \u2014 Getitem operation in python </> TagSegmentExpr \u2014 Expressions in python </> TagSegmentPower \u2014 Power expression in python </> TagSegmentFactor \u2014 Factor expression in python </> TagSegmentFuncCall \u2014 Function call in python </> TagSegmentTuple \u2014 Tuple literals in python </> TagSegmentList \u2014 List literals in python </> TagSegmentSet \u2014 Set literals in python </> TagSegmentDict \u2014 Dict literals in python </> TagSegmentSlice \u2014 Slice objects in python </> TagSegmentLambda \u2014 Lambda objects in python </> TagSegmentFilter \u2014 Filter segment </> TagTransformer \u2014 Transformer for python grammar </>","title":"liquid.python.tags"},{"location":"api/liquid.python.tags/#liquidpythontags","text":"</> Tags related definitions for python mode module","title":"liquid.python.tags"},{"location":"api/liquid.python.tags/#liquidpythontagstag_while","text":"</> Tag while Classes TagWhile \u2014 The for tag </> module","title":"liquid.python.tags.tag_while"},{"location":"api/liquid.python.tags/#liquidpythontagstag_python","text":"</> The python tag Classes TagPython \u2014 It can be either void or non-void </> module","title":"liquid.python.tags.tag_python"},{"location":"api/liquid.python.tags/#liquidpythontagstag_else","text":"</> Tag else Classes TagElseTransformer \u2014 The transformer for tag else </> TagElse \u2014 Tag else in python mode </> module","title":"liquid.python.tags.tag_else"},{"location":"api/liquid.python.tags/#liquidpythontagstag_from","text":"</> Tag from Classes TagFrom \u2014 Import submodules from python </> module","title":"liquid.python.tags.tag_from"},{"location":"api/liquid.python.tags/#liquidpythontagstag_unless","text":"</> Tag unless Classes TagUnless \u2014 Tag unless, with no emptydrop stuff </> module","title":"liquid.python.tags.tag_unless"},{"location":"api/liquid.python.tags/#liquidpythontagstag_if","text":"</> Tag if Classes TagIf \u2014 Tag if. </> module","title":"liquid.python.tags.tag_if"},{"location":"api/liquid.python.tags/#liquidpythontagstag_for","text":"</> More pythonic for tag for python mode of liquidpy Classes TagForTransformer \u2014 Transformer for tag for </> TagFor \u2014 The for tag </> module","title":"liquid.python.tags.tag_for"},{"location":"api/liquid.python.tags/#liquidpythontagstag__inherited","text":"</> Tags inherited from standard mode Classes TagBreak \u2014 Tag break in python mode </> TagContinue \u2014 Tag continue in python mode </> TagCOMMENT \u2014 The {# ... #} tag </> TagOUTPUT \u2014 The output tag {{ ... }} </> TagCase \u2014 The case tag </> TagWhen \u2014 The when tag </> TagConfigTransformer \u2014 The transformer for tag config </> TagConfig \u2014 The tag config </> TagCycleTransformer \u2014 The transformer for tag assign </> TagCycle \u2014 The tag cycle </> TagElsif \u2014 The elif/elsif tag </> module","title":"liquid.python.tags.tag__inherited"},{"location":"api/liquid.python.tags/#liquidpythontagstag_assign","text":"</> Tag assign Classes TagAssignTransformer \u2014 The transformer for tag assign in python mode </> TagAssign \u2014 Tag assign in python mode </> module","title":"liquid.python.tags.tag_assign"},{"location":"api/liquid.python.tags/#liquidpythontagstag_import","text":"</> Tag import Classes TagImport \u2014 Tag import to import a module from python </> module","title":"liquid.python.tags.tag_import"},{"location":"api/liquid.python.tags/#liquidpythontagsinherited","text":"</> About tags inherited from standard mode Classes TagManager \u2014 Tag manager for tags in python mode </> Tag \u2014 The base tag class for tags in python mode </> module","title":"liquid.python.tags.inherited"},{"location":"api/liquid.python.tags/#liquidpythontagstransformer","text":"</> The segments and transformer for liquidpy in python mode Classes TagSegmentVar \u2014 Varaible segment in python mode. There will be no EmptyDrop object as rendered </> TagSegmentIfelse \u2014 The ternary operation in python: A if cond else B </> TagSegmentOr \u2014 Or statement in python </> TagSegmentAnd \u2014 And statement in python </> TagSegmentNot \u2014 Not statement in python </> TagSegmentGetAttr \u2014 Getattr operation in python </> TagSegmentGetItem \u2014 Getitem operation in python </> TagSegmentExpr \u2014 Expressions in python </> TagSegmentPower \u2014 Power expression in python </> TagSegmentFactor \u2014 Factor expression in python </> TagSegmentFuncCall \u2014 Function call in python </> TagSegmentTuple \u2014 Tuple literals in python </> TagSegmentList \u2014 List literals in python </> TagSegmentSet \u2014 Set literals in python </> TagSegmentDict \u2014 Dict literals in python </> TagSegmentSlice \u2014 Slice objects in python </> TagSegmentLambda \u2014 Lambda objects in python </> TagSegmentFilter \u2014 Filter segment </> TagTransformer \u2014 Transformer for python grammar </>","title":"liquid.python.tags.transformer"},{"location":"api/liquid.python.tags.tag__inherited/","text":"module liquid.python.tags . tag__inherited </> Tags inherited from standard mode Classes TagBreak \u2014 Tag break in python mode </> TagContinue \u2014 Tag continue in python mode </> TagCOMMENT \u2014 The {# ... #} tag </> TagOUTPUT \u2014 The output tag {{ ... }} </> TagCase \u2014 The case tag </> TagWhen \u2014 The when tag </> TagConfigTransformer \u2014 The transformer for tag config </> TagConfig \u2014 The tag config </> TagCycleTransformer \u2014 The transformer for tag assign </> TagCycle \u2014 The tag cycle </> TagElsif \u2014 The elif/elsif tag </> class liquid.python.tags.tag__inherited . TagBreak ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag_break.TagBreak liquid.tags.tag.Tag Tag break in python mode Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Make sure no extra content for this tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method parse ( force=False ) </> Make sure no extra content for this tag class liquid.python.tags.tag__inherited . TagContinue ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag_continue.TagContinue liquid.tags.tag_break.TagBreak liquid.tags.tag.Tag Tag continue in python mode Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Make sure no extra content for this tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method parse ( force=False ) </> Make sure no extra content for this tag class liquid.python.tags.tag__inherited . TagCOMMENT ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.python.tags.inherited.Tag liquid.tags.tag.Tag The {# ... #} tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) class liquid.python.tags.tag__inherited . TagOUTPUT ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag__output.TagOUTPUT liquid.tags.tag.Tag The output tag {{ ... }} Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) class liquid.python.tags.tag__inherited . TagCase ( *args , **kwargs ) </> Bases liquid.python.tags.tag__inherited.TagOUTPUT liquid.tags.tag__output.TagOUTPUT liquid.tags.tag.Tag The case tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) class liquid.python.tags.tag__inherited . TagWhen ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.python.tags.tag__inherited.TagOUTPUT liquid.tags.tag__output.TagOUTPUT liquid.tags.tag.Tag The when tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) class liquid.python.tags.tag__inherited . TagConfigTransformer ( visit_tokens=False ) </> Bases liquid.python.tags.transformer.TagTransformer liquid.tags.tag_config.TagConfigTransformer liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag config Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> atom_dict ( marker ) \u2014 The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" </> atom_string ( *strings ) \u2014 The rule atom_string: string+ </> comparison ( expr , *op_and_exprs ) \u2014 The rule comparison: expr (_comp_op expr)* </> config_item ( varname , constant ) \u2014 Transform the tag_config rule </> dictmarker ( *tests ) \u2014 The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] </> factor ( factor_op_or_power , factor ) \u2014 The rule factor: _factor_op factor | power </> power ( atom_expr , factor ) \u2014 The rule power: atom_expr (\"**\" factor)? </> range ( token ) \u2014 Ranges </> tag_config ( *items ) \u2014 Transform the tag_config rule </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> test ( value , cond , false_value ) \u2014 The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method transform ( tree ) </> Transform the given tree, and return the final result method __mul__ ( other ) </> Chain two transformers together, returning a new transformer. method __default__ ( data , children , meta ) </> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method __default_token__ ( token ) </> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method range ( token ) </> Ranges method varname ( vname ) </> Keep the token information for tracking method argvalue ( test1 , test2=NOTHING ) </> rule argvalue: test (\"=\" test)? method tag_config ( *items ) </> Transform the tag_config rule method config_item ( varname , constant=True ) </> Transform the tag_config rule method test ( value , cond=NOTHING , false_value=NOTHING ) </> The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef method comparison ( expr , *op_and_exprs ) </> The rule comparison: expr (_comp_op expr)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method factor ( factor_op_or_power , factor=NOTHING ) </> The rule factor: _factor_op factor | power method power ( atom_expr , factor=NOTHING ) </> The rule power: atom_expr (\"**\" factor)? method dictmarker ( *tests ) </> The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] method atom_dict ( marker=NOTHING ) </> The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" method atom_string ( *strings ) </> The rule atom_string: string+ class liquid.python.tags.tag__inherited . TagConfig ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag_config.TagConfig liquid.tags.tag.Tag The tag config Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the configurations </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method parse ( force=False ) </> Parse the configurations class liquid.python.tags.tag__inherited . TagCycleTransformer ( visit_tokens=False ) </> Bases liquid.python.tags.transformer.TagTransformer liquid.tags.tag_cycle.TagCycleTransformer liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag assign Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> atom_dict ( marker ) \u2014 The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" </> atom_string ( *strings ) \u2014 The rule atom_string: string+ </> comparison ( expr , *op_and_exprs ) \u2014 The rule comparison: expr (_comp_op expr)* </> dictmarker ( *tests ) \u2014 The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] </> factor ( factor_op_or_power , factor ) \u2014 The rule factor: _factor_op factor | power </> power ( atom_expr , factor ) \u2014 The rule power: atom_expr (\"**\" factor)? </> range ( token ) \u2014 Ranges </> tag_cycle ( group , args ) \u2014 Transformer for tag for </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> test ( value , cond , false_value ) \u2014 The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method transform ( tree ) </> Transform the given tree, and return the final result method __mul__ ( other ) </> Chain two transformers together, returning a new transformer. method __default__ ( data , children , meta ) </> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method __default_token__ ( token ) </> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method range ( token ) </> Ranges method varname ( vname ) </> Keep the token information for tracking method argvalue ( test1 , test2=NOTHING ) </> rule argvalue: test (\"=\" test)? method tag_cycle ( group , args=None ) </> Transformer for tag for method test ( value , cond=NOTHING , false_value=NOTHING ) </> The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef method comparison ( expr , *op_and_exprs ) </> The rule comparison: expr (_comp_op expr)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method factor ( factor_op_or_power , factor=NOTHING ) </> The rule factor: _factor_op factor | power method power ( atom_expr , factor=NOTHING ) </> The rule power: atom_expr (\"**\" factor)? method dictmarker ( *tests ) </> The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] method atom_dict ( marker=NOTHING ) </> The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" method atom_string ( *strings ) </> The rule atom_string: string+ class liquid.python.tags.tag__inherited . TagCycle ( *args , **kwargs ) </> Bases liquid.tags.tag_cycle.TagCycle liquid.tags.tag.Tag The tag cycle Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> args ( local_vars , global_vars ) \u2014 Get the args of the cycle </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> get_value ( local_vars , global_vars ) \u2014 Get current value of the cycle, and increment the cursor </> group ( local_vars , global_vars ) \u2014 Get the group of the cycle </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method group ( local_vars , global_vars ) </> Get the group of the cycle method args ( local_vars , global_vars ) </> Get the args of the cycle method get_value ( local_vars , global_vars ) </> Get current value of the cycle, and increment the cursor class liquid.python.tags.tag__inherited . TagElsif ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.python.tags.tag_if.TagIf liquid.tags.tag_if.TagIf liquid.tags.tag.Tag The elif/elsif tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.python.tags.tag__inherited"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstag__inherited","text":"</> Tags inherited from standard mode Classes TagBreak \u2014 Tag break in python mode </> TagContinue \u2014 Tag continue in python mode </> TagCOMMENT \u2014 The {# ... #} tag </> TagOUTPUT \u2014 The output tag {{ ... }} </> TagCase \u2014 The case tag </> TagWhen \u2014 The when tag </> TagConfigTransformer \u2014 The transformer for tag config </> TagConfig \u2014 The tag config </> TagCycleTransformer \u2014 The transformer for tag assign </> TagCycle \u2014 The tag cycle </> TagElsif \u2014 The elif/elsif tag </> class","title":"liquid.python.tags.tag__inherited"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstag__inheritedtagbreak","text":"</> Bases liquid.tags.tag_break.TagBreak liquid.tags.tag.Tag Tag break in python mode Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Make sure no extra content for this tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag__inherited.TagBreak"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstag_breaktagbreakparse","text":"</> Make sure no extra content for this tag class","title":"liquid.tags.tag_break.TagBreak.parse"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstag__inheritedtagcontinue","text":"</> Bases liquid.tags.tag_continue.TagContinue liquid.tags.tag_break.TagBreak liquid.tags.tag.Tag Tag continue in python mode Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Make sure no extra content for this tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag__inherited.TagContinue"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtaginit_subclass_1","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagparse_children_1","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrepr_1","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_elder_1","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_parent_1","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_parents_1","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_elders_1","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrender_1","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstag_breaktagbreakparse_1","text":"</> Make sure no extra content for this tag class","title":"liquid.tags.tag_break.TagBreak.parse"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstag__inheritedtagcomment","text":"</> Bases liquid.python.tags.inherited.Tag liquid.tags.tag.Tag The {# ... #} tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag__inherited.TagCOMMENT"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtaginit_subclass_2","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagparse_children_2","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrepr_2","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_elder_2","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_parent_2","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_parents_2","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_elders_2","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrender_2","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) class","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstag__inheritedtagoutput","text":"</> Bases liquid.tags.tag__output.TagOUTPUT liquid.tags.tag.Tag The output tag {{ ... }} Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag__inherited.TagOUTPUT"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtaginit_subclass_3","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagparse_1","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagparse_children_3","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrepr_3","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_elder_3","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_parent_3","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_parents_3","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_elders_3","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrender_3","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) class","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstag__inheritedtagcase","text":"</> Bases liquid.python.tags.tag__inherited.TagOUTPUT liquid.tags.tag__output.TagOUTPUT liquid.tags.tag.Tag The case tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag__inherited.TagCase"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtaginit_subclass_4","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagparse_2","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagparse_children_4","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrepr_4","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_elder_4","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_parent_4","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_parents_4","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_elders_4","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrender_4","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) class","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstag__inheritedtagwhen","text":"</> Bases liquid.python.tags.tag__inherited.TagOUTPUT liquid.tags.tag__output.TagOUTPUT liquid.tags.tag.Tag The when tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag__inherited.TagWhen"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtaginit_subclass_5","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagparse_3","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagparse_children_5","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrepr_5","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_elder_5","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_parent_5","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_parents_5","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_elders_5","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrender_5","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) class","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstag__inheritedtagconfigtransformer","text":"</> Bases liquid.python.tags.transformer.TagTransformer liquid.tags.tag_config.TagConfigTransformer liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag config Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> atom_dict ( marker ) \u2014 The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" </> atom_string ( *strings ) \u2014 The rule atom_string: string+ </> comparison ( expr , *op_and_exprs ) \u2014 The rule comparison: expr (_comp_op expr)* </> config_item ( varname , constant ) \u2014 Transform the tag_config rule </> dictmarker ( *tests ) \u2014 The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] </> factor ( factor_op_or_power , factor ) \u2014 The rule factor: _factor_op factor | power </> power ( atom_expr , factor ) \u2014 The rule power: atom_expr (\"**\" factor)? </> range ( token ) \u2014 Ranges </> tag_config ( *items ) \u2014 Transform the tag_config rule </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> test ( value , cond , false_value ) \u2014 The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method","title":"liquid.python.tags.tag__inherited.TagConfigTransformer"},{"location":"api/liquid.python.tags.tag__inherited/#larkvisitorstransformertransform","text":"</> Transform the given tree, and return the final result method","title":"lark.visitors.Transformer.transform"},{"location":"api/liquid.python.tags.tag__inherited/#larkvisitorstransformermul","text":"</> Chain two transformers together, returning a new transformer. method","title":"lark.visitors.Transformer.mul"},{"location":"api/liquid.python.tags.tag__inherited/#larkvisitorstransformerdefault","text":"</> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method","title":"lark.visitors.Transformer.default"},{"location":"api/liquid.python.tags.tag__inherited/#larkvisitorstransformerdefault_token","text":"</> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method","title":"lark.visitors.Transformer.default_token"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstransformertagtransformerrange","text":"</> Ranges method","title":"liquid.tags.transformer.TagTransformer.range"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstransformertagtransformervarname","text":"</> Keep the token information for tracking method","title":"liquid.tags.transformer.TagTransformer.varname"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstransformertagtransformerargvalue","text":"</> rule argvalue: test (\"=\" test)? method","title":"liquid.tags.transformer.TagTransformer.argvalue"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstag_configtagconfigtransformertag_config","text":"</> Transform the tag_config rule method","title":"liquid.tags.tag_config.TagConfigTransformer.tag_config"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstag_configtagconfigtransformerconfig_item","text":"</> Transform the tag_config rule method","title":"liquid.tags.tag_config.TagConfigTransformer.config_item"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformertest","text":"</> The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef method","title":"liquid.python.tags.transformer.TagTransformer.test"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformercomparison","text":"</> The rule comparison: expr (_comp_op expr)* method","title":"liquid.python.tags.transformer.TagTransformer.comparison"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformerterm","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformerterm_1","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformerterm_2","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformerfactor","text":"</> The rule factor: _factor_op factor | power method","title":"liquid.python.tags.transformer.TagTransformer.factor"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformerpower","text":"</> The rule power: atom_expr (\"**\" factor)? method","title":"liquid.python.tags.transformer.TagTransformer.power"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformerdictmarker","text":"</> The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] method","title":"liquid.python.tags.transformer.TagTransformer.dictmarker"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformeratom_dict","text":"</> The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" method","title":"liquid.python.tags.transformer.TagTransformer.atom_dict"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformeratom_string","text":"</> The rule atom_string: string+ class","title":"liquid.python.tags.transformer.TagTransformer.atom_string"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstag__inheritedtagconfig","text":"</> Bases liquid.tags.tag_config.TagConfig liquid.tags.tag.Tag The tag config Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the configurations </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag__inherited.TagConfig"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtaginit_subclass_6","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagparse_children_6","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrepr_6","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_elder_6","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_parent_6","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_parents_6","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_elders_6","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrender_6","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstag_configtagconfigparse","text":"</> Parse the configurations class","title":"liquid.tags.tag_config.TagConfig.parse"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstag__inheritedtagcycletransformer","text":"</> Bases liquid.python.tags.transformer.TagTransformer liquid.tags.tag_cycle.TagCycleTransformer liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag assign Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> atom_dict ( marker ) \u2014 The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" </> atom_string ( *strings ) \u2014 The rule atom_string: string+ </> comparison ( expr , *op_and_exprs ) \u2014 The rule comparison: expr (_comp_op expr)* </> dictmarker ( *tests ) \u2014 The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] </> factor ( factor_op_or_power , factor ) \u2014 The rule factor: _factor_op factor | power </> power ( atom_expr , factor ) \u2014 The rule power: atom_expr (\"**\" factor)? </> range ( token ) \u2014 Ranges </> tag_cycle ( group , args ) \u2014 Transformer for tag for </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> test ( value , cond , false_value ) \u2014 The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method","title":"liquid.python.tags.tag__inherited.TagCycleTransformer"},{"location":"api/liquid.python.tags.tag__inherited/#larkvisitorstransformertransform_1","text":"</> Transform the given tree, and return the final result method","title":"lark.visitors.Transformer.transform"},{"location":"api/liquid.python.tags.tag__inherited/#larkvisitorstransformermul_1","text":"</> Chain two transformers together, returning a new transformer. method","title":"lark.visitors.Transformer.mul"},{"location":"api/liquid.python.tags.tag__inherited/#larkvisitorstransformerdefault_1","text":"</> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method","title":"lark.visitors.Transformer.default"},{"location":"api/liquid.python.tags.tag__inherited/#larkvisitorstransformerdefault_token_1","text":"</> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method","title":"lark.visitors.Transformer.default_token"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstransformertagtransformerrange_1","text":"</> Ranges method","title":"liquid.tags.transformer.TagTransformer.range"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstransformertagtransformervarname_1","text":"</> Keep the token information for tracking method","title":"liquid.tags.transformer.TagTransformer.varname"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstransformertagtransformerargvalue_1","text":"</> rule argvalue: test (\"=\" test)? method","title":"liquid.tags.transformer.TagTransformer.argvalue"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstag_cycletagcycletransformertag_cycle","text":"</> Transformer for tag for method","title":"liquid.tags.tag_cycle.TagCycleTransformer.tag_cycle"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformertest_1","text":"</> The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef method","title":"liquid.python.tags.transformer.TagTransformer.test"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformercomparison_1","text":"</> The rule comparison: expr (_comp_op expr)* method","title":"liquid.python.tags.transformer.TagTransformer.comparison"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformerterm_3","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformerterm_4","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformerterm_5","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformerfactor_1","text":"</> The rule factor: _factor_op factor | power method","title":"liquid.python.tags.transformer.TagTransformer.factor"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformerpower_1","text":"</> The rule power: atom_expr (\"**\" factor)? method","title":"liquid.python.tags.transformer.TagTransformer.power"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformerdictmarker_1","text":"</> The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] method","title":"liquid.python.tags.transformer.TagTransformer.dictmarker"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformeratom_dict_1","text":"</> The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" method","title":"liquid.python.tags.transformer.TagTransformer.atom_dict"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstransformertagtransformeratom_string_1","text":"</> The rule atom_string: string+ class","title":"liquid.python.tags.transformer.TagTransformer.atom_string"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstag__inheritedtagcycle","text":"</> Bases liquid.tags.tag_cycle.TagCycle liquid.tags.tag.Tag The tag cycle Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> args ( local_vars , global_vars ) \u2014 Get the args of the cycle </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> get_value ( local_vars , global_vars ) \u2014 Get current value of the cycle, and increment the cursor </> group ( local_vars , global_vars ) \u2014 Get the group of the cycle </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag__inherited.TagCycle"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtaginit_subclass_7","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagparse_4","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagparse_children_7","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrepr_7","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_elder_7","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_parent_7","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_parents_7","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_elders_7","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrender_7","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstag_cycletagcyclegroup","text":"</> Get the group of the cycle method","title":"liquid.tags.tag_cycle.TagCycle.group"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstag_cycletagcycleargs","text":"</> Get the args of the cycle method","title":"liquid.tags.tag_cycle.TagCycle.args"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstag_cycletagcycleget_value","text":"</> Get current value of the cycle, and increment the cursor class","title":"liquid.tags.tag_cycle.TagCycle.get_value"},{"location":"api/liquid.python.tags.tag__inherited/#liquidpythontagstag__inheritedtagelsif","text":"</> Bases liquid.python.tags.tag_if.TagIf liquid.tags.tag_if.TagIf liquid.tags.tag.Tag The elif/elsif tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag__inherited.TagElsif"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtaginit_subclass_8","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagparse_5","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagparse_children_8","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrepr_8","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_elder_8","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagis_parent_8","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_parents_8","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagcheck_elders_8","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag__inherited/#liquidtagstagtagrender_8","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag_assign/","text":"module liquid.python.tags . tag_assign </> Tag assign Classes TagAssignTransformer \u2014 The transformer for tag assign in python mode </> TagAssign \u2014 Tag assign in python mode </> class liquid.python.tags.tag_assign . TagAssignTransformer ( visit_tokens=False ) </> Bases liquid.python.tags.transformer.TagTransformer liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag assign in python mode Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> atom_dict ( marker ) \u2014 The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" </> atom_string ( *strings ) \u2014 The rule atom_string: string+ </> comparison ( expr , *op_and_exprs ) \u2014 The rule comparison: expr (_comp_op expr)* </> dictmarker ( *tests ) \u2014 The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] </> factor ( factor_op_or_power , factor ) \u2014 The rule factor: _factor_op factor | power </> power ( atom_expr , factor ) \u2014 The rule power: atom_expr (\"**\" factor)? </> range ( token ) \u2014 Ranges </> tag_assign ( varname , output ) \u2014 Transform the tag_assign rule </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> test ( value , cond , false_value ) \u2014 The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method transform ( tree ) </> Transform the given tree, and return the final result method __mul__ ( other ) </> Chain two transformers together, returning a new transformer. method __default__ ( data , children , meta ) </> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method __default_token__ ( token ) </> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method range ( token ) </> Ranges method varname ( vname ) </> Keep the token information for tracking method argvalue ( test1 , test2=NOTHING ) </> rule argvalue: test (\"=\" test)? method test ( value , cond=NOTHING , false_value=NOTHING ) </> The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef method comparison ( expr , *op_and_exprs ) </> The rule comparison: expr (_comp_op expr)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method factor ( factor_op_or_power , factor=NOTHING ) </> The rule factor: _factor_op factor | power method power ( atom_expr , factor=NOTHING ) </> The rule power: atom_expr (\"**\" factor)? method dictmarker ( *tests ) </> The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] method atom_dict ( marker=NOTHING ) </> The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" method atom_string ( *strings ) </> The rule atom_string: string+ method tag_assign ( varname , output ) </> Transform the tag_assign rule class liquid.python.tags.tag_assign . TagAssign ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag_assign.TagAssign liquid.tags.tag.Tag Tag assign in python mode Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.python.tags.tag_assign"},{"location":"api/liquid.python.tags.tag_assign/#liquidpythontagstag_assign","text":"</> Tag assign Classes TagAssignTransformer \u2014 The transformer for tag assign in python mode </> TagAssign \u2014 Tag assign in python mode </> class","title":"liquid.python.tags.tag_assign"},{"location":"api/liquid.python.tags.tag_assign/#liquidpythontagstag_assigntagassigntransformer","text":"</> Bases liquid.python.tags.transformer.TagTransformer liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag assign in python mode Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> atom_dict ( marker ) \u2014 The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" </> atom_string ( *strings ) \u2014 The rule atom_string: string+ </> comparison ( expr , *op_and_exprs ) \u2014 The rule comparison: expr (_comp_op expr)* </> dictmarker ( *tests ) \u2014 The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] </> factor ( factor_op_or_power , factor ) \u2014 The rule factor: _factor_op factor | power </> power ( atom_expr , factor ) \u2014 The rule power: atom_expr (\"**\" factor)? </> range ( token ) \u2014 Ranges </> tag_assign ( varname , output ) \u2014 Transform the tag_assign rule </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> test ( value , cond , false_value ) \u2014 The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method","title":"liquid.python.tags.tag_assign.TagAssignTransformer"},{"location":"api/liquid.python.tags.tag_assign/#larkvisitorstransformertransform","text":"</> Transform the given tree, and return the final result method","title":"lark.visitors.Transformer.transform"},{"location":"api/liquid.python.tags.tag_assign/#larkvisitorstransformermul","text":"</> Chain two transformers together, returning a new transformer. method","title":"lark.visitors.Transformer.mul"},{"location":"api/liquid.python.tags.tag_assign/#larkvisitorstransformerdefault","text":"</> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method","title":"lark.visitors.Transformer.default"},{"location":"api/liquid.python.tags.tag_assign/#larkvisitorstransformerdefault_token","text":"</> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method","title":"lark.visitors.Transformer.default_token"},{"location":"api/liquid.python.tags.tag_assign/#liquidtagstransformertagtransformerrange","text":"</> Ranges method","title":"liquid.tags.transformer.TagTransformer.range"},{"location":"api/liquid.python.tags.tag_assign/#liquidtagstransformertagtransformervarname","text":"</> Keep the token information for tracking method","title":"liquid.tags.transformer.TagTransformer.varname"},{"location":"api/liquid.python.tags.tag_assign/#liquidtagstransformertagtransformerargvalue","text":"</> rule argvalue: test (\"=\" test)? method","title":"liquid.tags.transformer.TagTransformer.argvalue"},{"location":"api/liquid.python.tags.tag_assign/#liquidpythontagstransformertagtransformertest","text":"</> The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef method","title":"liquid.python.tags.transformer.TagTransformer.test"},{"location":"api/liquid.python.tags.tag_assign/#liquidpythontagstransformertagtransformercomparison","text":"</> The rule comparison: expr (_comp_op expr)* method","title":"liquid.python.tags.transformer.TagTransformer.comparison"},{"location":"api/liquid.python.tags.tag_assign/#liquidpythontagstransformertagtransformerterm","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.tag_assign/#liquidpythontagstransformertagtransformerterm_1","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.tag_assign/#liquidpythontagstransformertagtransformerterm_2","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.tag_assign/#liquidpythontagstransformertagtransformerfactor","text":"</> The rule factor: _factor_op factor | power method","title":"liquid.python.tags.transformer.TagTransformer.factor"},{"location":"api/liquid.python.tags.tag_assign/#liquidpythontagstransformertagtransformerpower","text":"</> The rule power: atom_expr (\"**\" factor)? method","title":"liquid.python.tags.transformer.TagTransformer.power"},{"location":"api/liquid.python.tags.tag_assign/#liquidpythontagstransformertagtransformerdictmarker","text":"</> The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] method","title":"liquid.python.tags.transformer.TagTransformer.dictmarker"},{"location":"api/liquid.python.tags.tag_assign/#liquidpythontagstransformertagtransformeratom_dict","text":"</> The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" method","title":"liquid.python.tags.transformer.TagTransformer.atom_dict"},{"location":"api/liquid.python.tags.tag_assign/#liquidpythontagstransformertagtransformeratom_string","text":"</> The rule atom_string: string+ method","title":"liquid.python.tags.transformer.TagTransformer.atom_string"},{"location":"api/liquid.python.tags.tag_assign/#liquidpythontagstag_assigntagassigntransformertag_assign","text":"</> Transform the tag_assign rule class","title":"liquid.python.tags.tag_assign.TagAssignTransformer.tag_assign"},{"location":"api/liquid.python.tags.tag_assign/#liquidpythontagstag_assigntagassign","text":"</> Bases liquid.tags.tag_assign.TagAssign liquid.tags.tag.Tag Tag assign in python mode Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag_assign.TagAssign"},{"location":"api/liquid.python.tags.tag_assign/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag_assign/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.python.tags.tag_assign/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag_assign/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag_assign/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag_assign/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag_assign/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag_assign/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag_assign/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag_else/","text":"module liquid.python.tags . tag_else </> Tag else Classes TagElseTransformer \u2014 The transformer for tag else </> TagElse \u2014 Tag else in python mode </> class liquid.python.tags.tag_else . TagElseTransformer ( visit_tokens=False ) </> Bases liquid.python.tags.transformer.TagTransformer liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag else Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> atom_dict ( marker ) \u2014 The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" </> atom_string ( *strings ) \u2014 The rule atom_string: string+ </> comparison ( expr , *op_and_exprs ) \u2014 The rule comparison: expr (_comp_op expr)* </> dictmarker ( *tests ) \u2014 The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] </> factor ( factor_op_or_power , factor ) \u2014 The rule factor: _factor_op factor | power </> power ( atom_expr , factor ) \u2014 The rule power: atom_expr (\"**\" factor)? </> range ( token ) \u2014 Ranges </> tag_else ( test ) \u2014 Get whatever passed by </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> test ( value , cond , false_value ) \u2014 The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method transform ( tree ) </> Transform the given tree, and return the final result method __mul__ ( other ) </> Chain two transformers together, returning a new transformer. method __default__ ( data , children , meta ) </> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method __default_token__ ( token ) </> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method range ( token ) </> Ranges method varname ( vname ) </> Keep the token information for tracking method argvalue ( test1 , test2=NOTHING ) </> rule argvalue: test (\"=\" test)? method test ( value , cond=NOTHING , false_value=NOTHING ) </> The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef method comparison ( expr , *op_and_exprs ) </> The rule comparison: expr (_comp_op expr)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method factor ( factor_op_or_power , factor=NOTHING ) </> The rule factor: _factor_op factor | power method power ( atom_expr , factor=NOTHING ) </> The rule power: atom_expr (\"**\" factor)? method dictmarker ( *tests ) </> The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] method atom_dict ( marker=NOTHING ) </> The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" method atom_string ( *strings ) </> The rule atom_string: string+ method tag_else ( test=NOTHING ) </> Get whatever passed by class liquid.python.tags.tag_else . TagElse ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.python.tags.tag_if.TagIf liquid.tags.tag_if.TagIf liquid.tags.tag.Tag Tag else in python mode Allowed to be used with for, while and unless, too \"else if\" is also allowed here. Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Check to see if there is any siblings after a bare {% else %} tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method parse ( force=False ) </> Check to see if there is any siblings after a bare {% else %} tag","title":"liquid.python.tags.tag_else"},{"location":"api/liquid.python.tags.tag_else/#liquidpythontagstag_else","text":"</> Tag else Classes TagElseTransformer \u2014 The transformer for tag else </> TagElse \u2014 Tag else in python mode </> class","title":"liquid.python.tags.tag_else"},{"location":"api/liquid.python.tags.tag_else/#liquidpythontagstag_elsetagelsetransformer","text":"</> Bases liquid.python.tags.transformer.TagTransformer liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag else Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> atom_dict ( marker ) \u2014 The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" </> atom_string ( *strings ) \u2014 The rule atom_string: string+ </> comparison ( expr , *op_and_exprs ) \u2014 The rule comparison: expr (_comp_op expr)* </> dictmarker ( *tests ) \u2014 The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] </> factor ( factor_op_or_power , factor ) \u2014 The rule factor: _factor_op factor | power </> power ( atom_expr , factor ) \u2014 The rule power: atom_expr (\"**\" factor)? </> range ( token ) \u2014 Ranges </> tag_else ( test ) \u2014 Get whatever passed by </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> test ( value , cond , false_value ) \u2014 The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method","title":"liquid.python.tags.tag_else.TagElseTransformer"},{"location":"api/liquid.python.tags.tag_else/#larkvisitorstransformertransform","text":"</> Transform the given tree, and return the final result method","title":"lark.visitors.Transformer.transform"},{"location":"api/liquid.python.tags.tag_else/#larkvisitorstransformermul","text":"</> Chain two transformers together, returning a new transformer. method","title":"lark.visitors.Transformer.mul"},{"location":"api/liquid.python.tags.tag_else/#larkvisitorstransformerdefault","text":"</> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method","title":"lark.visitors.Transformer.default"},{"location":"api/liquid.python.tags.tag_else/#larkvisitorstransformerdefault_token","text":"</> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method","title":"lark.visitors.Transformer.default_token"},{"location":"api/liquid.python.tags.tag_else/#liquidtagstransformertagtransformerrange","text":"</> Ranges method","title":"liquid.tags.transformer.TagTransformer.range"},{"location":"api/liquid.python.tags.tag_else/#liquidtagstransformertagtransformervarname","text":"</> Keep the token information for tracking method","title":"liquid.tags.transformer.TagTransformer.varname"},{"location":"api/liquid.python.tags.tag_else/#liquidtagstransformertagtransformerargvalue","text":"</> rule argvalue: test (\"=\" test)? method","title":"liquid.tags.transformer.TagTransformer.argvalue"},{"location":"api/liquid.python.tags.tag_else/#liquidpythontagstransformertagtransformertest","text":"</> The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef method","title":"liquid.python.tags.transformer.TagTransformer.test"},{"location":"api/liquid.python.tags.tag_else/#liquidpythontagstransformertagtransformercomparison","text":"</> The rule comparison: expr (_comp_op expr)* method","title":"liquid.python.tags.transformer.TagTransformer.comparison"},{"location":"api/liquid.python.tags.tag_else/#liquidpythontagstransformertagtransformerterm","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.tag_else/#liquidpythontagstransformertagtransformerterm_1","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.tag_else/#liquidpythontagstransformertagtransformerterm_2","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.tag_else/#liquidpythontagstransformertagtransformerfactor","text":"</> The rule factor: _factor_op factor | power method","title":"liquid.python.tags.transformer.TagTransformer.factor"},{"location":"api/liquid.python.tags.tag_else/#liquidpythontagstransformertagtransformerpower","text":"</> The rule power: atom_expr (\"**\" factor)? method","title":"liquid.python.tags.transformer.TagTransformer.power"},{"location":"api/liquid.python.tags.tag_else/#liquidpythontagstransformertagtransformerdictmarker","text":"</> The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] method","title":"liquid.python.tags.transformer.TagTransformer.dictmarker"},{"location":"api/liquid.python.tags.tag_else/#liquidpythontagstransformertagtransformeratom_dict","text":"</> The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" method","title":"liquid.python.tags.transformer.TagTransformer.atom_dict"},{"location":"api/liquid.python.tags.tag_else/#liquidpythontagstransformertagtransformeratom_string","text":"</> The rule atom_string: string+ method","title":"liquid.python.tags.transformer.TagTransformer.atom_string"},{"location":"api/liquid.python.tags.tag_else/#liquidpythontagstag_elsetagelsetransformertag_else","text":"</> Get whatever passed by class","title":"liquid.python.tags.tag_else.TagElseTransformer.tag_else"},{"location":"api/liquid.python.tags.tag_else/#liquidpythontagstag_elsetagelse","text":"</> Bases liquid.python.tags.tag_if.TagIf liquid.tags.tag_if.TagIf liquid.tags.tag.Tag Tag else in python mode Allowed to be used with for, while and unless, too \"else if\" is also allowed here. Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Check to see if there is any siblings after a bare {% else %} tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag_else.TagElse"},{"location":"api/liquid.python.tags.tag_else/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag_else/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag_else/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag_else/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag_else/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag_else/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag_else/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag_else/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag_else/#liquidpythontagstag_elsetagelseparse","text":"</> Check to see if there is any siblings after a bare {% else %} tag","title":"liquid.python.tags.tag_else.TagElse.parse"},{"location":"api/liquid.python.tags.tag_for/","text":"module liquid.python.tags . tag_for </> More pythonic for tag for python mode of liquidpy Classes TagForTransformer \u2014 Transformer for tag for </> TagFor \u2014 The for tag </> class liquid.python.tags.tag_for . TagForTransformer ( visit_tokens=False ) </> Bases liquid.python.tags.transformer.TagTransformer liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable Transformer for tag for Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> atom_dict ( marker ) \u2014 The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" </> atom_string ( *strings ) \u2014 The rule atom_string: string+ </> comparison ( expr , *op_and_exprs ) \u2014 The rule comparison: expr (_comp_op expr)* </> dictmarker ( *tests ) \u2014 The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] </> factor ( factor_op_or_power , factor ) \u2014 The rule factor: _factor_op factor | power </> power ( atom_expr , factor ) \u2014 The rule power: atom_expr (\"**\" factor)? </> range ( token ) \u2014 Ranges </> tag_for ( varname , *args ) \u2014 Transformer for tag for </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> test ( value , cond , false_value ) \u2014 The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method transform ( tree ) </> Transform the given tree, and return the final result method __mul__ ( other ) </> Chain two transformers together, returning a new transformer. method __default__ ( data , children , meta ) </> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method __default_token__ ( token ) </> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method range ( token ) </> Ranges method varname ( vname ) </> Keep the token information for tracking method argvalue ( test1 , test2=NOTHING ) </> rule argvalue: test (\"=\" test)? method test ( value , cond=NOTHING , false_value=NOTHING ) </> The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef method comparison ( expr , *op_and_exprs ) </> The rule comparison: expr (_comp_op expr)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method factor ( factor_op_or_power , factor=NOTHING ) </> The rule factor: _factor_op factor | power method power ( atom_expr , factor=NOTHING ) </> The rule power: atom_expr (\"**\" factor)? method dictmarker ( *tests ) </> The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] method atom_dict ( marker=NOTHING ) </> The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" method atom_string ( *strings ) </> The rule atom_string: string+ method tag_for ( varname , *args ) </> Transformer for tag for class liquid.python.tags.tag_for . TagFor ( *args , **kwargs ) </> Bases liquid.python.tags.inherited.Tag liquid.tags.tag.Tag The for tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag cycles \u2014 The cycle object for cycle tags elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> flag_break \u2014 The flag for break statement flag_continue \u2014 The flag for continue statement name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.python.tags.tag_for"},{"location":"api/liquid.python.tags.tag_for/#liquidpythontagstag_for","text":"</> More pythonic for tag for python mode of liquidpy Classes TagForTransformer \u2014 Transformer for tag for </> TagFor \u2014 The for tag </> class","title":"liquid.python.tags.tag_for"},{"location":"api/liquid.python.tags.tag_for/#liquidpythontagstag_fortagfortransformer","text":"</> Bases liquid.python.tags.transformer.TagTransformer liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable Transformer for tag for Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> atom_dict ( marker ) \u2014 The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" </> atom_string ( *strings ) \u2014 The rule atom_string: string+ </> comparison ( expr , *op_and_exprs ) \u2014 The rule comparison: expr (_comp_op expr)* </> dictmarker ( *tests ) \u2014 The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] </> factor ( factor_op_or_power , factor ) \u2014 The rule factor: _factor_op factor | power </> power ( atom_expr , factor ) \u2014 The rule power: atom_expr (\"**\" factor)? </> range ( token ) \u2014 Ranges </> tag_for ( varname , *args ) \u2014 Transformer for tag for </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> test ( value , cond , false_value ) \u2014 The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method","title":"liquid.python.tags.tag_for.TagForTransformer"},{"location":"api/liquid.python.tags.tag_for/#larkvisitorstransformertransform","text":"</> Transform the given tree, and return the final result method","title":"lark.visitors.Transformer.transform"},{"location":"api/liquid.python.tags.tag_for/#larkvisitorstransformermul","text":"</> Chain two transformers together, returning a new transformer. method","title":"lark.visitors.Transformer.mul"},{"location":"api/liquid.python.tags.tag_for/#larkvisitorstransformerdefault","text":"</> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method","title":"lark.visitors.Transformer.default"},{"location":"api/liquid.python.tags.tag_for/#larkvisitorstransformerdefault_token","text":"</> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method","title":"lark.visitors.Transformer.default_token"},{"location":"api/liquid.python.tags.tag_for/#liquidtagstransformertagtransformerrange","text":"</> Ranges method","title":"liquid.tags.transformer.TagTransformer.range"},{"location":"api/liquid.python.tags.tag_for/#liquidtagstransformertagtransformervarname","text":"</> Keep the token information for tracking method","title":"liquid.tags.transformer.TagTransformer.varname"},{"location":"api/liquid.python.tags.tag_for/#liquidtagstransformertagtransformerargvalue","text":"</> rule argvalue: test (\"=\" test)? method","title":"liquid.tags.transformer.TagTransformer.argvalue"},{"location":"api/liquid.python.tags.tag_for/#liquidpythontagstransformertagtransformertest","text":"</> The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef method","title":"liquid.python.tags.transformer.TagTransformer.test"},{"location":"api/liquid.python.tags.tag_for/#liquidpythontagstransformertagtransformercomparison","text":"</> The rule comparison: expr (_comp_op expr)* method","title":"liquid.python.tags.transformer.TagTransformer.comparison"},{"location":"api/liquid.python.tags.tag_for/#liquidpythontagstransformertagtransformerterm","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.tag_for/#liquidpythontagstransformertagtransformerterm_1","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.tag_for/#liquidpythontagstransformertagtransformerterm_2","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.tag_for/#liquidpythontagstransformertagtransformerfactor","text":"</> The rule factor: _factor_op factor | power method","title":"liquid.python.tags.transformer.TagTransformer.factor"},{"location":"api/liquid.python.tags.tag_for/#liquidpythontagstransformertagtransformerpower","text":"</> The rule power: atom_expr (\"**\" factor)? method","title":"liquid.python.tags.transformer.TagTransformer.power"},{"location":"api/liquid.python.tags.tag_for/#liquidpythontagstransformertagtransformerdictmarker","text":"</> The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] method","title":"liquid.python.tags.transformer.TagTransformer.dictmarker"},{"location":"api/liquid.python.tags.tag_for/#liquidpythontagstransformertagtransformeratom_dict","text":"</> The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" method","title":"liquid.python.tags.transformer.TagTransformer.atom_dict"},{"location":"api/liquid.python.tags.tag_for/#liquidpythontagstransformertagtransformeratom_string","text":"</> The rule atom_string: string+ method","title":"liquid.python.tags.transformer.TagTransformer.atom_string"},{"location":"api/liquid.python.tags.tag_for/#liquidpythontagstag_fortagfortransformertag_for","text":"</> Transformer for tag for class","title":"liquid.python.tags.tag_for.TagForTransformer.tag_for"},{"location":"api/liquid.python.tags.tag_for/#liquidpythontagstag_fortagfor","text":"</> Bases liquid.python.tags.inherited.Tag liquid.tags.tag.Tag The for tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag cycles \u2014 The cycle object for cycle tags elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> flag_break \u2014 The flag for break statement flag_continue \u2014 The flag for continue statement name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag_for.TagFor"},{"location":"api/liquid.python.tags.tag_for/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag_for/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.python.tags.tag_for/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag_for/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag_for/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag_for/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag_for/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag_for/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag_for/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag_from/","text":"module liquid.python.tags . tag_from </> Tag from Classes TagFrom \u2014 Import submodules from python </> class liquid.python.tags.tag_from . TagFrom ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.python.tags.inherited.Tag liquid.tags.tag.Tag Import submodules from python Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.python.tags.tag_from"},{"location":"api/liquid.python.tags.tag_from/#liquidpythontagstag_from","text":"</> Tag from Classes TagFrom \u2014 Import submodules from python </> class","title":"liquid.python.tags.tag_from"},{"location":"api/liquid.python.tags.tag_from/#liquidpythontagstag_fromtagfrom","text":"</> Bases liquid.python.tags.inherited.Tag liquid.tags.tag.Tag Import submodules from python Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag_from.TagFrom"},{"location":"api/liquid.python.tags.tag_from/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag_from/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.python.tags.tag_from/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag_from/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag_from/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag_from/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag_from/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag_from/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag_from/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag_if/","text":"module liquid.python.tags . tag_if </> Tag if Classes TagIf \u2014 Tag if. </> class liquid.python.tags.tag_if . TagIf ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag_if.TagIf liquid.tags.tag.Tag Tag if. One can even do filters: {% if value | filter %} Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.python.tags.tag_if"},{"location":"api/liquid.python.tags.tag_if/#liquidpythontagstag_if","text":"</> Tag if Classes TagIf \u2014 Tag if. </> class","title":"liquid.python.tags.tag_if"},{"location":"api/liquid.python.tags.tag_if/#liquidpythontagstag_iftagif","text":"</> Bases liquid.tags.tag_if.TagIf liquid.tags.tag.Tag Tag if. One can even do filters: {% if value | filter %} Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag_if.TagIf"},{"location":"api/liquid.python.tags.tag_if/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag_if/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.python.tags.tag_if/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag_if/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag_if/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag_if/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag_if/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag_if/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag_if/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag_import/","text":"module liquid.python.tags . tag_import </> Tag import Classes TagImport \u2014 Tag import to import a module from python </> class liquid.python.tags.tag_import . TagImport ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.python.tags.inherited.Tag liquid.tags.tag.Tag Tag import to import a module from python Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.python.tags.tag_import"},{"location":"api/liquid.python.tags.tag_import/#liquidpythontagstag_import","text":"</> Tag import Classes TagImport \u2014 Tag import to import a module from python </> class","title":"liquid.python.tags.tag_import"},{"location":"api/liquid.python.tags.tag_import/#liquidpythontagstag_importtagimport","text":"</> Bases liquid.python.tags.inherited.Tag liquid.tags.tag.Tag Tag import to import a module from python Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag_import.TagImport"},{"location":"api/liquid.python.tags.tag_import/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag_import/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.python.tags.tag_import/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag_import/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag_import/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag_import/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag_import/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag_import/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag_import/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag_python/","text":"module liquid.python.tags . tag_python </> The python tag Classes TagPython \u2014 It can be either void or non-void </> class liquid.python.tags.tag_python . TagPython ( *args , **kwargs ) </> Bases liquid.python.tags.inherited.Tag liquid.tags.tag.Tag It can be either void or non-void {% python a = 1 %} {% python %} a = 1 b = 2 {% endpython %} Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.python.tags.tag_python"},{"location":"api/liquid.python.tags.tag_python/#liquidpythontagstag_python","text":"</> The python tag Classes TagPython \u2014 It can be either void or non-void </> class","title":"liquid.python.tags.tag_python"},{"location":"api/liquid.python.tags.tag_python/#liquidpythontagstag_pythontagpython","text":"</> Bases liquid.python.tags.inherited.Tag liquid.tags.tag.Tag It can be either void or non-void {% python a = 1 %} {% python %} a = 1 b = 2 {% endpython %} Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag_python.TagPython"},{"location":"api/liquid.python.tags.tag_python/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag_python/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.python.tags.tag_python/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag_python/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag_python/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag_python/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag_python/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag_python/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag_python/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag_unless/","text":"module liquid.python.tags . tag_unless </> Tag unless Classes TagUnless \u2014 Tag unless, with no emptydrop stuff </> class liquid.python.tags.tag_unless . TagUnless ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.python.tags.tag_if.TagIf liquid.tags.tag_if.TagIf liquid.tags.tag.Tag Tag unless, with no emptydrop stuff Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.python.tags.tag_unless"},{"location":"api/liquid.python.tags.tag_unless/#liquidpythontagstag_unless","text":"</> Tag unless Classes TagUnless \u2014 Tag unless, with no emptydrop stuff </> class","title":"liquid.python.tags.tag_unless"},{"location":"api/liquid.python.tags.tag_unless/#liquidpythontagstag_unlesstagunless","text":"</> Bases liquid.python.tags.tag_if.TagIf liquid.tags.tag_if.TagIf liquid.tags.tag.Tag Tag unless, with no emptydrop stuff Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag_unless.TagUnless"},{"location":"api/liquid.python.tags.tag_unless/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag_unless/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.python.tags.tag_unless/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag_unless/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag_unless/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag_unless/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag_unless/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag_unless/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag_unless/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.tag_while/","text":"module liquid.python.tags . tag_while </> Tag while Classes TagWhile \u2014 The for tag </> class liquid.python.tags.tag_while . TagWhile ( *args , **kwargs ) </> Bases liquid.python.tags.tag_if.TagIf liquid.tags.tag_if.TagIf liquid.tags.tag.Tag The for tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> flag_break \u2014 The flag for break statement flag_continue \u2014 The flag for continue statement name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.python.tags.tag_while"},{"location":"api/liquid.python.tags.tag_while/#liquidpythontagstag_while","text":"</> Tag while Classes TagWhile \u2014 The for tag </> class","title":"liquid.python.tags.tag_while"},{"location":"api/liquid.python.tags.tag_while/#liquidpythontagstag_whiletagwhile","text":"</> Bases liquid.python.tags.tag_if.TagIf liquid.tags.tag_if.TagIf liquid.tags.tag.Tag The for tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> flag_break \u2014 The flag for break statement flag_continue \u2014 The flag for continue statement name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.python.tags.tag_while.TagWhile"},{"location":"api/liquid.python.tags.tag_while/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.python.tags.tag_while/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.python.tags.tag_while/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.python.tags.tag_while/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.python.tags.tag_while/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.python.tags.tag_while/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.python.tags.tag_while/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.python.tags.tag_while/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.python.tags.tag_while/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.python.tags.transformer/","text":"module liquid.python.tags . transformer </> The segments and transformer for liquidpy in python mode Classes TagSegmentVar \u2014 Varaible segment in python mode. There will be no EmptyDrop object as rendered </> TagSegmentIfelse \u2014 The ternary operation in python: A if cond else B </> TagSegmentOr \u2014 Or statement in python </> TagSegmentAnd \u2014 And statement in python </> TagSegmentNot \u2014 Not statement in python </> TagSegmentGetAttr \u2014 Getattr operation in python </> TagSegmentGetItem \u2014 Getitem operation in python </> TagSegmentExpr \u2014 Expressions in python </> TagSegmentPower \u2014 Power expression in python </> TagSegmentFactor \u2014 Factor expression in python </> TagSegmentFuncCall \u2014 Function call in python </> TagSegmentTuple \u2014 Tuple literals in python </> TagSegmentList \u2014 List literals in python </> TagSegmentSet \u2014 Set literals in python </> TagSegmentDict \u2014 Dict literals in python </> TagSegmentSlice \u2014 Slice objects in python </> TagSegmentLambda \u2014 Lambda objects in python </> TagSegmentFilter \u2014 Filter segment </> TagTransformer \u2014 Transformer for python grammar </> class liquid.python.tags.transformer . TagSegmentVar ( *data ) </> Bases liquid.tags.transformer.TagSegmentVar liquid.tags.transformer.TagSegment Varaible segment in python mode. There will be no EmptyDrop object as rendered Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Get the value of a variable from envs </> method render ( local_vars , global_vars ) </> Get the value of a variable from envs class liquid.python.tags.transformer . TagSegmentIfelse ( *data ) </> Bases liquid.tags.transformer.TagSegment The ternary operation in python: A if cond else B Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Render the segment with the given envs </> method render ( local_vars , global_vars ) </> Render the segment with the given envs class liquid.python.tags.transformer . TagSegmentOr ( *data ) </> Bases liquid.tags.transformer.TagSegment Or statement in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagSegmentAnd ( *data ) </> Bases liquid.tags.transformer.TagSegment And statement in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagSegmentNot ( *data ) </> Bases liquid.tags.transformer.TagSegment Not statement in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagSegmentGetAttr ( *data ) </> Bases liquid.tags.transformer.TagSegment Getattr operation in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagSegmentGetItem ( *data ) </> Bases liquid.tags.transformer.TagSegment Getitem operation in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagSegmentExpr ( *data ) </> Bases liquid.tags.transformer.TagSegment Expressions in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagSegmentPower ( *data ) </> Bases liquid.tags.transformer.TagSegment Power expression in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagSegmentFactor ( *data ) </> Bases liquid.tags.transformer.TagSegment Factor expression in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagSegmentFuncCall ( *data ) </> Bases liquid.tags.transformer.TagSegment Function call in python We simplified the function call in python, no start arguments ( args) nor keyword arguments ( *kwargs) allowed. Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagSegmentTuple ( *data ) </> Bases liquid.tags.transformer.TagSegment Tuple literals in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagSegmentList ( *data ) </> Bases liquid.tags.transformer.TagSegment List literals in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagSegmentSet ( *data ) </> Bases liquid.tags.transformer.TagSegment Set literals in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagSegmentDict ( *data ) </> Bases liquid.tags.transformer.TagSegment Dict literals in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagSegmentSlice ( *data ) </> Bases liquid.tags.transformer.TagSegment Slice objects in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagSegmentLambda ( *data ) </> Bases liquid.tags.transformer.TagSegment Lambda objects in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagSegmentFilter ( *data ) </> Bases liquid.tags.transformer.TagSegment Filter segment Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method render ( local_vars , global_vars ) </> render the segment class liquid.python.tags.transformer . TagTransformer ( visit_tokens=False ) </> Bases liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable Transformer for python grammar Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> atom_dict ( marker ) \u2014 The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" </> atom_string ( *strings ) \u2014 The rule atom_string: string+ </> comparison ( expr , *op_and_exprs ) \u2014 The rule comparison: expr (_comp_op expr)* </> dictmarker ( *tests ) \u2014 The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] </> factor ( factor_op_or_power , factor ) \u2014 The rule factor: _factor_op factor | power </> power ( atom_expr , factor ) \u2014 The rule power: atom_expr (\"**\" factor)? </> range ( token ) \u2014 Ranges </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> test ( value , cond , false_value ) \u2014 The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method transform ( tree ) </> Transform the given tree, and return the final result method __mul__ ( other ) </> Chain two transformers together, returning a new transformer. method __default__ ( data , children , meta ) </> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method __default_token__ ( token ) </> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method range ( token ) </> Ranges method varname ( vname ) </> Keep the token information for tracking method argvalue ( test1 , test2=NOTHING ) </> rule argvalue: test (\"=\" test)? method test ( value , cond=NOTHING , false_value=NOTHING ) </> The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef method comparison ( expr , *op_and_exprs ) </> The rule comparison: expr (_comp_op expr)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method term ( one , *more ) </> The rule term: factor (_mul_op factor)* method factor ( factor_op_or_power , factor=NOTHING ) </> The rule factor: _factor_op factor | power method power ( atom_expr , factor=NOTHING ) </> The rule power: atom_expr (\"**\" factor)? method dictmarker ( *tests ) </> The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] method atom_dict ( marker=NOTHING ) </> The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" method atom_string ( *strings ) </> The rule atom_string: string+","title":"liquid.python.tags.transformer"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformer","text":"</> The segments and transformer for liquidpy in python mode Classes TagSegmentVar \u2014 Varaible segment in python mode. There will be no EmptyDrop object as rendered </> TagSegmentIfelse \u2014 The ternary operation in python: A if cond else B </> TagSegmentOr \u2014 Or statement in python </> TagSegmentAnd \u2014 And statement in python </> TagSegmentNot \u2014 Not statement in python </> TagSegmentGetAttr \u2014 Getattr operation in python </> TagSegmentGetItem \u2014 Getitem operation in python </> TagSegmentExpr \u2014 Expressions in python </> TagSegmentPower \u2014 Power expression in python </> TagSegmentFactor \u2014 Factor expression in python </> TagSegmentFuncCall \u2014 Function call in python </> TagSegmentTuple \u2014 Tuple literals in python </> TagSegmentList \u2014 List literals in python </> TagSegmentSet \u2014 Set literals in python </> TagSegmentDict \u2014 Dict literals in python </> TagSegmentSlice \u2014 Slice objects in python </> TagSegmentLambda \u2014 Lambda objects in python </> TagSegmentFilter \u2014 Filter segment </> TagTransformer \u2014 Transformer for python grammar </> class","title":"liquid.python.tags.transformer"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentvar","text":"</> Bases liquid.tags.transformer.TagSegmentVar liquid.tags.transformer.TagSegment Varaible segment in python mode. There will be no EmptyDrop object as rendered Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Get the value of a variable from envs </> method","title":"liquid.python.tags.transformer.TagSegmentVar"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentvarrender","text":"</> Get the value of a variable from envs class","title":"liquid.python.tags.transformer.TagSegmentVar.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentifelse","text":"</> Bases liquid.tags.transformer.TagSegment The ternary operation in python: A if cond else B Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Render the segment with the given envs </> method","title":"liquid.python.tags.transformer.TagSegmentIfelse"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentifelserender","text":"</> Render the segment with the given envs class","title":"liquid.python.tags.transformer.TagSegmentIfelse.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentor","text":"</> Bases liquid.tags.transformer.TagSegment Or statement in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentOr"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentorrender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentOr.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentand","text":"</> Bases liquid.tags.transformer.TagSegment And statement in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentAnd"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentandrender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentAnd.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentnot","text":"</> Bases liquid.tags.transformer.TagSegment Not statement in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentNot"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentnotrender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentNot.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentgetattr","text":"</> Bases liquid.tags.transformer.TagSegment Getattr operation in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentGetAttr"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentgetattrrender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentGetAttr.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentgetitem","text":"</> Bases liquid.tags.transformer.TagSegment Getitem operation in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentGetItem"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentgetitemrender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentGetItem.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentexpr","text":"</> Bases liquid.tags.transformer.TagSegment Expressions in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentExpr"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentexprrender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentExpr.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentpower","text":"</> Bases liquid.tags.transformer.TagSegment Power expression in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentPower"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentpowerrender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentPower.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentfactor","text":"</> Bases liquid.tags.transformer.TagSegment Factor expression in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentFactor"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentfactorrender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentFactor.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentfunccall","text":"</> Bases liquid.tags.transformer.TagSegment Function call in python We simplified the function call in python, no start arguments ( args) nor keyword arguments ( *kwargs) allowed. Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentFuncCall"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentfunccallrender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentFuncCall.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmenttuple","text":"</> Bases liquid.tags.transformer.TagSegment Tuple literals in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentTuple"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmenttuplerender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentTuple.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentlist","text":"</> Bases liquid.tags.transformer.TagSegment List literals in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentList"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentlistrender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentList.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentset","text":"</> Bases liquid.tags.transformer.TagSegment Set literals in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentSet"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentsetrender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentSet.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentdict","text":"</> Bases liquid.tags.transformer.TagSegment Dict literals in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentDict"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentdictrender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentDict.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentslice","text":"</> Bases liquid.tags.transformer.TagSegment Slice objects in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentSlice"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentslicerender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentSlice.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentlambda","text":"</> Bases liquid.tags.transformer.TagSegment Lambda objects in python Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentLambda"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentlambdarender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentLambda.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentfilter","text":"</> Bases liquid.tags.transformer.TagSegment Filter segment Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 render the segment </> method","title":"liquid.python.tags.transformer.TagSegmentFilter"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagsegmentfilterrender","text":"</> render the segment class","title":"liquid.python.tags.transformer.TagSegmentFilter.render"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagtransformer","text":"</> Bases liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable Transformer for python grammar Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> atom_dict ( marker ) \u2014 The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" </> atom_string ( *strings ) \u2014 The rule atom_string: string+ </> comparison ( expr , *op_and_exprs ) \u2014 The rule comparison: expr (_comp_op expr)* </> dictmarker ( *tests ) \u2014 The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] </> factor ( factor_op_or_power , factor ) \u2014 The rule factor: _factor_op factor | power </> power ( atom_expr , factor ) \u2014 The rule power: atom_expr (\"**\" factor)? </> range ( token ) \u2014 Ranges </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> term ( one , *more ) \u2014 The rule term: factor (_mul_op factor)* </> test ( value , cond , false_value ) \u2014 The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method","title":"liquid.python.tags.transformer.TagTransformer"},{"location":"api/liquid.python.tags.transformer/#larkvisitorstransformertransform","text":"</> Transform the given tree, and return the final result method","title":"lark.visitors.Transformer.transform"},{"location":"api/liquid.python.tags.transformer/#larkvisitorstransformermul","text":"</> Chain two transformers together, returning a new transformer. method","title":"lark.visitors.Transformer.mul"},{"location":"api/liquid.python.tags.transformer/#larkvisitorstransformerdefault","text":"</> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method","title":"lark.visitors.Transformer.default"},{"location":"api/liquid.python.tags.transformer/#larkvisitorstransformerdefault_token","text":"</> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method","title":"lark.visitors.Transformer.default_token"},{"location":"api/liquid.python.tags.transformer/#liquidtagstransformertagtransformerrange","text":"</> Ranges method","title":"liquid.tags.transformer.TagTransformer.range"},{"location":"api/liquid.python.tags.transformer/#liquidtagstransformertagtransformervarname","text":"</> Keep the token information for tracking method","title":"liquid.tags.transformer.TagTransformer.varname"},{"location":"api/liquid.python.tags.transformer/#liquidtagstransformertagtransformerargvalue","text":"</> rule argvalue: test (\"=\" test)? method","title":"liquid.tags.transformer.TagTransformer.argvalue"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagtransformertest","text":"</> The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef method","title":"liquid.python.tags.transformer.TagTransformer.test"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagtransformercomparison","text":"</> The rule comparison: expr (_comp_op expr)* method","title":"liquid.python.tags.transformer.TagTransformer.comparison"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagtransformerterm","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagtransformerterm_1","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagtransformerterm_2","text":"</> The rule term: factor (_mul_op factor)* method","title":"liquid.python.tags.transformer.TagTransformer.term"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagtransformerfactor","text":"</> The rule factor: _factor_op factor | power method","title":"liquid.python.tags.transformer.TagTransformer.factor"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagtransformerpower","text":"</> The rule power: atom_expr (\"**\" factor)? method","title":"liquid.python.tags.transformer.TagTransformer.power"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagtransformerdictmarker","text":"</> The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] method","title":"liquid.python.tags.transformer.TagTransformer.dictmarker"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagtransformeratom_dict","text":"</> The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" method","title":"liquid.python.tags.transformer.TagTransformer.atom_dict"},{"location":"api/liquid.python.tags.transformer/#liquidpythontagstransformertagtransformeratom_string","text":"</> The rule atom_string: string+","title":"liquid.python.tags.transformer.TagTransformer.atom_string"},{"location":"api/liquid.tags.grammar/","text":"module liquid.tags . grammar </> Grammar utilities for lark grammar. Here we opens opptunities to operate the grammar, including add, remove and update Classes Grammar \u2014 Manipulate lark grammar </> class liquid.tags.grammar . Grammar ( grammar ) </> Manipulate lark grammar Parameters grammar \u2014 The grammar. Could be a grammar string or a path to grammar file. Attributes grammar \u2014 The loaded grammar Methods __str__ ( ) \u2014 Dump the grammar for parser </> add ( rule_or_terminal , assignment , modifier ) \u2014 Add a new rule or terminal </> add_to ( rule , sub_rule ) \u2014 Add a sub-rule to a rule </> copy ( ) \u2014 Copy the grammar object </> replace ( rule_or_terminal , replacement ) \u2014 Replace a rule or a terminal with a replacement </> update ( other ) \u2014 Merge another grammar </> method copy ( ) </> Copy the grammar object method update ( other ) </> Merge another grammar Rule: - Existing rules will be extended in the way of rule: subrule -> rule: subrule | subrule2 - Non-existing rules/terminals will be added - Unimported statement will be added Parameters other \u2014 The other grammar method __str__ ( ) </> Dump the grammar for parser method replace ( rule_or_terminal , replacement ) </> Replace a rule or a terminal with a replacement Parameters rule_or_terminal \u2014 The rule or terminal name replacement \u2014 The replacement string for the rule or terminal method add_to ( rule , sub_rule ) </> Add a sub-rule to a rule The rule must be all alternatives (concatenated with \"|\") or an empty rule Parameters rule \u2014 The rule name sub_rule \u2014 The sub-rule method add ( rule_or_terminal , assignment , modifier=None ) </> Add a new rule or terminal Parameters assignment \u2014 The assignment for the rule or terminal modifier (optional) \u2014 The modifier for the rule or terminal rule_or_terminaL \u2014 The rule or terminal name","title":"liquid.tags.grammar"},{"location":"api/liquid.tags.grammar/#liquidtagsgrammar","text":"</> Grammar utilities for lark grammar. Here we opens opptunities to operate the grammar, including add, remove and update Classes Grammar \u2014 Manipulate lark grammar </> class","title":"liquid.tags.grammar"},{"location":"api/liquid.tags.grammar/#liquidtagsgrammargrammar","text":"</> Manipulate lark grammar Parameters grammar \u2014 The grammar. Could be a grammar string or a path to grammar file. Attributes grammar \u2014 The loaded grammar Methods __str__ ( ) \u2014 Dump the grammar for parser </> add ( rule_or_terminal , assignment , modifier ) \u2014 Add a new rule or terminal </> add_to ( rule , sub_rule ) \u2014 Add a sub-rule to a rule </> copy ( ) \u2014 Copy the grammar object </> replace ( rule_or_terminal , replacement ) \u2014 Replace a rule or a terminal with a replacement </> update ( other ) \u2014 Merge another grammar </> method","title":"liquid.tags.grammar.Grammar"},{"location":"api/liquid.tags.grammar/#liquidtagsgrammargrammarcopy","text":"</> Copy the grammar object method","title":"liquid.tags.grammar.Grammar.copy"},{"location":"api/liquid.tags.grammar/#liquidtagsgrammargrammarupdate","text":"</> Merge another grammar Rule: - Existing rules will be extended in the way of rule: subrule -> rule: subrule | subrule2 - Non-existing rules/terminals will be added - Unimported statement will be added Parameters other \u2014 The other grammar method","title":"liquid.tags.grammar.Grammar.update"},{"location":"api/liquid.tags.grammar/#liquidtagsgrammargrammarstr","text":"</> Dump the grammar for parser method","title":"liquid.tags.grammar.Grammar.str"},{"location":"api/liquid.tags.grammar/#liquidtagsgrammargrammarreplace","text":"</> Replace a rule or a terminal with a replacement Parameters rule_or_terminal \u2014 The rule or terminal name replacement \u2014 The replacement string for the rule or terminal method","title":"liquid.tags.grammar.Grammar.replace"},{"location":"api/liquid.tags.grammar/#liquidtagsgrammargrammaradd_to","text":"</> Add a sub-rule to a rule The rule must be all alternatives (concatenated with \"|\") or an empty rule Parameters rule \u2014 The rule name sub_rule \u2014 The sub-rule method","title":"liquid.tags.grammar.Grammar.add_to"},{"location":"api/liquid.tags.grammar/#liquidtagsgrammargrammaradd","text":"</> Add a new rule or terminal Parameters assignment \u2014 The assignment for the rule or terminal modifier (optional) \u2014 The modifier for the rule or terminal rule_or_terminaL \u2014 The rule or terminal name","title":"liquid.tags.grammar.Grammar.add"},{"location":"api/liquid.tags.manager/","text":"module liquid.tags . manager </> The tag manager Attributes tag_manager \u2014 The tag manager Classes TagManager \u2014 The tag manager </> class liquid.tags.manager . TagManager ( *args , **kwargs ) </> Bases liquid.utils.Singleton The tag manager Attributes INSTANCE \u2014 The instance of this singleton class tags \u2014 The tags database Methods get ( name ) \u2014 Get the tag class </> register ( tag_class_or_alias , mode ) \u2014 Register a tag </> unregister ( tagname , mode ) \u2014 Unregister a tag </> method register ( tag_class_or_alias=None , mode='standard' ) </> Register a tag This can be worked as a decorator Parameters tag_class_or_alias (optional) \u2014 The tag class or the alias for the tag class to decorate mode (optional) \u2014 Whether do it for given mode Returns The decorator or the decorated class method unregister ( tagname , mode='standard' ) </> Unregister a tag Parameters tagname \u2014 The name of the tag to unregister mode (optional) \u2014 Whether do it for given mode Returns The tag class unregistered. It can be used to be re-registered method get ( name ) </> Get the tag class Parameters name \u2014 The name of the tag Returns The tag class or None if name does not exist","title":"liquid.tags.manager"},{"location":"api/liquid.tags.manager/#liquidtagsmanager","text":"</> The tag manager Attributes tag_manager \u2014 The tag manager Classes TagManager \u2014 The tag manager </> class","title":"liquid.tags.manager"},{"location":"api/liquid.tags.manager/#liquidtagsmanagertagmanager","text":"</> Bases liquid.utils.Singleton The tag manager Attributes INSTANCE \u2014 The instance of this singleton class tags \u2014 The tags database Methods get ( name ) \u2014 Get the tag class </> register ( tag_class_or_alias , mode ) \u2014 Register a tag </> unregister ( tagname , mode ) \u2014 Unregister a tag </> method","title":"liquid.tags.manager.TagManager"},{"location":"api/liquid.tags.manager/#liquidtagsmanagertagmanagerregister","text":"</> Register a tag This can be worked as a decorator Parameters tag_class_or_alias (optional) \u2014 The tag class or the alias for the tag class to decorate mode (optional) \u2014 Whether do it for given mode Returns The decorator or the decorated class method","title":"liquid.tags.manager.TagManager.register"},{"location":"api/liquid.tags.manager/#liquidtagsmanagertagmanagerunregister","text":"</> Unregister a tag Parameters tagname \u2014 The name of the tag to unregister mode (optional) \u2014 Whether do it for given mode Returns The tag class unregistered. It can be used to be re-registered method","title":"liquid.tags.manager.TagManager.unregister"},{"location":"api/liquid.tags.manager/#liquidtagsmanagertagmanagerget","text":"</> Get the tag class Parameters name \u2014 The name of the tag Returns The tag class or None if name does not exist","title":"liquid.tags.manager.TagManager.get"},{"location":"api/liquid.tags/","text":"package liquid . tags </> All stuff about liquidpy tags module liquid.tags . tag_when </> Tag when (in case) {% assign handle = \"cake\" %} {% case handle %} {% when \"cake\" %} This is a cake {% when \"cookie\" %} This is a cookie {% else %} This is not a cake nor a cookie {% endcase %} Classes TagWhen \u2014 The when tag </> module liquid.tags . tag_extends </> Tag extends {% extends ... %} Classes TagExtends \u2014 The extends tag </> module liquid.tags . tag_increment </> Tag increment {% increment my_counter %} {% increment my_counter %} {% increment my_counter %} Classes TagIncrement \u2014 The increment tag </> module liquid.tags . tag_comment </> Tag comment {% comment %} ... {% endcomment %} Classes TagComment \u2014 The comment tag </> module liquid.tags . tag_block </> Tag block {% block block 1 %} ... {% endblock %} Classes TagBlock \u2014 The block tag </> module liquid.tags . tag_else </> Else tag in following situations // in if {% if ... %} ... [ {% elsif ... %} ] ... {% else %} ... {% endif %} // in case / when {% case x %} {% when ... %} ... {% when ... %} ... {% else %} ... {% endcase %} // in for {% for ... %} ... {% else %} ... {% endfor %} Classes TagElse \u2014 Class for tag else </> module liquid.tags . tag_elsif </> Elsif tag {% if ... %} ... {% elsif ... %} ... [ {% else %} ] ... {% endif %} Classes TagElsif \u2014 Class for tag elsif </> module liquid.tags . tag__literal </> The literal tag Classes TagLITERAL \u2014 The literal tag </> module liquid.tags . tag__end </> The end tag {% endxxx %} Classes TagEND \u2014 End tag: '{% endxxx %}' </> module liquid.tags . tag_break </> The break tag {% for ... %} {% break %} {% endfor %} Classes TagBreak \u2014 Class for tag break </> module liquid.tags . tag_continue </> The continue tag {% for ... %} {% continue %} {% endfor %} Classes TagContinue \u2014 Class for tag continue </> module liquid.tags . tag_include </> Tag include {% include ... %} Classes TagIncludeTransformer \u2014 The transformer for tag include </> TagInclude \u2014 The extends tag </> module liquid.tags . tag_raw </> Tag raw {% raw %} ... {% endraw %} Classes TagRaw \u2014 The raw tag </> module liquid.tags . tag__root </> The root tag Classes TagROOT \u2014 The root tag as a container of all child tags </> module liquid.tags . tag_capture </> Tag capture {% capture my_variable %} I am being captured. {% endcapture %} Classes TagCapture \u2014 The capture tag </> module liquid.tags . tag_unless </> Tag unless {% unless condition %} ... {% endunless %} Classes TagUnless \u2014 The unless tag </> module liquid.tags . tag_cycle </> Tag cycle {% for <loop> <args> %} ... {% cycle \"one\" , \"two\" , \"three\" %} ... {% endfor %} Classes TagCycleTransformer \u2014 The transformer for tag cycle </> TagCycle \u2014 The cycle tag </> module liquid.tags . tag_if </> Tag if {% if condition %} ... {% endif %} Classes TagIf \u2014 Tag if </> module liquid.tags . tag_case </> Tag case {% assign handle = \"cake\" %} {% case handle %} {% when \"cake\" %} This is a cake {% when \"cookie\" %} This is a cookie {% else %} This is not a cake nor a cookie {% endcase %} Classes TagCase \u2014 The case class </> module liquid.tags . tag_for </> Tag for {% for <loop> <args> %} ... {% endfor %} Classes ForLoop \u2014 ForLoop(first, index, index0, last, length, rindex, rindex0) </> TagForTransformer \u2014 The transformer for tag for </> TagFor \u2014 The for tag </> module liquid.tags . tag_assign </> Tag assign {% assign x = 1 %} {% assign x = x | plus : 1 %} Classes TagAssignTransformer \u2014 The transformer for tag assign </> TagAssign \u2014 The assign tag </> module liquid.tags . tag_decrement </> Tag decrement {% decrement my_counter %} {% decrement my_counter %} {% decrement my_counter %} Classes TagDecrement \u2014 The decrement tag' </> module liquid.tags . tag_config </> Tag config {% config %} Classes TagConfigTransformer \u2014 The transformer for tag config </> TagConfig \u2014 The config tag </> module liquid.tags . transformer </> The transformer for tag segments Classes TagSegment ( *data ) \u2014 Base class for segment classes </> TagSegmentVar \u2014 segment for variables </> TagSegmentComparison \u2014 Comparison segment </> TagSegmentGetItem \u2014 segment for obj[subscript] </> TagSegmentGetAttr \u2014 segment for obj.attr </> TagSegmentRange \u2014 segment for range </> TagSegmentOutput \u2014 Output inside {{ ... }} </> TagSegmentArguments \u2014 Arguments segment </> TagSegmentLogical \u2014 Logical segment </> TagSegmentFilter \u2014 Filter segment </> TagTransformer \u2014 Transform tag segments </> Functions render_segment ( tagseg , local_vars , global_vars ) \u2014 Try to render a segment </> module liquid.tags . tag_tablerow </> Tag tabrow <table> {% tablerow product in collection.products %} {{ product . title }} {% endtablerow %} </table> Classes TablerowObject \u2014 TablerowObject(itername, obj, limit, offset, cols) </> TagTablerowTransformer \u2014 The transformer for tablerow tag </> TagTablerow \u2014 The tablerow tag </> module liquid.tags . manager </> The tag manager Attributes tag_manager \u2014 The tag manager Classes TagManager \u2014 The tag manager </> module liquid.tags . tag__output </> The output tag {{ ... }} Classes TagOUTPUT \u2014 The output tag </> module liquid.tags . tag </> Basics for all tags Classes Tag \u2014 The base class for all tags. </> module liquid.tags . grammar </> Grammar utilities for lark grammar. Here we opens opptunities to operate the grammar, including add, remove and update Classes Grammar \u2014 Manipulate lark grammar </>","title":"liquid.tags"},{"location":"api/liquid.tags/#liquidtags","text":"</> All stuff about liquidpy tags module","title":"liquid.tags"},{"location":"api/liquid.tags/#liquidtagstag_when","text":"</> Tag when (in case) {% assign handle = \"cake\" %} {% case handle %} {% when \"cake\" %} This is a cake {% when \"cookie\" %} This is a cookie {% else %} This is not a cake nor a cookie {% endcase %} Classes TagWhen \u2014 The when tag </> module","title":"liquid.tags.tag_when"},{"location":"api/liquid.tags/#liquidtagstag_extends","text":"</> Tag extends {% extends ... %} Classes TagExtends \u2014 The extends tag </> module","title":"liquid.tags.tag_extends"},{"location":"api/liquid.tags/#liquidtagstag_increment","text":"</> Tag increment {% increment my_counter %} {% increment my_counter %} {% increment my_counter %} Classes TagIncrement \u2014 The increment tag </> module","title":"liquid.tags.tag_increment"},{"location":"api/liquid.tags/#liquidtagstag_comment","text":"</> Tag comment {% comment %} ... {% endcomment %} Classes TagComment \u2014 The comment tag </> module","title":"liquid.tags.tag_comment"},{"location":"api/liquid.tags/#liquidtagstag_block","text":"</> Tag block {% block block 1 %} ... {% endblock %} Classes TagBlock \u2014 The block tag </> module","title":"liquid.tags.tag_block"},{"location":"api/liquid.tags/#liquidtagstag_else","text":"</> Else tag in following situations // in if {% if ... %} ... [ {% elsif ... %} ] ... {% else %} ... {% endif %} // in case / when {% case x %} {% when ... %} ... {% when ... %} ... {% else %} ... {% endcase %} // in for {% for ... %} ... {% else %} ... {% endfor %} Classes TagElse \u2014 Class for tag else </> module","title":"liquid.tags.tag_else"},{"location":"api/liquid.tags/#liquidtagstag_elsif","text":"</> Elsif tag {% if ... %} ... {% elsif ... %} ... [ {% else %} ] ... {% endif %} Classes TagElsif \u2014 Class for tag elsif </> module","title":"liquid.tags.tag_elsif"},{"location":"api/liquid.tags/#liquidtagstag__literal","text":"</> The literal tag Classes TagLITERAL \u2014 The literal tag </> module","title":"liquid.tags.tag__literal"},{"location":"api/liquid.tags/#liquidtagstag__end","text":"</> The end tag {% endxxx %} Classes TagEND \u2014 End tag: '{% endxxx %}' </> module","title":"liquid.tags.tag__end"},{"location":"api/liquid.tags/#liquidtagstag_break","text":"</> The break tag {% for ... %} {% break %} {% endfor %} Classes TagBreak \u2014 Class for tag break </> module","title":"liquid.tags.tag_break"},{"location":"api/liquid.tags/#liquidtagstag_continue","text":"</> The continue tag {% for ... %} {% continue %} {% endfor %} Classes TagContinue \u2014 Class for tag continue </> module","title":"liquid.tags.tag_continue"},{"location":"api/liquid.tags/#liquidtagstag_include","text":"</> Tag include {% include ... %} Classes TagIncludeTransformer \u2014 The transformer for tag include </> TagInclude \u2014 The extends tag </> module","title":"liquid.tags.tag_include"},{"location":"api/liquid.tags/#liquidtagstag_raw","text":"</> Tag raw {% raw %} ... {% endraw %} Classes TagRaw \u2014 The raw tag </> module","title":"liquid.tags.tag_raw"},{"location":"api/liquid.tags/#liquidtagstag__root","text":"</> The root tag Classes TagROOT \u2014 The root tag as a container of all child tags </> module","title":"liquid.tags.tag__root"},{"location":"api/liquid.tags/#liquidtagstag_capture","text":"</> Tag capture {% capture my_variable %} I am being captured. {% endcapture %} Classes TagCapture \u2014 The capture tag </> module","title":"liquid.tags.tag_capture"},{"location":"api/liquid.tags/#liquidtagstag_unless","text":"</> Tag unless {% unless condition %} ... {% endunless %} Classes TagUnless \u2014 The unless tag </> module","title":"liquid.tags.tag_unless"},{"location":"api/liquid.tags/#liquidtagstag_cycle","text":"</> Tag cycle {% for <loop> <args> %} ... {% cycle \"one\" , \"two\" , \"three\" %} ... {% endfor %} Classes TagCycleTransformer \u2014 The transformer for tag cycle </> TagCycle \u2014 The cycle tag </> module","title":"liquid.tags.tag_cycle"},{"location":"api/liquid.tags/#liquidtagstag_if","text":"</> Tag if {% if condition %} ... {% endif %} Classes TagIf \u2014 Tag if </> module","title":"liquid.tags.tag_if"},{"location":"api/liquid.tags/#liquidtagstag_case","text":"</> Tag case {% assign handle = \"cake\" %} {% case handle %} {% when \"cake\" %} This is a cake {% when \"cookie\" %} This is a cookie {% else %} This is not a cake nor a cookie {% endcase %} Classes TagCase \u2014 The case class </> module","title":"liquid.tags.tag_case"},{"location":"api/liquid.tags/#liquidtagstag_for","text":"</> Tag for {% for <loop> <args> %} ... {% endfor %} Classes ForLoop \u2014 ForLoop(first, index, index0, last, length, rindex, rindex0) </> TagForTransformer \u2014 The transformer for tag for </> TagFor \u2014 The for tag </> module","title":"liquid.tags.tag_for"},{"location":"api/liquid.tags/#liquidtagstag_assign","text":"</> Tag assign {% assign x = 1 %} {% assign x = x | plus : 1 %} Classes TagAssignTransformer \u2014 The transformer for tag assign </> TagAssign \u2014 The assign tag </> module","title":"liquid.tags.tag_assign"},{"location":"api/liquid.tags/#liquidtagstag_decrement","text":"</> Tag decrement {% decrement my_counter %} {% decrement my_counter %} {% decrement my_counter %} Classes TagDecrement \u2014 The decrement tag' </> module","title":"liquid.tags.tag_decrement"},{"location":"api/liquid.tags/#liquidtagstag_config","text":"</> Tag config {% config %} Classes TagConfigTransformer \u2014 The transformer for tag config </> TagConfig \u2014 The config tag </> module","title":"liquid.tags.tag_config"},{"location":"api/liquid.tags/#liquidtagstransformer","text":"</> The transformer for tag segments Classes TagSegment ( *data ) \u2014 Base class for segment classes </> TagSegmentVar \u2014 segment for variables </> TagSegmentComparison \u2014 Comparison segment </> TagSegmentGetItem \u2014 segment for obj[subscript] </> TagSegmentGetAttr \u2014 segment for obj.attr </> TagSegmentRange \u2014 segment for range </> TagSegmentOutput \u2014 Output inside {{ ... }} </> TagSegmentArguments \u2014 Arguments segment </> TagSegmentLogical \u2014 Logical segment </> TagSegmentFilter \u2014 Filter segment </> TagTransformer \u2014 Transform tag segments </> Functions render_segment ( tagseg , local_vars , global_vars ) \u2014 Try to render a segment </> module","title":"liquid.tags.transformer"},{"location":"api/liquid.tags/#liquidtagstag_tablerow","text":"</> Tag tabrow <table> {% tablerow product in collection.products %} {{ product . title }} {% endtablerow %} </table> Classes TablerowObject \u2014 TablerowObject(itername, obj, limit, offset, cols) </> TagTablerowTransformer \u2014 The transformer for tablerow tag </> TagTablerow \u2014 The tablerow tag </> module","title":"liquid.tags.tag_tablerow"},{"location":"api/liquid.tags/#liquidtagsmanager","text":"</> The tag manager Attributes tag_manager \u2014 The tag manager Classes TagManager \u2014 The tag manager </> module","title":"liquid.tags.manager"},{"location":"api/liquid.tags/#liquidtagstag__output","text":"</> The output tag {{ ... }} Classes TagOUTPUT \u2014 The output tag </> module","title":"liquid.tags.tag__output"},{"location":"api/liquid.tags/#liquidtagstag","text":"</> Basics for all tags Classes Tag \u2014 The base class for all tags. </> module","title":"liquid.tags.tag"},{"location":"api/liquid.tags/#liquidtagsgrammar","text":"</> Grammar utilities for lark grammar. Here we opens opptunities to operate the grammar, including add, remove and update Classes Grammar \u2014 Manipulate lark grammar </>","title":"liquid.tags.grammar"},{"location":"api/liquid.tags.tag/","text":"module liquid.tags . tag </> Basics for all tags Classes Tag \u2014 The base class for all tags. </> class liquid.tags.tag . Tag ( hitname , content , context , open_compact , close_compact , parser ) </> The base class for all tags. Subclass should provide start , grammar , transformer , base_grammar via __init_subclass__ to initialize a PARSER for the tag. If start is None, meaning no parser needed for this tag. Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag"},{"location":"api/liquid.tags.tag/#liquidtagstag","text":"</> Basics for all tags Classes Tag \u2014 The base class for all tags. </> class","title":"liquid.tags.tag"},{"location":"api/liquid.tags.tag/#liquidtagstagtag","text":"</> The base class for all tags. Subclass should provide start , grammar , transformer , base_grammar via __init_subclass__ to initialize a PARSER for the tag. If start is None, meaning no parser needed for this tag. Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag.Tag"},{"location":"api/liquid.tags.tag/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag__end/","text":"module liquid.tags . tag__end </> The end tag {% endxxx %} Classes TagEND \u2014 End tag: '{% endxxx %}' </> class liquid.tags.tag__end . TagEND ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag.Tag End tag: '{% endxxx %}' Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag__end"},{"location":"api/liquid.tags.tag__end/#liquidtagstag__end","text":"</> The end tag {% endxxx %} Classes TagEND \u2014 End tag: '{% endxxx %}' </> class","title":"liquid.tags.tag__end"},{"location":"api/liquid.tags.tag__end/#liquidtagstag__endtagend","text":"</> Bases liquid.tags.tag.Tag End tag: '{% endxxx %}' Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag__end.TagEND"},{"location":"api/liquid.tags.tag__end/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag__end/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag__end/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag__end/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag__end/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag__end/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag__end/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag__end/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag__end/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag__literal/","text":"module liquid.tags . tag__literal </> The literal tag Classes TagLITERAL \u2014 The literal tag </> class liquid.tags.tag__literal . TagLITERAL ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag.Tag The literal tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the literals </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the literals Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it","title":"liquid.tags.tag__literal"},{"location":"api/liquid.tags.tag__literal/#liquidtagstag__literal","text":"</> The literal tag Classes TagLITERAL \u2014 The literal tag </> class","title":"liquid.tags.tag__literal"},{"location":"api/liquid.tags.tag__literal/#liquidtagstag__literaltagliteral","text":"</> Bases liquid.tags.tag.Tag The literal tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the literals </> classmethod","title":"liquid.tags.tag__literal.TagLITERAL"},{"location":"api/liquid.tags.tag__literal/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag__literal/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag__literal/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag__literal/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag__literal/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag__literal/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag__literal/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag__literal/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag__literal/#liquidtagstag__literaltagliteralrender","text":"</> Render the literals Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it","title":"liquid.tags.tag__literal.TagLITERAL.render"},{"location":"api/liquid.tags.tag__output/","text":"module liquid.tags . tag__output </> The output tag {{ ... }} Classes TagOUTPUT \u2014 The output tag </> class liquid.tags.tag__output . TagOUTPUT ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag.Tag The output tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag__output"},{"location":"api/liquid.tags.tag__output/#liquidtagstag__output","text":"</> The output tag {{ ... }} Classes TagOUTPUT \u2014 The output tag </> class","title":"liquid.tags.tag__output"},{"location":"api/liquid.tags.tag__output/#liquidtagstag__outputtagoutput","text":"</> Bases liquid.tags.tag.Tag The output tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag__output.TagOUTPUT"},{"location":"api/liquid.tags.tag__output/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag__output/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag__output/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag__output/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag__output/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag__output/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag__output/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag__output/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag__output/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag__root/","text":"module liquid.tags . tag__root </> The root tag Classes TagROOT \u2014 The root tag as a container of all child tags </> class liquid.tags.tag__root . TagROOT ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag.Tag The root tag as a container of all child tags Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Exclude block tags from parsing, until they are replaced </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the children of root </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method parse ( force=False ) </> Exclude block tags from parsing, until they are replaced method render ( local_vars , global_vars , from_elder=False ) </> Render the children of root Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it","title":"liquid.tags.tag__root"},{"location":"api/liquid.tags.tag__root/#liquidtagstag__root","text":"</> The root tag Classes TagROOT \u2014 The root tag as a container of all child tags </> class","title":"liquid.tags.tag__root"},{"location":"api/liquid.tags.tag__root/#liquidtagstag__roottagroot","text":"</> Bases liquid.tags.tag.Tag The root tag as a container of all child tags Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Exclude block tags from parsing, until they are replaced </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the children of root </> classmethod","title":"liquid.tags.tag__root.TagROOT"},{"location":"api/liquid.tags.tag__root/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag__root/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag__root/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag__root/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag__root/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag__root/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag__root/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag__root/#liquidtagstag__roottagrootparse","text":"</> Exclude block tags from parsing, until they are replaced method","title":"liquid.tags.tag__root.TagROOT.parse"},{"location":"api/liquid.tags.tag__root/#liquidtagstag__roottagrootrender","text":"</> Render the children of root Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it","title":"liquid.tags.tag__root.TagROOT.render"},{"location":"api/liquid.tags.tag_assign/","text":"module liquid.tags . tag_assign </> Tag assign {% assign x = 1 %} {% assign x = x | plus : 1 %} Classes TagAssignTransformer \u2014 The transformer for tag assign </> TagAssign \u2014 The assign tag </> class liquid.tags.tag_assign . TagAssignTransformer ( visit_tokens=False ) </> Bases liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag assign Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> comparison ( expr , op , expr2 ) \u2014 rule comparison: comparison: atom (_comp_op atom)? </> range ( token ) \u2014 Ranges </> tag_assign ( varname , output ) \u2014 Transform the tag_assign rule </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method transform ( tree ) </> Transform the given tree, and return the final result method __mul__ ( other ) </> Chain two transformers together, returning a new transformer. method __default__ ( data , children , meta ) </> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method __default_token__ ( token ) </> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method range ( token ) </> Ranges method comparison ( expr , op=None , expr2=None ) </> rule comparison: comparison: atom (_comp_op atom)? method varname ( vname ) </> Keep the token information for tracking method argvalue ( test1 , test2=NOTHING ) </> rule argvalue: test (\"=\" test)? method tag_assign ( varname , output ) </> Transform the tag_assign rule class liquid.tags.tag_assign . TagAssign ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag.Tag The assign tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag_assign"},{"location":"api/liquid.tags.tag_assign/#liquidtagstag_assign","text":"</> Tag assign {% assign x = 1 %} {% assign x = x | plus : 1 %} Classes TagAssignTransformer \u2014 The transformer for tag assign </> TagAssign \u2014 The assign tag </> class","title":"liquid.tags.tag_assign"},{"location":"api/liquid.tags.tag_assign/#liquidtagstag_assigntagassigntransformer","text":"</> Bases liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag assign Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> comparison ( expr , op , expr2 ) \u2014 rule comparison: comparison: atom (_comp_op atom)? </> range ( token ) \u2014 Ranges </> tag_assign ( varname , output ) \u2014 Transform the tag_assign rule </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method","title":"liquid.tags.tag_assign.TagAssignTransformer"},{"location":"api/liquid.tags.tag_assign/#larkvisitorstransformertransform","text":"</> Transform the given tree, and return the final result method","title":"lark.visitors.Transformer.transform"},{"location":"api/liquid.tags.tag_assign/#larkvisitorstransformermul","text":"</> Chain two transformers together, returning a new transformer. method","title":"lark.visitors.Transformer.mul"},{"location":"api/liquid.tags.tag_assign/#larkvisitorstransformerdefault","text":"</> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method","title":"lark.visitors.Transformer.default"},{"location":"api/liquid.tags.tag_assign/#larkvisitorstransformerdefault_token","text":"</> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method","title":"lark.visitors.Transformer.default_token"},{"location":"api/liquid.tags.tag_assign/#liquidtagstransformertagtransformerrange","text":"</> Ranges method","title":"liquid.tags.transformer.TagTransformer.range"},{"location":"api/liquid.tags.tag_assign/#liquidtagstransformertagtransformercomparison","text":"</> rule comparison: comparison: atom (_comp_op atom)? method","title":"liquid.tags.transformer.TagTransformer.comparison"},{"location":"api/liquid.tags.tag_assign/#liquidtagstransformertagtransformervarname","text":"</> Keep the token information for tracking method","title":"liquid.tags.transformer.TagTransformer.varname"},{"location":"api/liquid.tags.tag_assign/#liquidtagstransformertagtransformerargvalue","text":"</> rule argvalue: test (\"=\" test)? method","title":"liquid.tags.transformer.TagTransformer.argvalue"},{"location":"api/liquid.tags.tag_assign/#liquidtagstag_assigntagassigntransformertag_assign","text":"</> Transform the tag_assign rule class","title":"liquid.tags.tag_assign.TagAssignTransformer.tag_assign"},{"location":"api/liquid.tags.tag_assign/#liquidtagstag_assigntagassign","text":"</> Bases liquid.tags.tag.Tag The assign tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_assign.TagAssign"},{"location":"api/liquid.tags.tag_assign/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_assign/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag_assign/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_assign/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_assign/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_assign/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_assign/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_assign/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_assign/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_block/","text":"module liquid.tags . tag_block </> Tag block {% block block 1 %} ... {% endblock %} Classes TagBlock \u2014 The block tag </> class liquid.tags.tag_block . TagBlock ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag_capture.TagCapture liquid.tags.tag.Tag The block tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method __repr__ ( ) </> The representation of the tag","title":"liquid.tags.tag_block"},{"location":"api/liquid.tags.tag_block/#liquidtagstag_block","text":"</> Tag block {% block block 1 %} ... {% endblock %} Classes TagBlock \u2014 The block tag </> class","title":"liquid.tags.tag_block"},{"location":"api/liquid.tags.tag_block/#liquidtagstag_blocktagblock","text":"</> Bases liquid.tags.tag_capture.TagCapture liquid.tags.tag.Tag The block tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_block.TagBlock"},{"location":"api/liquid.tags.tag_block/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_block/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag_block/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_block/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_block/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_block/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_block/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_block/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_block/#liquidtagstag_blocktagblockrepr","text":"</> The representation of the tag","title":"liquid.tags.tag_block.TagBlock.repr"},{"location":"api/liquid.tags.tag_break/","text":"module liquid.tags . tag_break </> The break tag {% for ... %} {% break %} {% endfor %} Classes TagBreak \u2014 Class for tag break </> class liquid.tags.tag_break . TagBreak ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag.Tag Class for tag break Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Make sure no extra content for this tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method parse ( force=False ) </> Make sure no extra content for this tag","title":"liquid.tags.tag_break"},{"location":"api/liquid.tags.tag_break/#liquidtagstag_break","text":"</> The break tag {% for ... %} {% break %} {% endfor %} Classes TagBreak \u2014 Class for tag break </> class","title":"liquid.tags.tag_break"},{"location":"api/liquid.tags.tag_break/#liquidtagstag_breaktagbreak","text":"</> Bases liquid.tags.tag.Tag Class for tag break Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Make sure no extra content for this tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_break.TagBreak"},{"location":"api/liquid.tags.tag_break/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_break/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_break/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_break/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_break/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_break/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_break/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_break/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_break/#liquidtagstag_breaktagbreakparse","text":"</> Make sure no extra content for this tag","title":"liquid.tags.tag_break.TagBreak.parse"},{"location":"api/liquid.tags.tag_capture/","text":"module liquid.tags . tag_capture </> Tag capture {% capture my_variable %} I am being captured. {% endcapture %} Classes TagCapture \u2014 The capture tag </> class liquid.tags.tag_capture . TagCapture ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag.Tag The capture tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag_capture"},{"location":"api/liquid.tags.tag_capture/#liquidtagstag_capture","text":"</> Tag capture {% capture my_variable %} I am being captured. {% endcapture %} Classes TagCapture \u2014 The capture tag </> class","title":"liquid.tags.tag_capture"},{"location":"api/liquid.tags.tag_capture/#liquidtagstag_capturetagcapture","text":"</> Bases liquid.tags.tag.Tag The capture tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_capture.TagCapture"},{"location":"api/liquid.tags.tag_capture/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_capture/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag_capture/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_capture/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_capture/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_capture/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_capture/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_capture/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_capture/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_case/","text":"module liquid.tags . tag_case </> Tag case {% assign handle = \"cake\" %} {% case handle %} {% when \"cake\" %} This is a cake {% when \"cookie\" %} This is a cookie {% else %} This is not a cake nor a cookie {% endcase %} Classes TagCase \u2014 The case class </> class liquid.tags.tag_case . TagCase ( *args , **kwargs ) </> Bases liquid.tags.tag__output.TagOUTPUT liquid.tags.tag.Tag The case class Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag_case"},{"location":"api/liquid.tags.tag_case/#liquidtagstag_case","text":"</> Tag case {% assign handle = \"cake\" %} {% case handle %} {% when \"cake\" %} This is a cake {% when \"cookie\" %} This is a cookie {% else %} This is not a cake nor a cookie {% endcase %} Classes TagCase \u2014 The case class </> class","title":"liquid.tags.tag_case"},{"location":"api/liquid.tags.tag_case/#liquidtagstag_casetagcase","text":"</> Bases liquid.tags.tag__output.TagOUTPUT liquid.tags.tag.Tag The case class Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_case.TagCase"},{"location":"api/liquid.tags.tag_case/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_case/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag_case/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_case/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_case/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_case/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_case/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_case/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_case/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_comment/","text":"module liquid.tags . tag_comment </> Tag comment {% comment %} ... {% endcomment %} Classes TagComment \u2014 The comment tag </> class liquid.tags.tag_comment . TagComment ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag.Tag The comment tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag_comment"},{"location":"api/liquid.tags.tag_comment/#liquidtagstag_comment","text":"</> Tag comment {% comment %} ... {% endcomment %} Classes TagComment \u2014 The comment tag </> class","title":"liquid.tags.tag_comment"},{"location":"api/liquid.tags.tag_comment/#liquidtagstag_commenttagcomment","text":"</> Bases liquid.tags.tag.Tag The comment tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_comment.TagComment"},{"location":"api/liquid.tags.tag_comment/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_comment/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag_comment/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_comment/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_comment/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_comment/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_comment/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_comment/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_comment/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_config/","text":"module liquid.tags . tag_config </> Tag config {% config %} Classes TagConfigTransformer \u2014 The transformer for tag config </> TagConfig \u2014 The config tag </> class liquid.tags.tag_config . TagConfigTransformer ( visit_tokens=False ) </> Bases liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag config Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> comparison ( expr , op , expr2 ) \u2014 rule comparison: comparison: atom (_comp_op atom)? </> config_item ( varname , constant ) \u2014 Transform the tag_config rule </> range ( token ) \u2014 Ranges </> tag_config ( *items ) \u2014 Transform the tag_config rule </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method transform ( tree ) </> Transform the given tree, and return the final result method __mul__ ( other ) </> Chain two transformers together, returning a new transformer. method __default__ ( data , children , meta ) </> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method __default_token__ ( token ) </> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method range ( token ) </> Ranges method comparison ( expr , op=None , expr2=None ) </> rule comparison: comparison: atom (_comp_op atom)? method varname ( vname ) </> Keep the token information for tracking method argvalue ( test1 , test2=NOTHING ) </> rule argvalue: test (\"=\" test)? method tag_config ( *items ) </> Transform the tag_config rule method config_item ( varname , constant=True ) </> Transform the tag_config rule class liquid.tags.tag_config . TagConfig ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag.Tag The config tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the configurations </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method parse ( force=False ) </> Parse the configurations","title":"liquid.tags.tag_config"},{"location":"api/liquid.tags.tag_config/#liquidtagstag_config","text":"</> Tag config {% config %} Classes TagConfigTransformer \u2014 The transformer for tag config </> TagConfig \u2014 The config tag </> class","title":"liquid.tags.tag_config"},{"location":"api/liquid.tags.tag_config/#liquidtagstag_configtagconfigtransformer","text":"</> Bases liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag config Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> comparison ( expr , op , expr2 ) \u2014 rule comparison: comparison: atom (_comp_op atom)? </> config_item ( varname , constant ) \u2014 Transform the tag_config rule </> range ( token ) \u2014 Ranges </> tag_config ( *items ) \u2014 Transform the tag_config rule </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method","title":"liquid.tags.tag_config.TagConfigTransformer"},{"location":"api/liquid.tags.tag_config/#larkvisitorstransformertransform","text":"</> Transform the given tree, and return the final result method","title":"lark.visitors.Transformer.transform"},{"location":"api/liquid.tags.tag_config/#larkvisitorstransformermul","text":"</> Chain two transformers together, returning a new transformer. method","title":"lark.visitors.Transformer.mul"},{"location":"api/liquid.tags.tag_config/#larkvisitorstransformerdefault","text":"</> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method","title":"lark.visitors.Transformer.default"},{"location":"api/liquid.tags.tag_config/#larkvisitorstransformerdefault_token","text":"</> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method","title":"lark.visitors.Transformer.default_token"},{"location":"api/liquid.tags.tag_config/#liquidtagstransformertagtransformerrange","text":"</> Ranges method","title":"liquid.tags.transformer.TagTransformer.range"},{"location":"api/liquid.tags.tag_config/#liquidtagstransformertagtransformercomparison","text":"</> rule comparison: comparison: atom (_comp_op atom)? method","title":"liquid.tags.transformer.TagTransformer.comparison"},{"location":"api/liquid.tags.tag_config/#liquidtagstransformertagtransformervarname","text":"</> Keep the token information for tracking method","title":"liquid.tags.transformer.TagTransformer.varname"},{"location":"api/liquid.tags.tag_config/#liquidtagstransformertagtransformerargvalue","text":"</> rule argvalue: test (\"=\" test)? method","title":"liquid.tags.transformer.TagTransformer.argvalue"},{"location":"api/liquid.tags.tag_config/#liquidtagstag_configtagconfigtransformertag_config","text":"</> Transform the tag_config rule method","title":"liquid.tags.tag_config.TagConfigTransformer.tag_config"},{"location":"api/liquid.tags.tag_config/#liquidtagstag_configtagconfigtransformerconfig_item","text":"</> Transform the tag_config rule class","title":"liquid.tags.tag_config.TagConfigTransformer.config_item"},{"location":"api/liquid.tags.tag_config/#liquidtagstag_configtagconfig","text":"</> Bases liquid.tags.tag.Tag The config tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the configurations </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_config.TagConfig"},{"location":"api/liquid.tags.tag_config/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_config/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_config/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_config/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_config/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_config/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_config/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_config/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_config/#liquidtagstag_configtagconfigparse","text":"</> Parse the configurations","title":"liquid.tags.tag_config.TagConfig.parse"},{"location":"api/liquid.tags.tag_continue/","text":"module liquid.tags . tag_continue </> The continue tag {% for ... %} {% continue %} {% endfor %} Classes TagContinue \u2014 Class for tag continue </> class liquid.tags.tag_continue . TagContinue ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag_break.TagBreak liquid.tags.tag.Tag Class for tag continue Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Make sure no extra content for this tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method parse ( force=False ) </> Make sure no extra content for this tag","title":"liquid.tags.tag_continue"},{"location":"api/liquid.tags.tag_continue/#liquidtagstag_continue","text":"</> The continue tag {% for ... %} {% continue %} {% endfor %} Classes TagContinue \u2014 Class for tag continue </> class","title":"liquid.tags.tag_continue"},{"location":"api/liquid.tags.tag_continue/#liquidtagstag_continuetagcontinue","text":"</> Bases liquid.tags.tag_break.TagBreak liquid.tags.tag.Tag Class for tag continue Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Make sure no extra content for this tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_continue.TagContinue"},{"location":"api/liquid.tags.tag_continue/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_continue/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_continue/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_continue/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_continue/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_continue/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_continue/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_continue/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_continue/#liquidtagstag_breaktagbreakparse","text":"</> Make sure no extra content for this tag","title":"liquid.tags.tag_break.TagBreak.parse"},{"location":"api/liquid.tags.tag_cycle/","text":"module liquid.tags . tag_cycle </> Tag cycle {% for <loop> <args> %} ... {% cycle \"one\" , \"two\" , \"three\" %} ... {% endfor %} Classes TagCycleTransformer \u2014 The transformer for tag cycle </> TagCycle \u2014 The cycle tag </> class liquid.tags.tag_cycle . TagCycleTransformer ( visit_tokens=False ) </> Bases liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag cycle Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> comparison ( expr , op , expr2 ) \u2014 rule comparison: comparison: atom (_comp_op atom)? </> range ( token ) \u2014 Ranges </> tag_cycle ( group , args ) \u2014 Transformer for tag for </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method transform ( tree ) </> Transform the given tree, and return the final result method __mul__ ( other ) </> Chain two transformers together, returning a new transformer. method __default__ ( data , children , meta ) </> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method __default_token__ ( token ) </> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method range ( token ) </> Ranges method comparison ( expr , op=None , expr2=None ) </> rule comparison: comparison: atom (_comp_op atom)? method varname ( vname ) </> Keep the token information for tracking method argvalue ( test1 , test2=NOTHING ) </> rule argvalue: test (\"=\" test)? method tag_cycle ( group , args=None ) </> Transformer for tag for class liquid.tags.tag_cycle . TagCycle ( *args , **kwargs ) </> Bases liquid.tags.tag.Tag The cycle tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> args ( local_vars , global_vars ) \u2014 Get the args of the cycle </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> get_value ( local_vars , global_vars ) \u2014 Get current value of the cycle, and increment the cursor </> group ( local_vars , global_vars ) \u2014 Get the group of the cycle </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method group ( local_vars , global_vars ) </> Get the group of the cycle method args ( local_vars , global_vars ) </> Get the args of the cycle method get_value ( local_vars , global_vars ) </> Get current value of the cycle, and increment the cursor","title":"liquid.tags.tag_cycle"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstag_cycle","text":"</> Tag cycle {% for <loop> <args> %} ... {% cycle \"one\" , \"two\" , \"three\" %} ... {% endfor %} Classes TagCycleTransformer \u2014 The transformer for tag cycle </> TagCycle \u2014 The cycle tag </> class","title":"liquid.tags.tag_cycle"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstag_cycletagcycletransformer","text":"</> Bases liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag cycle Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> comparison ( expr , op , expr2 ) \u2014 rule comparison: comparison: atom (_comp_op atom)? </> range ( token ) \u2014 Ranges </> tag_cycle ( group , args ) \u2014 Transformer for tag for </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method","title":"liquid.tags.tag_cycle.TagCycleTransformer"},{"location":"api/liquid.tags.tag_cycle/#larkvisitorstransformertransform","text":"</> Transform the given tree, and return the final result method","title":"lark.visitors.Transformer.transform"},{"location":"api/liquid.tags.tag_cycle/#larkvisitorstransformermul","text":"</> Chain two transformers together, returning a new transformer. method","title":"lark.visitors.Transformer.mul"},{"location":"api/liquid.tags.tag_cycle/#larkvisitorstransformerdefault","text":"</> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method","title":"lark.visitors.Transformer.default"},{"location":"api/liquid.tags.tag_cycle/#larkvisitorstransformerdefault_token","text":"</> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method","title":"lark.visitors.Transformer.default_token"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstransformertagtransformerrange","text":"</> Ranges method","title":"liquid.tags.transformer.TagTransformer.range"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstransformertagtransformercomparison","text":"</> rule comparison: comparison: atom (_comp_op atom)? method","title":"liquid.tags.transformer.TagTransformer.comparison"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstransformertagtransformervarname","text":"</> Keep the token information for tracking method","title":"liquid.tags.transformer.TagTransformer.varname"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstransformertagtransformerargvalue","text":"</> rule argvalue: test (\"=\" test)? method","title":"liquid.tags.transformer.TagTransformer.argvalue"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstag_cycletagcycletransformertag_cycle","text":"</> Transformer for tag for class","title":"liquid.tags.tag_cycle.TagCycleTransformer.tag_cycle"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstag_cycletagcycle","text":"</> Bases liquid.tags.tag.Tag The cycle tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> args ( local_vars , global_vars ) \u2014 Get the args of the cycle </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> get_value ( local_vars , global_vars ) \u2014 Get current value of the cycle, and increment the cursor </> group ( local_vars , global_vars ) \u2014 Get the group of the cycle </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_cycle.TagCycle"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstag_cycletagcyclegroup","text":"</> Get the group of the cycle method","title":"liquid.tags.tag_cycle.TagCycle.group"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstag_cycletagcycleargs","text":"</> Get the args of the cycle method","title":"liquid.tags.tag_cycle.TagCycle.args"},{"location":"api/liquid.tags.tag_cycle/#liquidtagstag_cycletagcycleget_value","text":"</> Get current value of the cycle, and increment the cursor","title":"liquid.tags.tag_cycle.TagCycle.get_value"},{"location":"api/liquid.tags.tag_decrement/","text":"module liquid.tags . tag_decrement </> Tag decrement {% decrement my_counter %} {% decrement my_counter %} {% decrement my_counter %} Classes TagDecrement \u2014 The decrement tag' </> class liquid.tags.tag_decrement . TagDecrement ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag_capture.TagCapture liquid.tags.tag.Tag The decrement tag' Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag_decrement"},{"location":"api/liquid.tags.tag_decrement/#liquidtagstag_decrement","text":"</> Tag decrement {% decrement my_counter %} {% decrement my_counter %} {% decrement my_counter %} Classes TagDecrement \u2014 The decrement tag' </> class","title":"liquid.tags.tag_decrement"},{"location":"api/liquid.tags.tag_decrement/#liquidtagstag_decrementtagdecrement","text":"</> Bases liquid.tags.tag_capture.TagCapture liquid.tags.tag.Tag The decrement tag' Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_decrement.TagDecrement"},{"location":"api/liquid.tags.tag_decrement/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_decrement/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag_decrement/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_decrement/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_decrement/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_decrement/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_decrement/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_decrement/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_decrement/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_else/","text":"module liquid.tags . tag_else </> Else tag in following situations // in if {% if ... %} ... [ {% elsif ... %} ] ... {% else %} ... {% endif %} // in case / when {% case x %} {% when ... %} ... {% when ... %} ... {% else %} ... {% endcase %} // in for {% for ... %} ... {% else %} ... {% endfor %} Classes TagElse \u2014 Class for tag else </> class liquid.tags.tag_else . TagElse ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag.Tag Class for tag else Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 No extra content allowed for standard else tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method parse ( force=False ) </> No extra content allowed for standard else tag","title":"liquid.tags.tag_else"},{"location":"api/liquid.tags.tag_else/#liquidtagstag_else","text":"</> Else tag in following situations // in if {% if ... %} ... [ {% elsif ... %} ] ... {% else %} ... {% endif %} // in case / when {% case x %} {% when ... %} ... {% when ... %} ... {% else %} ... {% endcase %} // in for {% for ... %} ... {% else %} ... {% endfor %} Classes TagElse \u2014 Class for tag else </> class","title":"liquid.tags.tag_else"},{"location":"api/liquid.tags.tag_else/#liquidtagstag_elsetagelse","text":"</> Bases liquid.tags.tag.Tag Class for tag else Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 No extra content allowed for standard else tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_else.TagElse"},{"location":"api/liquid.tags.tag_else/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_else/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_else/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_else/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_else/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_else/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_else/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_else/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_else/#liquidtagstag_elsetagelseparse","text":"</> No extra content allowed for standard else tag","title":"liquid.tags.tag_else.TagElse.parse"},{"location":"api/liquid.tags.tag_elsif/","text":"module liquid.tags . tag_elsif </> Elsif tag {% if ... %} ... {% elsif ... %} ... [ {% else %} ] ... {% endif %} Classes TagElsif \u2014 Class for tag elsif </> class liquid.tags.tag_elsif . TagElsif ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag_if.TagIf liquid.tags.tag.Tag Class for tag elsif Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag_elsif"},{"location":"api/liquid.tags.tag_elsif/#liquidtagstag_elsif","text":"</> Elsif tag {% if ... %} ... {% elsif ... %} ... [ {% else %} ] ... {% endif %} Classes TagElsif \u2014 Class for tag elsif </> class","title":"liquid.tags.tag_elsif"},{"location":"api/liquid.tags.tag_elsif/#liquidtagstag_elsiftagelsif","text":"</> Bases liquid.tags.tag_if.TagIf liquid.tags.tag.Tag Class for tag elsif Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_elsif.TagElsif"},{"location":"api/liquid.tags.tag_elsif/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_elsif/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag_elsif/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_elsif/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_elsif/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_elsif/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_elsif/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_elsif/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_elsif/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_extends/","text":"module liquid.tags . tag_extends </> Tag extends {% extends ... %} Classes TagExtends \u2014 The extends tag </> class liquid.tags.tag_extends . TagExtends ( *args , **kwargs ) </> Bases liquid.tags.tag.Tag The extends tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method parse ( force=False ) </> Parse the content of the tag","title":"liquid.tags.tag_extends"},{"location":"api/liquid.tags.tag_extends/#liquidtagstag_extends","text":"</> Tag extends {% extends ... %} Classes TagExtends \u2014 The extends tag </> class","title":"liquid.tags.tag_extends"},{"location":"api/liquid.tags.tag_extends/#liquidtagstag_extendstagextends","text":"</> Bases liquid.tags.tag.Tag The extends tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_extends.TagExtends"},{"location":"api/liquid.tags.tag_extends/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_extends/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_extends/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_extends/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_extends/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_extends/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_extends/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_extends/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_extends/#liquidtagstag_extendstagextendsparse","text":"</> Parse the content of the tag","title":"liquid.tags.tag_extends.TagExtends.parse"},{"location":"api/liquid.tags.tag_for/","text":"module liquid.tags . tag_for </> Tag for {% for <loop> <args> %} ... {% endfor %} Classes ForLoop \u2014 ForLoop(first, index, index0, last, length, rindex, rindex0) </> TagForTransformer \u2014 The transformer for tag for </> TagFor \u2014 The for tag </> class liquid.tags.tag_for . ForLoop ( first , index , index0 , last , length , rindex , rindex0 ) </> Bases tuple ForLoop(first, index, index0, last, length, rindex, rindex0) class liquid.tags.tag_for . TagForTransformer ( visit_tokens=False ) </> Bases liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag for Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> comparison ( expr , op , expr2 ) \u2014 rule comparison: comparison: atom (_comp_op atom)? </> for_limit_arg ( arg ) \u2014 Transformer for for_limit_arg </> for_offset_arg ( arg ) \u2014 Transformer for for_offset_arg </> for_reversed_arg ( ) \u2014 Transformer for for_reversed_arg </> range ( token ) \u2014 Ranges </> tag_for ( varname , atom , *args ) \u2014 Transformer for tag for </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method transform ( tree ) </> Transform the given tree, and return the final result method __mul__ ( other ) </> Chain two transformers together, returning a new transformer. method __default__ ( data , children , meta ) </> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method __default_token__ ( token ) </> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method range ( token ) </> Ranges method comparison ( expr , op=None , expr2=None ) </> rule comparison: comparison: atom (_comp_op atom)? method varname ( vname ) </> Keep the token information for tracking method argvalue ( test1 , test2=NOTHING ) </> rule argvalue: test (\"=\" test)? method for_limit_arg ( arg ) </> Transformer for for_limit_arg method for_offset_arg ( arg ) </> Transformer for for_offset_arg method for_reversed_arg ( ) </> Transformer for for_reversed_arg method tag_for ( varname , atom , *args ) </> Transformer for tag for class liquid.tags.tag_for . TagFor ( *args , **kwargs ) </> Bases liquid.tags.tag.Tag The for tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag cycles \u2014 The cycle object for cycle tags elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> flag_break \u2014 The flag for break statement flag_continue \u2014 The flag for continue statement name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag_for"},{"location":"api/liquid.tags.tag_for/#liquidtagstag_for","text":"</> Tag for {% for <loop> <args> %} ... {% endfor %} Classes ForLoop \u2014 ForLoop(first, index, index0, last, length, rindex, rindex0) </> TagForTransformer \u2014 The transformer for tag for </> TagFor \u2014 The for tag </> class","title":"liquid.tags.tag_for"},{"location":"api/liquid.tags.tag_for/#liquidtagstag_forforloop","text":"</> Bases tuple ForLoop(first, index, index0, last, length, rindex, rindex0) class","title":"liquid.tags.tag_for.ForLoop"},{"location":"api/liquid.tags.tag_for/#liquidtagstag_fortagfortransformer","text":"</> Bases liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag for Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> comparison ( expr , op , expr2 ) \u2014 rule comparison: comparison: atom (_comp_op atom)? </> for_limit_arg ( arg ) \u2014 Transformer for for_limit_arg </> for_offset_arg ( arg ) \u2014 Transformer for for_offset_arg </> for_reversed_arg ( ) \u2014 Transformer for for_reversed_arg </> range ( token ) \u2014 Ranges </> tag_for ( varname , atom , *args ) \u2014 Transformer for tag for </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method","title":"liquid.tags.tag_for.TagForTransformer"},{"location":"api/liquid.tags.tag_for/#larkvisitorstransformertransform","text":"</> Transform the given tree, and return the final result method","title":"lark.visitors.Transformer.transform"},{"location":"api/liquid.tags.tag_for/#larkvisitorstransformermul","text":"</> Chain two transformers together, returning a new transformer. method","title":"lark.visitors.Transformer.mul"},{"location":"api/liquid.tags.tag_for/#larkvisitorstransformerdefault","text":"</> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method","title":"lark.visitors.Transformer.default"},{"location":"api/liquid.tags.tag_for/#larkvisitorstransformerdefault_token","text":"</> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method","title":"lark.visitors.Transformer.default_token"},{"location":"api/liquid.tags.tag_for/#liquidtagstransformertagtransformerrange","text":"</> Ranges method","title":"liquid.tags.transformer.TagTransformer.range"},{"location":"api/liquid.tags.tag_for/#liquidtagstransformertagtransformercomparison","text":"</> rule comparison: comparison: atom (_comp_op atom)? method","title":"liquid.tags.transformer.TagTransformer.comparison"},{"location":"api/liquid.tags.tag_for/#liquidtagstransformertagtransformervarname","text":"</> Keep the token information for tracking method","title":"liquid.tags.transformer.TagTransformer.varname"},{"location":"api/liquid.tags.tag_for/#liquidtagstransformertagtransformerargvalue","text":"</> rule argvalue: test (\"=\" test)? method","title":"liquid.tags.transformer.TagTransformer.argvalue"},{"location":"api/liquid.tags.tag_for/#liquidtagstag_fortagfortransformerfor_limit_arg","text":"</> Transformer for for_limit_arg method","title":"liquid.tags.tag_for.TagForTransformer.for_limit_arg"},{"location":"api/liquid.tags.tag_for/#liquidtagstag_fortagfortransformerfor_offset_arg","text":"</> Transformer for for_offset_arg method","title":"liquid.tags.tag_for.TagForTransformer.for_offset_arg"},{"location":"api/liquid.tags.tag_for/#liquidtagstag_fortagfortransformerfor_reversed_arg","text":"</> Transformer for for_reversed_arg method","title":"liquid.tags.tag_for.TagForTransformer.for_reversed_arg"},{"location":"api/liquid.tags.tag_for/#liquidtagstag_fortagfortransformertag_for","text":"</> Transformer for tag for class","title":"liquid.tags.tag_for.TagForTransformer.tag_for"},{"location":"api/liquid.tags.tag_for/#liquidtagstag_fortagfor","text":"</> Bases liquid.tags.tag.Tag The for tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag cycles \u2014 The cycle object for cycle tags elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> flag_break \u2014 The flag for break statement flag_continue \u2014 The flag for continue statement name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_for.TagFor"},{"location":"api/liquid.tags.tag_for/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_for/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag_for/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_for/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_for/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_for/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_for/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_for/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_for/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_if/","text":"module liquid.tags . tag_if </> Tag if {% if condition %} ... {% endif %} Classes TagIf \u2014 Tag if </> class liquid.tags.tag_if . TagIf ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag.Tag Tag if Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag_if"},{"location":"api/liquid.tags.tag_if/#liquidtagstag_if","text":"</> Tag if {% if condition %} ... {% endif %} Classes TagIf \u2014 Tag if </> class","title":"liquid.tags.tag_if"},{"location":"api/liquid.tags.tag_if/#liquidtagstag_iftagif","text":"</> Bases liquid.tags.tag.Tag Tag if Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_if.TagIf"},{"location":"api/liquid.tags.tag_if/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_if/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag_if/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_if/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_if/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_if/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_if/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_if/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_if/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_include/","text":"module liquid.tags . tag_include </> Tag include {% include ... %} Classes TagIncludeTransformer \u2014 The transformer for tag include </> TagInclude \u2014 The extends tag </> class liquid.tags.tag_include . TagIncludeTransformer ( visit_tokens=False ) </> Bases liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag include Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> comparison ( expr , op , expr2 ) \u2014 rule comparison: comparison: atom (_comp_op atom)? </> include_item ( varname , test ) \u2014 Transform include_item rule </> range ( token ) \u2014 Ranges </> tag_include ( path , *items ) \u2014 Transform tag_include </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method transform ( tree ) </> Transform the given tree, and return the final result method __mul__ ( other ) </> Chain two transformers together, returning a new transformer. method __default__ ( data , children , meta ) </> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method __default_token__ ( token ) </> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method range ( token ) </> Ranges method comparison ( expr , op=None , expr2=None ) </> rule comparison: comparison: atom (_comp_op atom)? method varname ( vname ) </> Keep the token information for tracking method argvalue ( test1 , test2=NOTHING ) </> rule argvalue: test (\"=\" test)? method include_item ( varname , test ) </> Transform include_item rule method tag_include ( path , *items ) </> Transform tag_include class liquid.tags.tag_include . TagInclude ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag.Tag The extends tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the include template </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method parse ( force=False ) </> Parse the include template","title":"liquid.tags.tag_include"},{"location":"api/liquid.tags.tag_include/#liquidtagstag_include","text":"</> Tag include {% include ... %} Classes TagIncludeTransformer \u2014 The transformer for tag include </> TagInclude \u2014 The extends tag </> class","title":"liquid.tags.tag_include"},{"location":"api/liquid.tags.tag_include/#liquidtagstag_includetagincludetransformer","text":"</> Bases liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tag include Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> comparison ( expr , op , expr2 ) \u2014 rule comparison: comparison: atom (_comp_op atom)? </> include_item ( varname , test ) \u2014 Transform include_item rule </> range ( token ) \u2014 Ranges </> tag_include ( path , *items ) \u2014 Transform tag_include </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method","title":"liquid.tags.tag_include.TagIncludeTransformer"},{"location":"api/liquid.tags.tag_include/#larkvisitorstransformertransform","text":"</> Transform the given tree, and return the final result method","title":"lark.visitors.Transformer.transform"},{"location":"api/liquid.tags.tag_include/#larkvisitorstransformermul","text":"</> Chain two transformers together, returning a new transformer. method","title":"lark.visitors.Transformer.mul"},{"location":"api/liquid.tags.tag_include/#larkvisitorstransformerdefault","text":"</> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method","title":"lark.visitors.Transformer.default"},{"location":"api/liquid.tags.tag_include/#larkvisitorstransformerdefault_token","text":"</> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method","title":"lark.visitors.Transformer.default_token"},{"location":"api/liquid.tags.tag_include/#liquidtagstransformertagtransformerrange","text":"</> Ranges method","title":"liquid.tags.transformer.TagTransformer.range"},{"location":"api/liquid.tags.tag_include/#liquidtagstransformertagtransformercomparison","text":"</> rule comparison: comparison: atom (_comp_op atom)? method","title":"liquid.tags.transformer.TagTransformer.comparison"},{"location":"api/liquid.tags.tag_include/#liquidtagstransformertagtransformervarname","text":"</> Keep the token information for tracking method","title":"liquid.tags.transformer.TagTransformer.varname"},{"location":"api/liquid.tags.tag_include/#liquidtagstransformertagtransformerargvalue","text":"</> rule argvalue: test (\"=\" test)? method","title":"liquid.tags.transformer.TagTransformer.argvalue"},{"location":"api/liquid.tags.tag_include/#liquidtagstag_includetagincludetransformerinclude_item","text":"</> Transform include_item rule method","title":"liquid.tags.tag_include.TagIncludeTransformer.include_item"},{"location":"api/liquid.tags.tag_include/#liquidtagstag_includetagincludetransformertag_include","text":"</> Transform tag_include class","title":"liquid.tags.tag_include.TagIncludeTransformer.tag_include"},{"location":"api/liquid.tags.tag_include/#liquidtagstag_includetaginclude","text":"</> Bases liquid.tags.tag.Tag The extends tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the include template </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_include.TagInclude"},{"location":"api/liquid.tags.tag_include/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_include/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_include/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_include/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_include/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_include/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_include/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_include/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_include/#liquidtagstag_includetagincludeparse","text":"</> Parse the include template","title":"liquid.tags.tag_include.TagInclude.parse"},{"location":"api/liquid.tags.tag_increment/","text":"module liquid.tags . tag_increment </> Tag increment {% increment my_counter %} {% increment my_counter %} {% increment my_counter %} Classes TagIncrement \u2014 The increment tag </> class liquid.tags.tag_increment . TagIncrement ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag_capture.TagCapture liquid.tags.tag.Tag The increment tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag_increment"},{"location":"api/liquid.tags.tag_increment/#liquidtagstag_increment","text":"</> Tag increment {% increment my_counter %} {% increment my_counter %} {% increment my_counter %} Classes TagIncrement \u2014 The increment tag </> class","title":"liquid.tags.tag_increment"},{"location":"api/liquid.tags.tag_increment/#liquidtagstag_incrementtagincrement","text":"</> Bases liquid.tags.tag_capture.TagCapture liquid.tags.tag.Tag The increment tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_increment.TagIncrement"},{"location":"api/liquid.tags.tag_increment/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_increment/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag_increment/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_increment/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_increment/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_increment/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_increment/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_increment/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_increment/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_raw/","text":"module liquid.tags . tag_raw </> Tag raw {% raw %} ... {% endraw %} Classes TagRaw \u2014 The raw tag </> class liquid.tags.tag_raw . TagRaw ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag.Tag The raw tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 No extra content allowed for standard else tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method parse ( force=False ) </> No extra content allowed for standard else tag","title":"liquid.tags.tag_raw"},{"location":"api/liquid.tags.tag_raw/#liquidtagstag_raw","text":"</> Tag raw {% raw %} ... {% endraw %} Classes TagRaw \u2014 The raw tag </> class","title":"liquid.tags.tag_raw"},{"location":"api/liquid.tags.tag_raw/#liquidtagstag_rawtagraw","text":"</> Bases liquid.tags.tag.Tag The raw tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 No extra content allowed for standard else tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_raw.TagRaw"},{"location":"api/liquid.tags.tag_raw/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_raw/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_raw/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_raw/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_raw/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_raw/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_raw/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_raw/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified) method","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_raw/#liquidtagstag_rawtagrawparse","text":"</> No extra content allowed for standard else tag","title":"liquid.tags.tag_raw.TagRaw.parse"},{"location":"api/liquid.tags.tag_tablerow/","text":"module liquid.tags . tag_tablerow </> Tag tabrow <table> {% tablerow product in collection.products %} {{ product . title }} {% endtablerow %} </table> Classes TablerowObject \u2014 TablerowObject(itername, obj, limit, offset, cols) </> TagTablerowTransformer \u2014 The transformer for tablerow tag </> TagTablerow \u2014 The tablerow tag </> class liquid.tags.tag_tablerow . TablerowObject ( itername , obj , limit , offset , cols ) </> Bases tuple TablerowObject(itername, obj, limit, offset, cols) class liquid.tags.tag_tablerow . TagTablerowTransformer ( visit_tokens=False ) </> Bases liquid.tags.tag_for.TagForTransformer liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tablerow tag Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> comparison ( expr , op , expr2 ) \u2014 rule comparison: comparison: atom (_comp_op atom)? </> for_limit_arg ( arg ) \u2014 Transformer for for_limit_arg </> for_offset_arg ( arg ) \u2014 Transformer for for_offset_arg </> for_reversed_arg ( ) \u2014 Transformer for for_reversed_arg </> range ( token ) \u2014 Ranges </> tablerow_cols_arg ( token ) \u2014 Transform rule: tablerow_cols_arg </> tag_for ( varname , atom , *args ) \u2014 Transformer for tag for </> tag_tablerow ( varname , atom , *args ) \u2014 Transform rule: tag_tablerow </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method transform ( tree ) </> Transform the given tree, and return the final result method __mul__ ( other ) </> Chain two transformers together, returning a new transformer. method __default__ ( data , children , meta ) </> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method __default_token__ ( token ) </> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method range ( token ) </> Ranges method comparison ( expr , op=None , expr2=None ) </> rule comparison: comparison: atom (_comp_op atom)? method varname ( vname ) </> Keep the token information for tracking method argvalue ( test1 , test2=NOTHING ) </> rule argvalue: test (\"=\" test)? method for_limit_arg ( arg ) </> Transformer for for_limit_arg method for_offset_arg ( arg ) </> Transformer for for_offset_arg method for_reversed_arg ( ) </> Transformer for for_reversed_arg method tag_for ( varname , atom , *args ) </> Transformer for tag for method tablerow_cols_arg ( token ) </> Transform rule: tablerow_cols_arg method tag_tablerow ( varname , atom , *args ) </> Transform rule: tag_tablerow class liquid.tags.tag_tablerow . TagTablerow ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag.Tag The tablerow tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag_tablerow"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstag_tablerow","text":"</> Tag tabrow <table> {% tablerow product in collection.products %} {{ product . title }} {% endtablerow %} </table> Classes TablerowObject \u2014 TablerowObject(itername, obj, limit, offset, cols) </> TagTablerowTransformer \u2014 The transformer for tablerow tag </> TagTablerow \u2014 The tablerow tag </> class","title":"liquid.tags.tag_tablerow"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstag_tablerowtablerowobject","text":"</> Bases tuple TablerowObject(itername, obj, limit, offset, cols) class","title":"liquid.tags.tag_tablerow.TablerowObject"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstag_tablerowtagtablerowtransformer","text":"</> Bases liquid.tags.tag_for.TagForTransformer liquid.tags.transformer.TagTransformer lark.visitors.Transformer lark.visitors._Decoratable The transformer for tablerow tag Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> comparison ( expr , op , expr2 ) \u2014 rule comparison: comparison: atom (_comp_op atom)? </> for_limit_arg ( arg ) \u2014 Transformer for for_limit_arg </> for_offset_arg ( arg ) \u2014 Transformer for for_offset_arg </> for_reversed_arg ( ) \u2014 Transformer for for_reversed_arg </> range ( token ) \u2014 Ranges </> tablerow_cols_arg ( token ) \u2014 Transform rule: tablerow_cols_arg </> tag_for ( varname , atom , *args ) \u2014 Transformer for tag for </> tag_tablerow ( varname , atom , *args ) \u2014 Transform rule: tag_tablerow </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method","title":"liquid.tags.tag_tablerow.TagTablerowTransformer"},{"location":"api/liquid.tags.tag_tablerow/#larkvisitorstransformertransform","text":"</> Transform the given tree, and return the final result method","title":"lark.visitors.Transformer.transform"},{"location":"api/liquid.tags.tag_tablerow/#larkvisitorstransformermul","text":"</> Chain two transformers together, returning a new transformer. method","title":"lark.visitors.Transformer.mul"},{"location":"api/liquid.tags.tag_tablerow/#larkvisitorstransformerdefault","text":"</> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method","title":"lark.visitors.Transformer.default"},{"location":"api/liquid.tags.tag_tablerow/#larkvisitorstransformerdefault_token","text":"</> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method","title":"lark.visitors.Transformer.default_token"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstransformertagtransformerrange","text":"</> Ranges method","title":"liquid.tags.transformer.TagTransformer.range"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstransformertagtransformercomparison","text":"</> rule comparison: comparison: atom (_comp_op atom)? method","title":"liquid.tags.transformer.TagTransformer.comparison"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstransformertagtransformervarname","text":"</> Keep the token information for tracking method","title":"liquid.tags.transformer.TagTransformer.varname"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstransformertagtransformerargvalue","text":"</> rule argvalue: test (\"=\" test)? method","title":"liquid.tags.transformer.TagTransformer.argvalue"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstag_fortagfortransformerfor_limit_arg","text":"</> Transformer for for_limit_arg method","title":"liquid.tags.tag_for.TagForTransformer.for_limit_arg"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstag_fortagfortransformerfor_offset_arg","text":"</> Transformer for for_offset_arg method","title":"liquid.tags.tag_for.TagForTransformer.for_offset_arg"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstag_fortagfortransformerfor_reversed_arg","text":"</> Transformer for for_reversed_arg method","title":"liquid.tags.tag_for.TagForTransformer.for_reversed_arg"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstag_fortagfortransformertag_for","text":"</> Transformer for tag for method","title":"liquid.tags.tag_for.TagForTransformer.tag_for"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstag_tablerowtagtablerowtransformertablerow_cols_arg","text":"</> Transform rule: tablerow_cols_arg method","title":"liquid.tags.tag_tablerow.TagTablerowTransformer.tablerow_cols_arg"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstag_tablerowtagtablerowtransformertag_tablerow","text":"</> Transform rule: tag_tablerow class","title":"liquid.tags.tag_tablerow.TagTablerowTransformer.tag_tablerow"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstag_tablerowtagtablerow","text":"</> Bases liquid.tags.tag.Tag The tablerow tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_tablerow.TagTablerow"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_tablerow/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_unless/","text":"module liquid.tags . tag_unless </> Tag unless {% unless condition %} ... {% endunless %} Classes TagUnless \u2014 The unless tag </> class liquid.tags.tag_unless . TagUnless ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag_if.TagIf liquid.tags.tag.Tag The unless tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag_unless"},{"location":"api/liquid.tags.tag_unless/#liquidtagstag_unless","text":"</> Tag unless {% unless condition %} ... {% endunless %} Classes TagUnless \u2014 The unless tag </> class","title":"liquid.tags.tag_unless"},{"location":"api/liquid.tags.tag_unless/#liquidtagstag_unlesstagunless","text":"</> Bases liquid.tags.tag_if.TagIf liquid.tags.tag.Tag The unless tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_unless.TagUnless"},{"location":"api/liquid.tags.tag_unless/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_unless/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag_unless/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_unless/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_unless/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_unless/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_unless/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_unless/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_unless/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.tag_when/","text":"module liquid.tags . tag_when </> Tag when (in case) {% assign handle = \"cake\" %} {% case handle %} {% when \"cake\" %} This is a cake {% when \"cookie\" %} This is a cookie {% else %} This is not a cake nor a cookie {% endcase %} Classes TagWhen \u2014 The when tag </> class liquid.tags.tag_when . TagWhen ( hitname , content , context , open_compact , close_compact , parser ) </> Bases liquid.tags.tag__output.TagOUTPUT liquid.tags.tag.Tag The when tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod __init_subclass__ ( use_parser=False ) </> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method parse ( force=False ) </> Parse the content of the tag method parse_children ( base_level ) </> Parse the children if they are hold previouly method __repr__ ( ) </> The representation of the tag method is_elder ( tag ) </> Check if tag can be an elder of this tag method is_parent ( tag ) </> Check if tag can be a parent of this tag method check_parents ( ) </> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method check_elders ( ) </> Check if required elders are placed method render ( local_vars , global_vars , from_elder=False ) </> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag_when"},{"location":"api/liquid.tags.tag_when/#liquidtagstag_when","text":"</> Tag when (in case) {% assign handle = \"cake\" %} {% case handle %} {% when \"cake\" %} This is a cake {% when \"cookie\" %} This is a cookie {% else %} This is not a cake nor a cookie {% endcase %} Classes TagWhen \u2014 The when tag </> class","title":"liquid.tags.tag_when"},{"location":"api/liquid.tags.tag_when/#liquidtagstag_whentagwhen","text":"</> Bases liquid.tags.tag__output.TagOUTPUT liquid.tags.tag.Tag The when tag Parameters hitname \u2014 The name that this tag hits (since a tag can have aliases) content \u2014 The content of the tag context \u2014 The context of the tag open_compact \u2014 Whether it is compact tag for open tag close_compact \u2014 Whether it is compact tag for close tag parser \u2014 The parser of the tag Attributes BASE_GRAMMAR \u2014 The base grammar ELDER_TAGS \u2014 Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS \u2014 Parent tags where this tags allows to be put in PARSER \u2014 Parser to parse the content RAW \u2014 Whether all content should be treated as raw SECURE \u2014 Is this tag secure? An insecure tag is not allowed in strict mode VOID \u2014 whether the tag is void, meaning True if there is no children allow otherwise False YONGER_TAGS \u2014 A flag to tell whether a yonger sibling tag is allowed to be followed. children \u2014 The children of the tag close_compact \u2014 Whether it is compact tag for close tag closest_parent \u2014 Find the closest parent </> content \u2014 The content of the tag context \u2014 The context of the tag elder_required \u2014 Whether this tag is requiring an elder tag </> eldest \u2014 Find eldest tag </> name \u2014 The name that this tag hits (since a tag can have aliases) next \u2014 The next tag of this tag open_compact \u2014 Whether it is compact tag for open tag parent \u2014 The parent of the tag parent_required \u2014 Whether this tag is requiring a parent tag </> parser \u2014 The parser of the tag parsing_children \u2014 Whether we should parse then children, or just hold it parsing_self \u2014 Whether this tag needs further parsing, or just hold it prev \u2014 The previous tag of this tag Methods __init_subclass__ ( use_parser ) \u2014 Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser </> __repr__ ( ) \u2014 The representation of the tag </> check_elders ( ) \u2014 Check if required elders are placed </> check_parents ( ) \u2014 Check if we have valid direct or indirect parents </> is_elder ( tag ) \u2014 Check if tag can be an elder of this tag </> is_parent ( tag ) \u2014 Check if tag can be a parent of this tag </> parse ( force ) \u2014 Parse the content of the tag </> parse_children ( base_level ) \u2014 Parse the children if they are hold previouly </> render ( local_vars , global_vars , from_elder ) \u2014 Render the tag </> classmethod","title":"liquid.tags.tag_when.TagWhen"},{"location":"api/liquid.tags.tag_when/#liquidtagstagtaginit_subclass","text":"</> Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser method","title":"liquid.tags.tag.Tag.init_subclass"},{"location":"api/liquid.tags.tag_when/#liquidtagstagtagparse","text":"</> Parse the content of the tag method","title":"liquid.tags.tag.Tag.parse"},{"location":"api/liquid.tags.tag_when/#liquidtagstagtagparse_children","text":"</> Parse the children if they are hold previouly method","title":"liquid.tags.tag.Tag.parse_children"},{"location":"api/liquid.tags.tag_when/#liquidtagstagtagrepr","text":"</> The representation of the tag method","title":"liquid.tags.tag.Tag.repr"},{"location":"api/liquid.tags.tag_when/#liquidtagstagtagis_elder","text":"</> Check if tag can be an elder of this tag method","title":"liquid.tags.tag.Tag.is_elder"},{"location":"api/liquid.tags.tag_when/#liquidtagstagtagis_parent","text":"</> Check if tag can be a parent of this tag method","title":"liquid.tags.tag.Tag.is_parent"},{"location":"api/liquid.tags.tag_when/#liquidtagstagtagcheck_parents","text":"</> Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, continue can be in if . We need to check if it parent for some where like this: {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} method","title":"liquid.tags.tag.Tag.check_parents"},{"location":"api/liquid.tags.tag_when/#liquidtagstagtagcheck_elders","text":"</> Check if required elders are placed method","title":"liquid.tags.tag.Tag.check_elders"},{"location":"api/liquid.tags.tag_when/#liquidtagstagtagrender","text":"</> Render the tag Parameters local_vars \u2014 The local variables global_vars \u2014 The global variables from_elder (optional) \u2014 Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns The rendered string and local variables (maybe modified)","title":"liquid.tags.tag.Tag.render"},{"location":"api/liquid.tags.transformer/","text":"module liquid.tags . transformer </> The transformer for tag segments Classes TagSegment ( *data ) \u2014 Base class for segment classes </> TagSegmentVar \u2014 segment for variables </> TagSegmentComparison \u2014 Comparison segment </> TagSegmentGetItem \u2014 segment for obj[subscript] </> TagSegmentGetAttr \u2014 segment for obj.attr </> TagSegmentRange \u2014 segment for range </> TagSegmentOutput \u2014 Output inside {{ ... }} </> TagSegmentArguments \u2014 Arguments segment </> TagSegmentLogical \u2014 Logical segment </> TagSegmentFilter \u2014 Filter segment </> TagTransformer \u2014 Transform tag segments </> Functions render_segment ( tagseg , local_vars , global_vars ) \u2014 Try to render a segment </> function liquid.tags.transformer . render_segment ( tagseg , local_vars , global_vars ) </> Try to render a segment If it is a tagseg object, render it with the envs, otherwise, return the value itself Parameters local_vars \u2014 The local variables global_vars \u2014 The global_vars Returns The rendered value abstract class liquid.tags.transformer . TagSegment ( *data ) </> Base class for segment classes The parsed objects for the syntax inside a tag Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Render the segment with the given envs </> abstract method render ( local_vars , global_vars ) </> Render the segment with the given envs class liquid.tags.transformer . TagSegmentVar ( *data ) </> Bases liquid.tags.transformer.TagSegment segment for variables Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Get the value of a variable from envs </> method render ( local_vars , global_vars ) </> Get the value of a variable from envs class liquid.tags.transformer . TagSegmentComparison ( *data ) </> Bases liquid.tags.transformer.TagSegment Comparison segment Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Render the segment </> method render ( local_vars , global_vars ) </> Render the segment class liquid.tags.transformer . TagSegmentGetItem ( *data ) </> Bases liquid.tags.transformer.TagSegment segment for obj[subscript] Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Try to get the value of the getitem operation </> method render ( local_vars , global_vars ) </> Try to get the value of the getitem operation class liquid.tags.transformer . TagSegmentGetAttr ( *data ) </> Bases liquid.tags.transformer.TagSegment segment for obj.attr Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Try to get the value of the getattr operation </> method render ( local_vars , global_vars ) </> Try to get the value of the getattr operation class liquid.tags.transformer . TagSegmentRange ( *data ) </> Bases liquid.tags.transformer.TagSegment segment for range Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Render the range segment </> method render ( local_vars , global_vars ) </> Render the range segment class liquid.tags.transformer . TagSegmentOutput ( *data ) </> Bases liquid.tags.transformer.TagSegment Output inside {{ ... }} Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Render the output segment </> method render ( local_vars , global_vars ) </> Render the output segment class liquid.tags.transformer . TagSegmentArguments ( *data ) </> Bases liquid.tags.transformer.TagSegment Arguments segment Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars , as_is ) \u2014 Render the segment </> method render ( local_vars , global_vars , as_is=False ) </> Render the segment Parameters as_is (optional) \u2014 Whether render the non-keyword arguments as-is or treat them as variables Returns Rendered non-keyword and keyword arguments class liquid.tags.transformer . TagSegmentLogical ( *data ) </> Bases liquid.tags.transformer.TagSegment Logical segment Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Render the segment with the given envs </> method render ( local_vars , global_vars ) </> Render the segment with the given envs class liquid.tags.transformer . TagSegmentFilter ( *data ) </> Bases liquid.tags.transformer.TagSegment Filter segment Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Render the segment with the given envs </> method render ( local_vars , global_vars ) </> Render the segment with the given envs class liquid.tags.transformer . TagTransformer ( visit_tokens=False ) </> Bases lark.visitors.Transformer lark.visitors._Decoratable Transform tag segments Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> comparison ( expr , op , expr2 ) \u2014 rule comparison: comparison: atom (_comp_op atom)? </> range ( token ) \u2014 Ranges </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method transform ( tree ) </> Transform the given tree, and return the final result method __mul__ ( other ) </> Chain two transformers together, returning a new transformer. method __default__ ( data , children , meta ) </> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method __default_token__ ( token ) </> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method range ( token ) </> Ranges method comparison ( expr , op=None , expr2=None ) </> rule comparison: comparison: atom (_comp_op atom)? method varname ( vname ) </> Keep the token information for tracking method argvalue ( test1 , test2=NOTHING ) </> rule argvalue: test (\"=\" test)?","title":"liquid.tags.transformer"},{"location":"api/liquid.tags.transformer/#liquidtagstransformer","text":"</> The transformer for tag segments Classes TagSegment ( *data ) \u2014 Base class for segment classes </> TagSegmentVar \u2014 segment for variables </> TagSegmentComparison \u2014 Comparison segment </> TagSegmentGetItem \u2014 segment for obj[subscript] </> TagSegmentGetAttr \u2014 segment for obj.attr </> TagSegmentRange \u2014 segment for range </> TagSegmentOutput \u2014 Output inside {{ ... }} </> TagSegmentArguments \u2014 Arguments segment </> TagSegmentLogical \u2014 Logical segment </> TagSegmentFilter \u2014 Filter segment </> TagTransformer \u2014 Transform tag segments </> Functions render_segment ( tagseg , local_vars , global_vars ) \u2014 Try to render a segment </> function","title":"liquid.tags.transformer"},{"location":"api/liquid.tags.transformer/#liquidtagstransformerrender_segment","text":"</> Try to render a segment If it is a tagseg object, render it with the envs, otherwise, return the value itself Parameters local_vars \u2014 The local variables global_vars \u2014 The global_vars Returns The rendered value abstract class","title":"liquid.tags.transformer.render_segment"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegment","text":"</> Base class for segment classes The parsed objects for the syntax inside a tag Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Render the segment with the given envs </> abstract method","title":"liquid.tags.transformer.TagSegment"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentrender","text":"</> Render the segment with the given envs class","title":"liquid.tags.transformer.TagSegment.render"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentvar","text":"</> Bases liquid.tags.transformer.TagSegment segment for variables Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Get the value of a variable from envs </> method","title":"liquid.tags.transformer.TagSegmentVar"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentvarrender","text":"</> Get the value of a variable from envs class","title":"liquid.tags.transformer.TagSegmentVar.render"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentcomparison","text":"</> Bases liquid.tags.transformer.TagSegment Comparison segment Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Render the segment </> method","title":"liquid.tags.transformer.TagSegmentComparison"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentcomparisonrender","text":"</> Render the segment class","title":"liquid.tags.transformer.TagSegmentComparison.render"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentgetitem","text":"</> Bases liquid.tags.transformer.TagSegment segment for obj[subscript] Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Try to get the value of the getitem operation </> method","title":"liquid.tags.transformer.TagSegmentGetItem"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentgetitemrender","text":"</> Try to get the value of the getitem operation class","title":"liquid.tags.transformer.TagSegmentGetItem.render"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentgetattr","text":"</> Bases liquid.tags.transformer.TagSegment segment for obj.attr Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Try to get the value of the getattr operation </> method","title":"liquid.tags.transformer.TagSegmentGetAttr"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentgetattrrender","text":"</> Try to get the value of the getattr operation class","title":"liquid.tags.transformer.TagSegmentGetAttr.render"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentrange","text":"</> Bases liquid.tags.transformer.TagSegment segment for range Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Render the range segment </> method","title":"liquid.tags.transformer.TagSegmentRange"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentrangerender","text":"</> Render the range segment class","title":"liquid.tags.transformer.TagSegmentRange.render"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentoutput","text":"</> Bases liquid.tags.transformer.TagSegment Output inside {{ ... }} Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Render the output segment </> method","title":"liquid.tags.transformer.TagSegmentOutput"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentoutputrender","text":"</> Render the output segment class","title":"liquid.tags.transformer.TagSegmentOutput.render"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentarguments","text":"</> Bases liquid.tags.transformer.TagSegment Arguments segment Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars , as_is ) \u2014 Render the segment </> method","title":"liquid.tags.transformer.TagSegmentArguments"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentargumentsrender","text":"</> Render the segment Parameters as_is (optional) \u2014 Whether render the non-keyword arguments as-is or treat them as variables Returns Rendered non-keyword and keyword arguments class","title":"liquid.tags.transformer.TagSegmentArguments.render"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentlogical","text":"</> Bases liquid.tags.transformer.TagSegment Logical segment Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Render the segment with the given envs </> method","title":"liquid.tags.transformer.TagSegmentLogical"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentlogicalrender","text":"</> Render the segment with the given envs class","title":"liquid.tags.transformer.TagSegmentLogical.render"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentfilter","text":"</> Bases liquid.tags.transformer.TagSegment Filter segment Attributes data \u2014 The data to parser data \u2014 Get the data </> Methods render ( local_vars , global_vars ) \u2014 Render the segment with the given envs </> method","title":"liquid.tags.transformer.TagSegmentFilter"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagsegmentfilterrender","text":"</> Render the segment with the given envs class","title":"liquid.tags.transformer.TagSegmentFilter.render"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagtransformer","text":"</> Bases lark.visitors.Transformer lark.visitors._Decoratable Transform tag segments Parameters visit_tokens (optional) \u2014 Should the transformer visit tokens in addition to rules. Setting this to False is slightly faster. Defaults to True . (For processing ignored tokens, use the lexer_callbacks options) Methods __default__ ( data , children , meta ) \u2014 Default function that is called if there is no attribute matching data </> __default_token__ ( token ) \u2014 Default function that is called if there is no attribute matching token.type </> __mul__ ( other ) \u2014 Chain two transformers together, returning a new transformer. </> argvalue ( test1 , test2 ) \u2014 rule argvalue: test (\"=\" test)? </> comparison ( expr , op , expr2 ) \u2014 rule comparison: comparison: atom (_comp_op atom)? </> range ( token ) \u2014 Ranges </> transform ( tree ) \u2014 Transform the given tree, and return the final result </> varname ( vname ) \u2014 Keep the token information for tracking </> method","title":"liquid.tags.transformer.TagTransformer"},{"location":"api/liquid.tags.transformer/#larkvisitorstransformertransform","text":"</> Transform the given tree, and return the final result method","title":"lark.visitors.Transformer.transform"},{"location":"api/liquid.tags.transformer/#larkvisitorstransformermul","text":"</> Chain two transformers together, returning a new transformer. method","title":"lark.visitors.Transformer.mul"},{"location":"api/liquid.tags.transformer/#larkvisitorstransformerdefault","text":"</> Default function that is called if there is no attribute matching data Can be overridden. Defaults to creating a new copy of the tree node (i.e. return Tree(data, children, meta) ) method","title":"lark.visitors.Transformer.default"},{"location":"api/liquid.tags.transformer/#larkvisitorstransformerdefault_token","text":"</> Default function that is called if there is no attribute matching token.type Can be overridden. Defaults to returning the token as-is. method","title":"lark.visitors.Transformer.default_token"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagtransformerrange","text":"</> Ranges method","title":"liquid.tags.transformer.TagTransformer.range"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagtransformercomparison","text":"</> rule comparison: comparison: atom (_comp_op atom)? method","title":"liquid.tags.transformer.TagTransformer.comparison"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagtransformervarname","text":"</> Keep the token information for tracking method","title":"liquid.tags.transformer.TagTransformer.varname"},{"location":"api/liquid.tags.transformer/#liquidtagstransformertagtransformerargvalue","text":"</> rule argvalue: test (\"=\" test)?","title":"liquid.tags.transformer.TagTransformer.argvalue"},{"location":"api/liquid.utils/","text":"module liquid . utils </> Utilities for liquidpy Classes TemplateMeta \u2014 TemplateMeta(name, path, stream, should_close) </> Nothing \u2014 A unique object to identify a NOTHING other than None </> OptionalTags \u2014 Indicates the arguments are optional </> RequiredTags \u2014 Indicates the arguments are required </> Singleton \u2014 An abstract base class for signleton classes </> Functions analyze_leading_spaces ( string ) \u2014 Analyze the leading spaces of a string </> check_name ( names ) \u2014 Check whether the name is allowed </> excmsg_with_context ( msg , context , parser ) \u2014 Assemble the exception message with context </> find_dir ( path , curr_path ) \u2014 Find the directory by given path </> find_template ( path , curr_path , config_paths ) \u2014 Find the template by given path </> get_tag_parser ( start , grammar , transformer , base_grammar ) \u2014 Get the lark parser for tags </> shorten ( text , width , placeholder ) \u2014 Wrap textwrap.shorten </> template_meta ( template ) \u2014 Get the metadata of a template </> class liquid.utils . TemplateMeta ( name , path , stream , should_close ) </> Bases tuple TemplateMeta(name, path, stream, should_close) class liquid.utils . Nothing ( ) </> A unique object to identify a NOTHING other than None Lark transformers sometimes can pass None or nothing when no terminals matched. To distinguish this situation, we need something other than None. class liquid.utils . OptionalTags ( *args ) </> Bases liquid.utils._PositionalTuple tuple Indicates the arguments are optional class liquid.utils . RequiredTags ( *args ) </> Bases liquid.utils._PositionalTuple tuple Indicates the arguments are required class liquid.utils . Singleton ( *args , **kwargs ) </> An abstract base class for signleton classes To prevent the init to run again for initialized object from new , we have a property _initialized to inidicate whether the object has been initialized already. function liquid.utils . template_meta ( template ) </> Get the metadata of a template This is to try to normalize the template for liquid into the name of the template, the IO object and whether we should close that IO object. The IO object should be closed when a valid path is passed. Parameters template \u2014 The template Returns A tuple of the template name, the IO object and whether we should close that IO object function liquid.utils . check_name ( names ) </> Check whether the name is allowed Raises LiquidNameError \u2014 when names contains name that is not allowed function liquid.utils . analyze_leading_spaces ( string ) </> Analyze the leading spaces of a string Parameters string \u2014 The string to analyze Returns A tuple of two integers. Number of new lines and the number spaces that last new line has function liquid.utils . shorten ( text , width , placeholder=' ...' ) </> Wrap textwrap.shorten Since textwrap.shorten('abcdefg', 5, placeholder='.') will return '.' But what we want is 'abcd.' function liquid.utils . excmsg_with_context ( msg , context , parser ) </> Assemble the exception message with context Parameters context \u2014 The context parser \u2014 The parser Returns The assembled exception message function liquid.utils . get_tag_parser ( start , grammar , transformer , base_grammar=None ) </> Get the lark parser for tags Parameters start \u2014 The start rule name grammar \u2014 The new grammar transformer \u2014 The transformer for the parser base_grammar (optional) \u2014 The base grammar Returns The lark object for parsing function liquid.utils . find_template ( path , curr_path , config_paths ) </> Find the template by given path curr_path will always be the first one to look up. If it is None (template from a string, for example), current working directory will be used. Parameters path \u2014 The path to look up curr_path \u2014 The path where current template is located config_paths \u2014 The paths from configuration Returns The path found either directory. function liquid.utils . find_dir ( path , curr_path ) </> Find the directory by given path If path is relative, find one relative to curr_path. Parameters path \u2014 The path to look up curr_path \u2014 the path where current template is located Returns The directory found","title":"liquid.utils"},{"location":"api/liquid.utils/#liquidutils","text":"</> Utilities for liquidpy Classes TemplateMeta \u2014 TemplateMeta(name, path, stream, should_close) </> Nothing \u2014 A unique object to identify a NOTHING other than None </> OptionalTags \u2014 Indicates the arguments are optional </> RequiredTags \u2014 Indicates the arguments are required </> Singleton \u2014 An abstract base class for signleton classes </> Functions analyze_leading_spaces ( string ) \u2014 Analyze the leading spaces of a string </> check_name ( names ) \u2014 Check whether the name is allowed </> excmsg_with_context ( msg , context , parser ) \u2014 Assemble the exception message with context </> find_dir ( path , curr_path ) \u2014 Find the directory by given path </> find_template ( path , curr_path , config_paths ) \u2014 Find the template by given path </> get_tag_parser ( start , grammar , transformer , base_grammar ) \u2014 Get the lark parser for tags </> shorten ( text , width , placeholder ) \u2014 Wrap textwrap.shorten </> template_meta ( template ) \u2014 Get the metadata of a template </> class","title":"liquid.utils"},{"location":"api/liquid.utils/#liquidutilstemplatemeta","text":"</> Bases tuple TemplateMeta(name, path, stream, should_close) class","title":"liquid.utils.TemplateMeta"},{"location":"api/liquid.utils/#liquidutilsnothing","text":"</> A unique object to identify a NOTHING other than None Lark transformers sometimes can pass None or nothing when no terminals matched. To distinguish this situation, we need something other than None. class","title":"liquid.utils.Nothing"},{"location":"api/liquid.utils/#liquidutilsoptionaltags","text":"</> Bases liquid.utils._PositionalTuple tuple Indicates the arguments are optional class","title":"liquid.utils.OptionalTags"},{"location":"api/liquid.utils/#liquidutilsrequiredtags","text":"</> Bases liquid.utils._PositionalTuple tuple Indicates the arguments are required class","title":"liquid.utils.RequiredTags"},{"location":"api/liquid.utils/#liquidutilssingleton","text":"</> An abstract base class for signleton classes To prevent the init to run again for initialized object from new , we have a property _initialized to inidicate whether the object has been initialized already. function","title":"liquid.utils.Singleton"},{"location":"api/liquid.utils/#liquidutilstemplate_meta","text":"</> Get the metadata of a template This is to try to normalize the template for liquid into the name of the template, the IO object and whether we should close that IO object. The IO object should be closed when a valid path is passed. Parameters template \u2014 The template Returns A tuple of the template name, the IO object and whether we should close that IO object function","title":"liquid.utils.template_meta"},{"location":"api/liquid.utils/#liquidutilscheck_name","text":"</> Check whether the name is allowed Raises LiquidNameError \u2014 when names contains name that is not allowed function","title":"liquid.utils.check_name"},{"location":"api/liquid.utils/#liquidutilsanalyze_leading_spaces","text":"</> Analyze the leading spaces of a string Parameters string \u2014 The string to analyze Returns A tuple of two integers. Number of new lines and the number spaces that last new line has function","title":"liquid.utils.analyze_leading_spaces"},{"location":"api/liquid.utils/#liquidutilsshorten","text":"</> Wrap textwrap.shorten Since textwrap.shorten('abcdefg', 5, placeholder='.') will return '.' But what we want is 'abcd.' function","title":"liquid.utils.shorten"},{"location":"api/liquid.utils/#liquidutilsexcmsg_with_context","text":"</> Assemble the exception message with context Parameters context \u2014 The context parser \u2014 The parser Returns The assembled exception message function","title":"liquid.utils.excmsg_with_context"},{"location":"api/liquid.utils/#liquidutilsget_tag_parser","text":"</> Get the lark parser for tags Parameters start \u2014 The start rule name grammar \u2014 The new grammar transformer \u2014 The transformer for the parser base_grammar (optional) \u2014 The base grammar Returns The lark object for parsing function","title":"liquid.utils.get_tag_parser"},{"location":"api/liquid.utils/#liquidutilsfind_template","text":"</> Find the template by given path curr_path will always be the first one to look up. If it is None (template from a string, for example), current working directory will be used. Parameters path \u2014 The path to look up curr_path \u2014 The path where current template is located config_paths \u2014 The paths from configuration Returns The path found either directory. function","title":"liquid.utils.find_template"},{"location":"api/liquid.utils/#liquidutilsfind_dir","text":"</> Find the directory by given path If path is relative, find one relative to curr_path. Parameters path \u2014 The path to look up curr_path \u2014 the path where current template is located Returns The directory found","title":"liquid.utils.find_dir"},{"location":"api/source/liquid.config/","text":"SOURCE CODE liquid. config DOCS \"\"\"The configuration for liquidpy Attributes: LIQUID_LOGGER_NAME: The name of the logger LIQUID_LOG_INDENT: Indentions to show the tree structure in logging LIQUID_FILTERS_ENVNAME: The variable containing all filters LIQUID_EXC_MAX_STACKS: The stacks to show in exceptions when debug is on LIQUID_EXC_CODE_CONTEXT: The number of context lines to show codes in exceptions when debug is on DEFAULT_CONFIG: The default configuration \"\"\" import logging from diot import Diot # some constants LIQUID_LOGGER_NAME = 'LIQUID' # type: str LIQUID_LOG_INDENT = ' ' # type: str LIQUID_FILTERS_ENVNAME = '__LIQUID_FILTERS__' # type: str LIQUID_EXC_MAX_STACKS = 5 # type: int LIQUID_EXC_CODE_CONTEXT = 3 # type: int DEFAULT_CONFIG = Diot ( mode = 'standard' , strict = True , debug = False , cache = False , extends_dir = [], include_dir = [] ) # type: Diot class Config ( Diot ): DOCS \"\"\"The configurations for liquidpy\"\"\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) # set the default if not set self |= DEFAULT_CONFIG | self def update_logger ( self ): DOCS # type: (bool) -> None \"\"\"Update the logger configuration according to the configuration \"\"\" from .utils import logger if not self . debug : logger . setLevel ( logging . CRITICAL ) else : logger . setLevel ( logging . DEBUG )","title":"liquid.config"},{"location":"api/source/liquid.exceptions/","text":"SOURCE CODE liquid. exceptions DOCS \"\"\"Exceptions for liquidpy, all based on `LiquidException`\"\"\" class LiquidException ( Exception ): DOCS \"\"\"The base class for all liquidpy exceptions\"\"\" class LiquidNameError ( LiquidException ): DOCS \"\"\"When wrong name or preserved keyword passed\"\"\" class LiquidFilterRegistryException ( LiquidException ): DOCS \"\"\"Raises when operate the filter registry incorrectly\"\"\" class LiquidTagRegistryException ( LiquidException ): DOCS \"\"\"Raises when operate the tag registry incorrectly\"\"\" class LiquidSyntaxError ( LiquidException ): DOCS \"\"\"Template syntax error Args: msg: The message for the exception context: The context parser: The parser \"\"\" def __init__ ( self , msg , context = None , parser = None ): # type: (str, Diot, Parser) -> None from .utils import excmsg_with_context super () . __init__ ( excmsg_with_context ( msg , context , parser )) class LiquidRenderError ( LiquidException ): DOCS \"\"\"Template render error Args: msg: The message for the exception context: The context parser: The parser \"\"\" def __init__ ( self , msg , context = None , parser = None ): # type: (str, Diot, Parser) -> None from .utils import excmsg_with_context super () . __init__ ( excmsg_with_context ( msg , context , parser ))","title":"liquid.exceptions"},{"location":"api/source/liquid.filters/","text":"SOURCE CODE liquid. filters DOCS \"\"\"The filters used in liquidpy Attributes: filter_manager: The filter manager \"\"\" import math import html from .utils import Singleton from .exceptions import LiquidFilterRegistryException class FilterManager ( Singleton ): DOCS \"\"\"A manager for filters Attributes: INSTANCE: The instance of the class, since it's a signleton filters: The filters database \"\"\" INSTANCE = None # type: FilterManager filters = {} # type: Dict[str, Callable] def register ( self , name_or_filter = None , mode = 'standard' ): DOCS # type: (Optional[Union[str, Callable]], bool) -> Optional[Callable] \"\"\"Register a filter This can be used as a decorator >>> @filter_manager.register >>> def add(a, b): >>> return a+b >>> # register it with an alias: >>> @filter_manager.register('addfunc') >>> def add(a, b): >>> return a+b Args: name_or_filter: The filter to register if name is given, will be treated as alias mode: Whether do it for given mode Returns: The registered function or the decorator \"\"\" # if mode == 'jekyll': # from .jekyll.filter_manager import filter_manager as filtermgr # return filtermgr.register(name_or_filter) if mode == 'python' : from .python.filters import filter_manager as filtermgr return filtermgr . register ( name_or_filter ) def decorator ( filterfunc ): name = filterfunc . __name__ name = [ name ] if name_or_filter and name_or_filter is not filterfunc : names = name_or_filter if isinstance ( names , str ): names = ( nam . strip () for nam in names . split ( ',' )) name = names for nam in name : self . __class__ . filters [ nam ] = filterfunc return filterfunc if callable ( name_or_filter ): return decorator ( name_or_filter ) return decorator def unregister ( self , name , mode = 'standard' ): DOCS # type: (str, str) -> Optional[Callable] \"\"\"Unregister a filter Args: name: The name of the filter to unregister mode: Whether do it for given mode Returns: The unregistered filter or None if name does not exist \"\"\" # if mode == 'jekyll': # from .jekyll.filter_manager import filter_manager as filtermgr # return filtermgr.unregister(name) if mode == 'python' : from .python.filters import filter_manager as filtermgr return filtermgr . unregister ( name ) try : return self . __class__ . filters . pop ( name ) except KeyError : raise LiquidFilterRegistryException ( f 'No such filter: { name !r} ' ) from None # pylint: disable=invalid-name filter_manager = FilterManager () # type: FilterManager class EmptyDrop : DOCS \"\"\"The EmptyDrop class borrowed from liquid\"\"\" def __init__ ( self ): setattr ( self , 'empty?' , True ) def __str__ ( self ): return '' def __eq__ ( self , other ): return not bool ( other ) def __ne__ ( self , other ): return not self . __eq__ ( other ) def __bool__ ( self ): return False def _get_prop ( obj , prop ): \"\"\"Get the property of the object, allow via getitem\"\"\" try : return obj [ prop ] except ( TypeError , KeyError ): return getattr ( obj , prop ) filter_manager . register ( str . capitalize ) filter_manager . register ( abs ) filter_manager . register ( round ) filter_manager . register ( 'concat' )( list . __add__ ) filter_manager . register ( 'at_least' )( max ) filter_manager . register ( 'at_most' )( min ) filter_manager . register ( 'downcase' )( str . lower ) filter_manager . register ( 'upcase' )( str . upper ) filter_manager . register ( html . escape ) filter_manager . register ( str . lstrip ) filter_manager . register ( str . rstrip ) filter_manager . register ( str . strip ) filter_manager . register ( str . replace ) filter_manager . register ( 'size' )( len ) @filter_manager . register DOCS def split ( base , sep ): \"\"\"Split a string into a list If the sep is empty, return the list of characters \"\"\" if not sep : return list ( base ) return base . split ( sep ) @filter_manager . register DOCS def append ( base , suffix ): \"\"\"Append a suffix to a string\"\"\" return f \" { base }{ suffix } \" @filter_manager . register DOCS def prepend ( base , prefix ): \"\"\"Prepend a prefix to a string\"\"\" return f \" { prefix }{ base } \" @filter_manager . register DOCS def times ( base , sep ): \"\"\"Implementation of * \"\"\" return base * sep @filter_manager . register DOCS def minus ( base , sep ): \"\"\"Implementation of - \"\"\" return base - sep @filter_manager . register DOCS def plus ( base , sep ): \"\"\"Implementation of + \"\"\" return base + sep @filter_manager . register DOCS def modulo ( base , sep ): \"\"\"Implementation of % \"\"\" return base % sep @filter_manager . register DOCS def ceil ( base ): \"\"\"Get the ceil of a number\"\"\" return math . ceil ( float ( base )) @filter_manager . register DOCS def floor ( base ): \"\"\"Get the floor of a number\"\"\" return math . floor ( float ( base )) @filter_manager . register ( 'date' ) DOCS def liquid_date ( base , fmt ): \"\"\"Format a date/datetime\"\"\" from datetime import datetime if base == \"now\" : dtime = datetime . now () elif base == \"today\" : dtime = datetime . today () else : from dateutil import parser dtime = parser . parse ( base ) return dtime . strftime ( fmt ) @filter_manager . register DOCS def default ( base , deft ): \"\"\"Return the deft value if base is not set. Otherwise, return base\"\"\" if base == 0.0 : return base return base or deft @filter_manager . register DOCS def divided_by ( base , dvdby ): \"\"\"Implementation of / or // \"\"\" if isinstance ( dvdby , int ): return base // dvdby return base / dvdby @filter_manager . register DOCS def escape_once ( base ): \"\"\"Escapse html characters only once of the string\"\"\" return html . escape ( html . unescape ( base )) @filter_manager . register DOCS def newline_to_br ( base ): \"\"\"Replace newline with `<br />`\"\"\" return base . replace ( ' \\n ' , '<br />' ) @filter_manager . register DOCS def remove ( base , string ): \"\"\"Remove a substring from a string\"\"\" return base . replace ( string , '' ) @filter_manager . register DOCS def remove_first ( base , string ): \"\"\"Remove the first substring from a string\"\"\" return base . replace ( string , '' , 1 ) @filter_manager . register DOCS def replace_first ( base , old , new ): \"\"\"Replace the first substring with new string\"\"\" return base . replace ( old , new , 1 ) @filter_manager . register DOCS def reverse ( base ): \"\"\"Get the reversed list\"\"\" if not base : return EmptyDrop () return list ( reversed ( base )) @filter_manager . register DOCS def sort ( base ): \"\"\"Get the sorted list\"\"\" if not base : return EmptyDrop () return list ( sorted ( base )) @filter_manager . register DOCS def sort_natural ( base ): \"\"\"Get the sorted list in a case-insensitive manner\"\"\" if not base : return EmptyDrop () return list ( sorted ( base , key = str . casefold )) @filter_manager . register ( 'slice' ) DOCS def liquid_slice ( base , start , length = 1 ): \"\"\"Slice a list\"\"\" if not base : return EmptyDrop () if start < 0 : start = len ( base ) + start return base [ start : start + length ] @filter_manager . register DOCS def strip_html ( base ): \"\"\"Strip html tags from a string\"\"\" import re # use html parser? return re . sub ( r '<[^>]+>' , '' , base ) @filter_manager . register DOCS def strip_newlines ( base ): \"\"\"Strip newlines from a string\"\"\" return base . replace ( ' \\n ' , '' ) @filter_manager . register DOCS def truncate ( base , length , ellipsis = \"...\" ): \"\"\"Truncate a string\"\"\" lenbase = len ( base ) if length >= lenbase : return base return base [: length - len ( ellipsis )] + ellipsis @filter_manager . register DOCS def truncatewords ( base , length , ellipsis = \"...\" ): \"\"\"Truncate a string by words\"\"\" # do we need to preserve the whitespaces? baselist = base . split () lenbase = len ( baselist ) if length >= lenbase : return base # instead of collapsing them into just a single space? return \" \" . join ( baselist [: length ]) + ellipsis @filter_manager . register DOCS def uniq ( base ): \"\"\"Get the unique elements from a list\"\"\" if not base : return EmptyDrop () ret = [] for bas in base : if not bas in ret : ret . append ( bas ) return ret @filter_manager . register DOCS def url_decode ( base ): \"\"\"Url-decode a string\"\"\" try : from urllib import unquote except ImportError : from urllib.parse import unquote return unquote ( base ) @filter_manager . register DOCS def url_encode ( base ): \"\"\"Url-encode a string\"\"\" try : from urllib import urlencode except ImportError : from urllib.parse import urlencode return urlencode ({ '' : base })[ 1 :] @filter_manager . register DOCS def where ( base , prop , value ): \"\"\"Query a list of objects with a given property value\"\"\" ret = [ bas for bas in base if _get_prop ( bas , prop ) == value ] return ret or EmptyDrop () @filter_manager . register ( 'map' ) DOCS def liquid_map ( base , prop ): \"\"\"Map a property to a list of objects\"\"\" return [ _get_prop ( bas , prop ) for bas in base ] @filter_manager . register DOCS def join ( base , sep ): \"\"\"Join a list by the sep\"\"\" if isinstance ( base , EmptyDrop ): return '' return sep . join ( base ) @filter_manager . register DOCS def first ( base ): \"\"\"Get the first element of the list\"\"\" if not base : return EmptyDrop () return base [ 0 ] @filter_manager . register DOCS def last ( base ): \"\"\"Get the last element of the list\"\"\" if not base : return EmptyDrop () return base [ - 1 ] @filter_manager . register DOCS def compact ( base ): \"\"\"Remove empties from a list\"\"\" ret = [ bas for bas in base if bas ] return ret or EmptyDrop ()","title":"liquid.filters"},{"location":"api/source/liquid.liquid/","text":"SOURCE CODE liquid. liquid DOCS \"\"\"Provides Liquid, LiquidPython and LiquidJekyll classes\"\"\" from .config import Config , LIQUID_FILTERS_ENVNAME from .utils import template_meta , check_name from .parser import Parser from .filters import filter_manager , EmptyDrop # from .jekyll.parser import Parser as ParserJekyll # from .jekyll.filters import filter_manager as filter_manager_jekyll from .python.parser import Parser as ParserPython from .python.filters import filter_manager as filter_manager_python class Liquid : DOCS \"\"\"The main class for external use One could provide a config says `liquid_config['extended'] = True` to switch this object to be initialized as a LiquidPython object. Examples: >>> liq1 = Liquid(\"{{a}}\") >>> liq1.__class__ # -> Liquid >>> liq2 = Liquid(\"{{a}}\", {'mode': 'python'}) >>> liq2.__class__ # -> LiquidPython >>> isinstance(liq2, Liquid) # -> True Attributes: PARSER_CLASS: The root parser class FILTER_MANAGER: The filter manager Args: liquid_template: The template that can be rendered. It could be a string template, a path to a file contains the template or an IO object with the template liquid_config: The configuration for this liquid object - extended: Whether use the extended mode - **envs: Other environment variables for template rendering. \"\"\" PARSER_CLASS = Parser FILTER_MANAGER = filter_manager # pylint: disable=unused-argument def __new__ ( cls , liquid_template , liquid_config = None , ** envs ): DOCS # type: (Union[str, Path, IO], Optional[Dict[str, Any]], Any) -> Liquid \"\"\"Works as a router to determine returning a Liquid or LiquidPython object according to liquid_config['extended'] \"\"\" mode = ( liquid_config . get ( 'mode' ) if liquid_config else None ) # type: str # if mode == 'jekyll': # return LiquidJekyll.__new__(LiquidJekyll) if mode == 'python' : return LiquidPython . __new__ ( LiquidPython ) return super () . __new__ ( cls ) # pylint: enable=unused-argument def __init__ ( self , liquid_template , liquid_config = None , ** envs ): # type: (Union[str, Path, IO], Optional[Dict[str, Any]], Any) -> None # since __new__ returns an object anyway is a Liquid object # we will need to pass handling to LiquidPython itself check_name ( envs ) self . envs = envs self . config = Config ( liquid_config or {}) self . config . update_logger () self . meta = template_meta ( liquid_template ) self . parsed = self . _from_cache ( liquid_template ) # pylint: disable=unused-argument def _from_cache ( self , liquid_template ): # (Union[str, Path, IO]) -> Type[Parser] \"\"\"Try to the parsed object from the cache // Todo: When config.cache is False, don't cache When True, try to cache it in memory, otherwise a directory should be specified, objects are cached there \"\"\" parsed = self . PARSER_CLASS ( self . meta , self . config ) . parse () return parsed # pylint: enable=unused-argument def __del__ ( self ): try : if self . meta . should_close : self . meta . stream . close () except AttributeError : # pragma: no cover pass def _update_context ( self , context ): # type: (Dict[str, Any]) -> Dict[str, Any] \"\"\"Update the given context based on pre-set envs\"\"\" check_name ( context ) envs = self . envs . copy () # type: Dict[str, Any] envs . update ( context ) return envs def _render ( self , local_vars : dict , global_vars : dict ) -> str : # render and return try : return self . parsed . render ( local_vars , global_vars )[ 0 ] finally : # debug mode needs stream to print stack details if self . meta . should_close : self . meta . stream . close () def render ( self , ** context ): DOCS # type: (Any) -> str \"\"\"Render the template with given context The parsed is a TagRoot object, whose render gives a string Args: context: The context used to render the template Returns: The rendered content \"\"\" context = self . _update_context ( context ) global_context = context . copy () global_context [ LIQUID_FILTERS_ENVNAME ] = self . FILTER_MANAGER . filters # liquid's EmptyDrop object global_context [ 'empty' ] = EmptyDrop () return self . _render ( context , global_context ) # class LiquidJekyll(Liquid): # \"\"\"Support for extended mode of liquidpy\"\"\" # PARSER_CLASS = ParserJekyll # FILTER_MANAGER = filter_manager_jekyll # __new__ = object.__new__ # def __init__(self, liquid_template, liquid_config=None, **envs): # # type: (Union[str, Path, IO], Optional[Dict[str, Any]], Any) -> None # # pylint: disable=super-init-not-called # self._init(liquid_template, liquid_config, **envs) class LiquidPython ( Liquid ): DOCS # pylint: disable=too-few-public-methods \"\"\"Support for extended mode of liquidpy\"\"\" PARSER_CLASS = ParserPython FILTER_MANAGER = filter_manager_python # pylint: disable=signature-differs,unused-argument,arguments-differ def __new__ ( cls , * args , ** kwargs ): DOCS return object . __new__ ( cls ) def render ( self , ** context ): DOCS # type: (Any) -> str \"\"\"Render the template with given context The parsed is a TagRoot object, whose render gives a string Args: context: The context used to render the template Returns: The rendered content \"\"\" context = self . _update_context ( context ) global_context = __builtins__ . copy () global_context . update ( context ) global_context [ LIQUID_FILTERS_ENVNAME ] = self . FILTER_MANAGER . filters return self . _render ( context , global_context )","title":"liquid.liquid"},{"location":"api/source/liquid/","text":"SOURCE CODE liquid DOCS \"\"\"A port of liquid template engine in python\"\"\" from .liquid import Liquid from .filters import filter_manager from .tags import tag_manager , Tag from .exceptions import ( LiquidException , LiquidTagRegistryException , LiquidFilterRegistryException , LiquidNameError , LiquidSyntaxError , LiquidRenderError , ) # python mode from .liquid import LiquidPython from .python.tags import tag_manager as tag_manager_python , Tag as TagPython from .python.filters import filter_manager as filter_manager_python __version__ = '0.6.3'","title":"liquid"},{"location":"api/source/liquid.nodes/","text":"SOURCE CODE liquid. nodes DOCS \"\"\"Definition of nodes and node scanner\"\"\" from .config import LIQUID_LOG_INDENT from .tags import tag_manager from .utils import analyze_leading_spaces , logger from .exceptions import LiquidSyntaxError class Node : DOCS \"\"\"A node of liquidpy Serves as a bridge between parser and tags for scanning Should be one of: - literal node: ... - output node: {{ ... }} - comment node: {# ... #} - tag node: {% ... %} Attributes: OPEN_TAG: The open tags for the node CLOSE_TAG: The close tags for the node TAG_MANAGER: The tag manager name: The name of the node open_compact: Whether open tag is compact close_compact: Whether close tag is compact content: The content of the node context: The context of the node Args: content: The content of the node context: The context of the node parser: The parser open_tag: The open tag of the node close_tag: The close tag of the node \"\"\" OPEN_TAG = () # type: Tuple[str] CLOSE_TAG = () # type: Tuple[str] name = '' # type: str __slots__ = ( 'open_compact' , 'close_compact' , 'context' , 'content' , '_tag' ) def __init__ ( self , # pylint:disable=too-many-arguments content , context , parser , open_tag = '' , close_tag = '' ): # type: (str, str, str, Optional[Diot], \"Parser\") -> None self . open_compact = '-' in open_tag self . close_compact = '-' in close_tag self . context = context self . content = content self . _update_context ( open_tag ) tag = self . _get_tag ( parser ) self . _tag = tag def __init_subclass__ ( cls , tag_manager = tag_manager ): DOCS # pylint: disable=redefined-outer-name cls . TAG_MANAGER = tag_manager @property DOCS def tag ( self ): # type: () -> \"Tag\" \"\"\"Get the tag from the node\"\"\" return self . _tag @property DOCS def raw ( self ): # type: () -> bool \"\"\"Check whether this node is in raw mode\"\"\" return self . tag . RAW def _update_context ( self , open_tag ): \"\"\"Update the context to the start of the content\"\"\" def _get_tag ( self , parser ): # type: (\"Parser\") -> \"Tag\" \"\"\"Get the tag Args: parser: The parser Returns: The tag that can is associated with this node \"\"\" tag_class = self . TAG_MANAGER . get ( self . name ) if not tag_class : try : self . context . lineno = self . _tagname_line self . context . colno = self . _tagname_column - 1 except AttributeError : # pragma: no cover pass raise LiquidSyntaxError ( f 'No such tag: { self . name } ' , self . context , parser ) name = self . name content = self . content if name . startswith ( 'end' ): content = name [ 3 :] return tag_class ( name , content , self . context , self . open_compact , self . close_compact , parser ) class NodeLiteral ( Node ): DOCS \"\"\"The literal node\"\"\" name = \"LITERAL\" class NodeOutput ( Node ): DOCS \"\"\"The output node\"\"\" OPEN_TAG = '{{' , '{{-' CLOSE_TAG = '}}' , '-}}' name = \"OUTPUT\" def _update_context ( self , open_tag ): self . context . colno += len ( open_tag ) nnewline , nspaces = analyze_leading_spaces ( self . content ) if nnewline > 0 : self . context . lineno += nnewline self . context . colno = nspaces else : self . context . colno += nspaces self . content = self . content . strip () class NodeTag ( Node ): DOCS \"\"\"The opening of a tag node\"\"\" OPEN_TAG = '{%' , '{%-' CLOSE_TAG = '%}' , '-%}' def __init__ ( self , * args , ** kwargs ): self . _tagname_line = self . _tagname_column = 0 super () . __init__ ( * args , ** kwargs ) def _update_context ( self , open_tag ): NodeOutput . _update_context ( self , open_tag ) self . _tagname_line = self . context . lineno self . _tagname_column = self . context . colno splits = self . content . strip () . split ( maxsplit = 1 ) # type: List[str] self . name = splits [ 0 ] # type: str content = splits [ 1 ] if len ( splits ) > 1 else '' self . context . colno += len ( self . name ) n_newline , n_spaces = analyze_leading_spaces ( self . content [ len ( self . name ):] ) if n_newline > 0 : self . context . lineno += n_newline self . context . colno = n_spaces else : self . context . colno += n_spaces self . content = content class NodeScanner : DOCS # pylint: disable=too-many-instance-attributes,too-few-public-methods \"\"\"Scanning for the nodes Attributes: LITERAL: The literal node NODES: The possible nodes OPEN_CHARS: The start characters of open tags for those nodes This is to speed up the lookup for a potential hit of a node context: The context of the potential node open_context: Where the open tag hits hit: The node we hit This will be only fit when there is only one type of node hit literal_buffer: The buffer for literal nodes This will not consume the potential node opentag_buffer: The buffer for open tags closetag_buffer: The buffer for close tags content_buffer: The buffer for content of potential nodes escape: Whether the previous character is an escape (`\\\\`) rawtag: The matched raw tag name parser: The parser \"\"\" __slots__ = ( 'context' , 'open_context' , 'hit' , 'literal_buffer' , 'opentag_buffer' , 'content_buffer' , 'closetag_buffer' , 'escape' , 'rawtag' , 'parser' ) LITERAL = NodeLiteral # type: NodeLiteral NODES = ( NodeOutput , NodeTag ) # type: Tuple[Type[Node]] OPEN_CHARS = set ( tag [ 0 ] for node in NODES for tag in node . OPEN_TAG ) # type: Set[str] def __init__ ( self , context , parser ): # type: (Diot, \"Parser\") -> None self . context = context # type: Diot self . open_context = None # type: Diot self . hit = None # type: Optional[Node] self . literal_buffer = '' # type: str self . opentag_buffer = None # type: str self . closetag_buffer = None # type: str self . content_buffer = None # type: str self . escape = None # type: bool self . rawtag = None # type: Optional[str] self . parser = parser # type: Parser self . _clear_state () def _clear_state ( self ): \"\"\"Clear the hit state.\"\"\" self . hit = None self . opentag_buffer = '' self . closetag_buffer = '' self . content_buffer = '' def _summarize ( self , end = False ): \"\"\"Summarize the residue\"\"\" # we don't have any node hit, summarize the literal if not self . hit : # context is mutable, have to copy it to keep current context literal = ( self . literal_buffer + self . opentag_buffer if end else self . literal_buffer ) # type: str self . literal_buffer = '' if literal : node = self . LITERAL ( literal , self . open_context , self . parser ) logger . debug ( '[dim italic] %s Found %r [/dim italic]' , self . context . level * LIQUID_LOG_INDENT , node . tag , extra = { \"markup\" : True }) return node return not end # We got a hit, if no closetag hit yet, # we need to summarize previous literals if not self . closetag_buffer : if self . literal_buffer : node = self . LITERAL ( self . literal_buffer , self . open_context , self . parser ) self . literal_buffer = '' logger . debug ( '[dim italic] %s Found %r [/dim italic]' , self . context . level * LIQUID_LOG_INDENT , node . tag , extra = { \"markup\" : True }) self . open_context = self . context . copy () self . open_context . colno -= len ( self . opentag_buffer ) return node if not end : return True if self . closetag_buffer in self . hit . CLOSE_TAG : # let's see if we are inside a raw tag if self . rawtag : # NodeTag if ( not self . hit . name and self . content_buffer . strip () == 'end' + self . rawtag ): self . rawtag = None else : self . literal_buffer += ( self . opentag_buffer + self . content_buffer + self . closetag_buffer ) logger . debug ( '[dim italic] %s Gave up %r (inside raw tag)' '[/dim italic]' , self . context . level * LIQUID_LOG_INDENT , self . hit . __name__ , extra = { \"markup\" : True }) self . _clear_state () if not end : return True node = self . hit ( self . content_buffer , self . open_context , self . parser , self . opentag_buffer , self . closetag_buffer ) # type: Type[Node] logger . debug ( ' %s Found %r ' , self . context . level * LIQUID_LOG_INDENT , node . tag ) if node . raw : self . rawtag = node . name self . _clear_state () return node context = self . open_context or self . context raise LiquidSyntaxError ( f 'Unclosed node { self . hit . __name__ } ( { context . name } , ' f 'line { context . lineno + 1 } , ' f 'column { context . colno + 1 } )' , context , self . parser ) def _open_node ( self , char ): # type: (str) -> Optional[bool] \"\"\"check if char is opening a node only when one definite type of node hit\"\"\" if (( not self . opentag_buffer and not char in self . OPEN_CHARS ) or self . content_buffer ): return False opentag = self . opentag_buffer + char # type: str # See if we already have a hit, see if we hit '-' if self . hit : return opentag in self . hit . OPEN_TAG potential_hits = [ node for node in self . NODES if any ( tag . startswith ( opentag ) for tag in node . OPEN_TAG )] if len ( potential_hits ) == 1 : self . hit = potential_hits [ 0 ] return True if len ( potential_hits ) > 1 : return None return False def _close_node ( self , char ): # type: (str) -> Optional[bool] \"\"\"Check if a char is closing a node\"\"\" closetag = self . closetag_buffer + char # type: str if closetag in self . hit . CLOSE_TAG : return True if any ( ctag . startswith ( closetag ) for ctag in self . hit . CLOSE_TAG ): return None return False def _add_to_buffer ( self , char ): # type: (str) -> Union[bool, Type[Node]] \"\"\"Add character to buffer, and decide whether we should do a summary on the state\"\"\" # When should we do a summary: # 1. When a potential hit is determined (ie `{%` hit) # 2. When a hit closes (ie `%}` hit) # 3. Stream end hit if self . escape : char = f ' \\\\ { char } ' self . escape = False if not self . hit : opened = self . _open_node ( char ) # type: Optional[bool] if opened is True : # pragma: no cover self . opentag_buffer += char ret = self . _summarize () logger . debug ( '[dim italic] %s Opened potential node: %s ' '(line: %s , column: %s )[/dim italic]' , self . context . level * LIQUID_LOG_INDENT , self . hit . __name__ , self . open_context . lineno + 1 , self . open_context . colno + 1 , extra = { \"markup\" : True }) return ret if opened is False : self . literal_buffer += self . opentag_buffer + char self . opentag_buffer = '' else : # hit potentially, multiple node types hit self . opentag_buffer += char elif self . _open_node ( char ) is False : closed = self . _close_node ( char ) if closed is True : self . closetag_buffer += char node = self . _summarize () if isinstance ( node , bool ): return node self . open_context = self . context . copy () logger . debug ( '[dim italic] %s Closed node: %s [/dim italic]' , self . context . level * LIQUID_LOG_INDENT , f \" { node . __class__ . __name__ } ( { node . tag . name } )\" if isinstance ( node , NodeTag ) else node . name , extra = { \"markup\" : True }) return node if closed is False : self . content_buffer += self . closetag_buffer + char self . closetag_buffer = '' else : # potentially closed self . closetag_buffer += char else : # we hit '-' self . opentag_buffer += char return True def consume ( self , stream ): DOCS # type: (IO) -> Union[bool, Type[Node]] \"\"\"Consume the character of a stream if it is empty, then we hit the end of the stream. Otherwise, we need to update the context, and add the character to the buffer. Args: stream: The stream to consume Returns: True: we should continue consuming False: we should stop consuming (we hit the end of the stream) Node: A complete node hit \"\"\" char = stream . read ( 1 ) # type: str if not char : return self . _summarize ( end = True ) if char == ' \\n ' : self . context . lineno += 1 self . context . colno = 0 return self . _add_to_buffer ( char ) if char == ' \\\\ ' : self . escape = not self . escape self . context . colno += 1 if not self . escape : return self . _add_to_buffer ( char ) else : self . context . colno += 1 return self . _add_to_buffer ( char ) return True","title":"liquid.nodes"},{"location":"api/source/liquid.parser/","text":"SOURCE CODE liquid. parser DOCS \"\"\"The parser for liquidpy\"\"\" from collections import deque from diot import Diot from .config import LIQUID_LOG_INDENT from .nodes import NodeScanner from .utils import logger from .tags import tag_manager from .exceptions import LiquidSyntaxError class Visitor : DOCS # pylint: disable=too-few-public-methods \"\"\"Vistor to visit parsed node Attributes: root: The root tag stack: The tag stack, used to resolve the structure blocks: The block tags, used to replace the mother's ones has_mother: Indicates whether this template is extended from a mother template Args: root: The root tag \"\"\" __slots__ = ( 'root' , 'stack' , 'blocks' , 'has_mother' , '_prev_tag' ) def __init__ ( self , root ): # type: (Tag) -> None self . root = root self . stack = deque () self . blocks = {} self . has_mother = False # use to hold the compact self . _prev_tag = None def visit ( self , tag ): DOCS # type: (Tag) -> None \"\"\"Visit the tag Args: tag: The tag \"\"\" # whitespace control if tag . name == 'LITERAL' : tag . open_compact = self . _prev_tag and self . _prev_tag . close_compact elif self . _prev_tag and self . _prev_tag . name == 'LITERAL' : self . _prev_tag . close_compact = tag . open_compact self . _prev_tag = tag if tag . name . startswith ( 'end' ): self . _end_tag ( tag ) else : self . _start_tag ( tag ) tag . parse () if tag . name == 'block' : self . blocks [ tag . parsed ] = tag def _start_tag ( self , tag ): # type: (Tag) -> None \"\"\"Encounter a start tag, try to solve the structure\"\"\" if not self . stack : if tag . parent_required : raise LiquidSyntaxError ( f \"One of the parent tags is required: { tag . PARENT_TAGS } \" , tag . context , tag . parser ) if tag . elder_required : raise LiquidSyntaxError ( f \"One of the elder tags is required: { tag . ELDER_TAGS } \" , tag . context , tag . parser ) self . root . children . append ( tag ) tag . parent = self . root else : # assign siblings if tag . is_elder ( self . stack [ - 1 ]): # let parent handle coming tags prev_tag = self . stack . pop () prev_tag . next = tag tag . prev = prev_tag tag . context . level = prev_tag . context . level # now self.stack[-1] should be the parent if self . stack : self . stack [ - 1 ] . children . append ( tag ) tag . parent = self . stack [ - 1 ] tag . context . level = tag . parent . context . level + 1 # If parent is holding parsing, I am holding too. tag . parsing_self = tag . parent . parsing_children tag . parsing_children = tag . parent . parsing_children # parent check # we need to check if a tag is under the right parent if not tag . check_parents (): raise LiquidSyntaxError ( f \"Tag { tag . name !r} expects parents: { tag . PARENT_TAGS } \" , tag . context , tag . parser ) # elder check # if a node is requiring elders, it should not be the first child if not tag . check_elders (): raise LiquidSyntaxError ( f \"Tag { tag . name !r} expects elder tags: { tag . ELDER_TAGS } \" , tag . context , tag . parser ) if not tag . VOID : self . stack . append ( tag ) def _end_tag ( self , tag ): # type: (Tag) -> None \"\"\"Handle tag relationships when closing a tag.\"\"\" tagname = tag . name [ 3 :] if not self . stack : raise LiquidSyntaxError ( f \"Unexpected endtag: { tag !r} \" , tag . context , tag . parser ) last_tag = self . stack [ - 1 ] last_eldest = last_tag . eldest or last_tag while last_tag : if last_eldest . name == tagname : self . stack . pop () break # If a tag needs parent, supposingly, the parent will close # for it # Otherwise, here, it needs to be closed if not last_eldest . parent_required : raise LiquidSyntaxError ( f \"Tag unclosed: { last_eldest !r} \" , last_eldest . context , last_eldest . parser ) self . stack . pop () last_tag = self . stack [ - 1 ] if self . stack else None last_eldest = ( last_tag . eldest if last_eldest else None ) or last_tag class Parser : DOCS # pylint: disable=too-few-public-methods \"\"\"The root parser for liquidpy This parses the stream into tags, and each tag will be handled by different parser using lark Attibutes: NODESCANNER_CLASS: The node scanner class VISITOR_CLASS: The visitor class config: The configuration context: The context parent: The parent parser nodescanner: The node scanner visitor: The visitor for tags Args: meta: The template meta data config: The configuration context: The context level: The level of the parser \"\"\" __slots__ = ( 'config' , 'context' , 'parent' , 'nodescanner' , 'visitor' ) NODESCANNER_CLASS = NodeScanner # type: Type[NodeScanner] VISITOR_CLASS = Visitor # type: Type[Visitor] def __init__ ( self , meta , config , context = None , level = 0 ): # type: (TemplateMeta, Dict, Optional[Diot], Optional[int]) -> None self . config = config self . context = context or Diot ( name = meta . name , path = meta . path , stream = meta . stream , lineno = 0 , colno = 0 , level = level ) self . parent = None self . nodescanner = self . NODESCANNER_CLASS ( self . context , self ) self . nodescanner . open_context = self . context . copy () self . visitor = self . VISITOR_CLASS ( tag_manager . get ( 'ROOT' )( hitname = 'ROOT' , content = f ' { meta . name } ::ROOT' , context = self . nodescanner . open_context , open_compact = False , close_compact = False , parser = self )) def parse ( self ): DOCS # type: () -> Tag \"\"\"Parser the template for later rendering. Returns: The root tag for later rendering \"\"\" logger . debug ( ' %s - PARSING %r ...' , self . context . level * LIQUID_LOG_INDENT , self . context . name ) while True : scanned = self . nodescanner . consume ( self . context . stream ) # type: Optional[bool, Node] if scanned is False : self . visitor . root . parse () logger . debug ( ' %s END PARSING.' , self . context . level * LIQUID_LOG_INDENT ) break if scanned is True : continue # Node tag = scanned . tag if not tag . SECURE and self . config . strict : raise LiquidSyntaxError ( f \"Tag not allowed in strict mode: { tag !r} \" , tag . context , self ) self . visitor . visit ( tag ) return self . visitor . root","title":"liquid.parser"},{"location":"api/source/liquid.python.filters/","text":"SOURCE CODE liquid.python. filters DOCS \"\"\"Management for filters in extended mode\"\"\" from ..filters import FilterManager as FilterManagerStandard , EmptyDrop class FilterManager ( FilterManagerStandard ): DOCS \"\"\"A manager for filters in extended mode\"\"\" INSTANCE = None filters = FilterManagerStandard . filters . copy () # type: Dict[str, Callable] # pylint: disable=invalid-name filter_manager = FilterManager () def _no_emptydrop ( name ): \"\"\"No emptydrop of the filters\"\"\" original_filter = filter_manager . filters [ name ] def new_filter ( * args , ** kwargs ): ret = original_filter ( * args , ** kwargs ) if isinstance ( ret , EmptyDrop ): return args [ 0 ] return ret filter_manager . register ( name )( new_filter ) for filter_name in ( 'reverse' , 'sort' , 'sort_natural' , 'slice' , 'uniq' , 'where' , 'first' , 'last' , 'compact' ): _no_emptydrop ( filter_name ) @filter_manager . register DOCS def getitem ( base , index ): \"\"\"Get an item from the base value\"\"\" return base [ index ] @filter_manager . register DOCS def render ( base , ** envs ): \"\"\"Render a template in python mode\"\"\" import sys from ..liquid import LiquidPython from ..config import LIQUID_FILTERS_ENVNAME frame = sys . _getframe ( 2 ) local_vars = frame . f_locals [ 'local_vars' ] global_vars = frame . f_locals [ 'global_vars' ] . copy () global_vars . update ( local_vars ) global_vars . update ( envs ) del global_vars [ LIQUID_FILTERS_ENVNAME ] return LiquidPython ( base ) . render ( ** global_vars )","title":"liquid.python.filters"},{"location":"api/source/liquid.python/","text":"SOURCE CODE liquid. python DOCS","title":"liquid.python"},{"location":"api/source/liquid.python.parser/","text":"SOURCE CODE liquid.python. parser DOCS \"\"\"BLock parser to parse the text into blocks in python mode\"\"\" # pylint: disable=relative-beyond-top-level from .tags import tag_manager # pylint: disable=unused-import from ..parser import Parser as ParserStandard from ..nodes import ( Node as NodeStandard , NodeTag as NodeTagStandard , NodeOutput as NodeOutputStandard , NodeScanner as NodeScannerStandard ) class NodeTag ( NodeTagStandard , tag_manager = tag_manager ): DOCS \"\"\"Node tag for python mode using a different tag manager\"\"\" class NodeComment ( NodeStandard , tag_manager = tag_manager ): DOCS \"\"\"Node comment for python mode\"\"\" OPEN_TAG = '{#' , '{#-' CLOSE_TAG = '#}' , '-#}' name = \"COMMENT\" class NodeOutput ( NodeOutputStandard , tag_manager = tag_manager ): DOCS \"\"\"Node output for python mode using a different tag manager\"\"\" class NodeScanner ( NodeScannerStandard ): DOCS # pylint: disable=too-few-public-methods \"\"\"Allows NodeComment: {# ... #}\"\"\" NODES = ( NodeComment , NodeOutput , NodeTag ) class Parser ( ParserStandard ): DOCS # pylint: disable=too-few-public-methods \"\"\"Parsing text into blocks in python mode\"\"\" NODESCANNER_CLASS = NodeScanner","title":"liquid.python.parser"},{"location":"api/source/liquid.python.tags.inherited/","text":"SOURCE CODE liquid.python.tags. inherited DOCS \"\"\"About tags inherited from standard mode Attributes BASE_GRAMMAR: The base grammar for python mode tag_manager: The tag manager for python mode \"\"\" from pathlib import Path from ...tags.manager import TagManager as TagManagerStandard from ...tags.grammar import Grammar from ...tags.tag import Tag as TagStandard BASE_GRAMMAR = Grammar ( Path ( __file__ ) . parent / 'grammar.lark' ) # type: Grammar class TagManager ( TagManagerStandard ): DOCS \"\"\"Tag manager for tags in python mode\"\"\" INSTANCE = None tags = {} # pylint: disable=invalid-name tag_manager = TagManager () # type: TagManager class Tag ( TagStandard , use_parser = True ): DOCS \"\"\"The base tag class for tags in python mode\"\"\" BASE_GRAMMAR = BASE_GRAMMAR","title":"liquid.python.tags.inherited"},{"location":"api/source/liquid.python.tags/","text":"SOURCE CODE liquid.python. tags DOCS \"\"\"Tags related definitions for python mode\"\"\" import pkgutil from .inherited import Tag , tag_manager # load all builtin tags for _ , modname , _ in pkgutil . walk_packages ( __path__ ): if modname . startswith ( 'tag_' ): __import__ ( f ' { __name__ } . { modname } ' )","title":"liquid.python.tags"},{"location":"api/source/liquid.python.tags.tag__inherited/","text":"SOURCE CODE liquid.python.tags. tag__inherited DOCS \"\"\"Tags inherited from standard mode\"\"\" # pylint: disable=relative-beyond-top-level from lark import v_args from .inherited import tag_manager , Tag , BASE_GRAMMAR from .transformer import TagTransformer from .tag_if import TagIf from ...utils import RequiredTags from ...tags.tag__output import TagOUTPUT as TagOUTPUTStandard from ...tags.tag__end import TagEND from ...tags.tag_block import TagBlock from ...tags.tag_break import TagBreak as TagBreakStandard from ...tags.tag_capture import TagCapture from ...tags.tag_case import TagCase as TagCaseStandard from ...tags.tag_comment import TagComment from ...tags.tag_continue import TagContinue as TagContinueStandard from ...tags.tag_extends import TagExtends from ...tags.tag_include import TagInclude from ...tags.tag_decrement import TagDecrement from ...tags.tag_increment import TagIncrement from ...tags.tag_raw import TagRaw from ...tags.tag_when import TagWhen as TagWhenStandard from ...tags.tag_config import ( TagConfig as TagConfigStandard , TagConfigTransformer as TagConfigTransformerStandard ) from ...tags.tag_cycle import ( TagCycle as TagCycleStandard , TagCycleTransformer as TagCycleTransformerStandard ) tag_manager . register ( TagEND ) tag_manager . register ( TagBlock ) tag_manager . register ( TagCapture ) tag_manager . register ( TagComment ) tag_manager . register ( TagExtends ) tag_manager . register ( TagInclude ) tag_manager . register ( TagDecrement ) tag_manager . register ( TagIncrement ) tag_manager . register ( TagRaw ) @tag_manager . register class TagBreak ( TagBreakStandard ): DOCS \"\"\"Tag break in python mode\"\"\" PARENT_TAGS = RequiredTags ( 'for' , 'while' ) BASE_GRAMMAR = BASE_GRAMMAR @tag_manager . register class TagContinue ( TagContinueStandard ): DOCS \"\"\"Tag continue in python mode\"\"\" PARENT_TAGS = RequiredTags ( 'for' , 'while' ) BASE_GRAMMAR = BASE_GRAMMAR @tag_manager . register class TagCOMMENT ( Tag ): DOCS \"\"\"The {# ... #} tag\"\"\" VOID = True def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str # pylint: disable=unused-argument return '' @tag_manager . register class TagOUTPUT ( TagOUTPUTStandard ): DOCS \"\"\"The output tag {{ ... }}\"\"\" TRANSFORMER = TagTransformer () BASE_GRAMMAR = BASE_GRAMMAR @tag_manager . register class TagCase ( TagOUTPUT , use_parser = True ): DOCS \"\"\"The case tag\"\"\" VOID = False __init__ = TagCaseStandard . __init__ _render = TagCaseStandard . _render @tag_manager . register class TagWhen ( TagOUTPUT , use_parser = True ): DOCS \"\"\"The when tag\"\"\" VOID = TagWhenStandard . VOID PARENT = TagWhenStandard . PARENT_TAGS ELDER_TAGS = TagWhenStandard . ELDER_TAGS _render = TagWhenStandard . _render @v_args ( inline = True ) class TagConfigTransformer ( TagTransformer , TagConfigTransformerStandard ): DOCS \"\"\"The transformer for tag config\"\"\" @tag_manager . register class TagConfig ( TagConfigStandard ): DOCS \"\"\"The tag config\"\"\" TRANSFORMER = TagConfigTransformer () BASE_GRAMMAR = BASE_GRAMMAR @v_args ( inline = True ) class TagCycleTransformer ( TagTransformer , TagCycleTransformerStandard ): DOCS \"\"\"The transformer for tag assign\"\"\" @tag_manager . register class TagCycle ( TagCycleStandard ): DOCS \"\"\"The tag cycle\"\"\" TRANSFORMER = TagCycleTransformer () BASE_GRAMMAR = BASE_GRAMMAR @tag_manager . register ( 'elif, elsif' ) class TagElsif ( TagIf ): DOCS \"\"\"The elif/elsif tag\"\"\" ELDER_TAGS = RequiredTags ( 'if' , 'unless' , 'elsif' , 'elif' )","title":"liquid.python.tags.tag__inherited"},{"location":"api/source/liquid.python.tags.tag_assign/","text":"SOURCE CODE liquid.python.tags. tag_assign DOCS \"\"\"Tag assign\"\"\" from lark import v_args , Tree from .transformer import TagTransformer from .inherited import tag_manager , BASE_GRAMMAR from ...tags.tag_assign import TagAssign as TagAssignStandard @v_args ( inline = True ) class TagAssignTransformer ( TagTransformer ): DOCS \"\"\"The transformer for tag assign in python mode\"\"\" # pylint: disable=no-self-use def tag_assign ( self , varname , output ): DOCS # type: (str, Tree) -> Tuple[str, Tree] \"\"\"Transform the tag_assign rule\"\"\" return str ( varname ), output @tag_manager . register class TagAssign ( TagAssignStandard ): DOCS \"\"\"Tag assign in python mode\"\"\" BASE_GRAMMAR = BASE_GRAMMAR TRANSFORMER = TagAssignTransformer () def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str varname , output = self . parsed output = output . render ( local_vars , global_vars ) local_vars [ varname ] = output return ''","title":"liquid.python.tags.tag_assign"},{"location":"api/source/liquid.python.tags.tag_else/","text":"SOURCE CODE liquid.python.tags. tag_else DOCS \"\"\"Tag else\"\"\" from lark import v_args from .transformer import TagTransformer from .inherited import tag_manager from .tag_if import TagIf from ...utils import NOTHING , OptionalTags , RequiredTags from ...exceptions import LiquidSyntaxError @v_args ( inline = True ) class TagElseTransformer ( TagTransformer ): DOCS \"\"\"The transformer for tag else\"\"\" # pylint: disable=no-self-use def tag_else ( self , test = NOTHING ): DOCS \"\"\"Get whatever passed by\"\"\" return test @tag_manager . register class TagElse ( TagIf ): DOCS \"\"\"Tag else in python mode Allowed to be used with for, while and unless, too \"else if\" is also allowed here. \"\"\" PARENT_TAGS = OptionalTags ( 'case' ) # check this is invalid: # {% if ... %} {% else %} {% else if ... %} {% endif %} ELDER_TAGS = RequiredTags ( 'if' , 'unless' , 'when' , 'for' , 'elsif' , 'elif' , 'else' , 'while' ) START = 'tag_else' GRAMMAR = 'tag_else: (\"if\" test)?' TRANSFORMER = TagElseTransformer () def parse ( self , force = False ): DOCS # type: (bool) -> None \"\"\"Check to see if there is any siblings after a bare {% else %} tag \"\"\" if not super () . parse ( force ): return # if this is {% else %}, we should not have any following siblings # This is a special case # Should we use another flag to tell the parse and raise the # exception earlier? if ( self . prev and isinstance ( self . prev , TagElse ) and self . prev . parsed is NOTHING ): raise LiquidSyntaxError ( f 'No tags allowed after { self !r} ' , self . context , self . parser ) def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str if self . parsed is NOTHING : return self . _render_children ( local_vars , global_vars ) return super () . _render ( local_vars , global_vars )","title":"liquid.python.tags.tag_else"},{"location":"api/source/liquid.python.tags.tag_for/","text":"SOURCE CODE liquid.python.tags. tag_for DOCS \"\"\"More pythonic for tag for python mode of liquidpy\"\"\" from lark import v_args from .transformer import TagTransformer from .inherited import Tag , tag_manager from ...tags.transformer import render_segment @v_args ( inline = True ) class TagForTransformer ( TagTransformer ): DOCS \"\"\"Transformer for tag for\"\"\" # pylint: disable=no-self-use def tag_for ( self , varname , * args ): DOCS \"\"\"Transformer for tag for\"\"\" varnames = ( varname , * args [: - 1 ]) return tuple ( str ( vname ) for vname in varnames ), args [ - 1 ] @tag_manager . register class TagFor ( Tag ): DOCS \"\"\"The for tag Attributes: flag_break: The flag for break statement flag_continue: The flag for continue statement cycles: The cycle object for cycle tags \"\"\" __slots__ = Tag . __slots__ + ( 'flag_break' , 'flag_continue' ) START = 'tag_for' GRAMMAR = 'tag_for: var (\",\" var)* \"in\" output' TRANSFORMER = TagForTransformer () def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . flag_break = False # type: bool self . flag_continue = False # type: bool def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str rendered = '' varnames , value = self . parsed value = render_segment ( value , local_vars , global_vars ) local_vars_inside = local_vars . copy () for elem in value : if not isinstance ( elem , ( tuple , list )): elem = ( elem ,) for i , varname in enumerate ( varnames ): local_vars_inside [ varname ] = elem [ i ] for child in self . children : child_rendered , _ = child . render ( local_vars_inside , global_vars ) rendered += child_rendered if self . flag_continue or self . flag_break : self . flag_continue = False break if self . flag_break : break if not value or not self . flag_break : # for ... else rendered += self . _render_next ( local_vars , global_vars , True ) return rendered","title":"liquid.python.tags.tag_for"},{"location":"api/source/liquid.python.tags.tag_from/","text":"SOURCE CODE liquid.python.tags. tag_from DOCS \"\"\"Tag from\"\"\" from .inherited import tag_manager , Tag @tag_manager . register class TagFrom ( Tag ): DOCS \"\"\"Import submodules from python\"\"\" VOID = True SECURE = False def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str # pylint: disable=exec-used exec ( f 'from { self . content } ' , global_vars , local_vars ) return ''","title":"liquid.python.tags.tag_from"},{"location":"api/source/liquid.python.tags.tag_if/","text":"SOURCE CODE liquid.python.tags. tag_if DOCS \"\"\"Tag if\"\"\" from .transformer import TagTransformer from .inherited import tag_manager , BASE_GRAMMAR from ...tags.transformer import render_segment from ...tags.tag_if import TagIf as TagIfStandard @tag_manager . register class TagIf ( TagIfStandard ): DOCS \"\"\"Tag if. One can even do filters: {% if value | filter %} \"\"\" START = 'output' TRANSFORMER = TagTransformer () BASE_GRAMMAR = BASE_GRAMMAR def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str rendered = '' expr = render_segment ( self . parsed , local_vars , global_vars ) from_elder = True if expr : # don't go next from_elder = False rendered += self . _render_children ( local_vars , global_vars ) rendered += self . _render_next ( local_vars , global_vars , from_elder ) return rendered","title":"liquid.python.tags.tag_if"},{"location":"api/source/liquid.python.tags.tag_import/","text":"SOURCE CODE liquid.python.tags. tag_import DOCS \"\"\"Tag import\"\"\" from .inherited import tag_manager , Tag @tag_manager . register class TagImport ( Tag ): DOCS \"\"\"Tag import to import a module from python\"\"\" VOID = True SECURE = False def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str # pylint: disable=exec-used exec ( f 'import { self . content } ' , global_vars , local_vars ) return ''","title":"liquid.python.tags.tag_import"},{"location":"api/source/liquid.python.tags.tag_python/","text":"SOURCE CODE liquid.python.tags. tag_python DOCS \"\"\"The python tag\"\"\" import textwrap from .inherited import tag_manager , Tag @tag_manager . register class TagPython ( Tag ): DOCS \"\"\"It can be either void or non-void ```liquid {% python a = 1 %} {% python %} a = 1 b = 2 {% endpython %} ``` \"\"\" VOID = False SECURE = False def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) if self . content : self . VOID = True # pylint: disable=invalid-name def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str # pylint: disable=exec-used if self . VOID : return exec ( self . content , global_vars , local_vars ) or '' children_rendered = self . _render_children ( local_vars , global_vars ) return exec ( textwrap . dedent ( str ( children_rendered )), global_vars , local_vars ) or ''","title":"liquid.python.tags.tag_python"},{"location":"api/source/liquid.python.tags.tag_unless/","text":"SOURCE CODE liquid.python.tags. tag_unless DOCS \"\"\"Tag unless\"\"\" from .inherited import tag_manager from .tag_if import TagIf from ...tags.transformer import render_segment @tag_manager . register class TagUnless ( TagIf , use_parser = True ): DOCS \"\"\"Tag unless, with no emptydrop stuff\"\"\" def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str rendered = '' expr = render_segment ( self . parsed , local_vars , global_vars ) from_elder = True if not expr : # don't go next from_elder = False rendered += self . _render_children ( local_vars , global_vars ) rendered += self . _render_next ( local_vars , global_vars , from_elder ) return rendered","title":"liquid.python.tags.tag_unless"},{"location":"api/source/liquid.python.tags.tag_while/","text":"SOURCE CODE liquid.python.tags. tag_while DOCS \"\"\"Tag while\"\"\" import copy from .inherited import tag_manager from .tag_if import TagIf from ...tags.transformer import render_segment @tag_manager . register class TagWhile ( TagIf ): DOCS \"\"\"The for tag Attributes: flag_break: The flag for break statement flag_continue: The flag for continue statement \"\"\" __slots__ = TagIf . __slots__ + ( 'flag_break' , 'flag_continue' ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . flag_continue = False # type: bool self . flag_break = False # type: bool def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str rendered = '' value = render_segment ( self . parsed , local_vars , global_vars ) value0 = copy . copy ( value ) local_vars_copy = None while value : local_vars_copy = local_vars_copy or local_vars . copy () for child in self . children : child_rendered , _ = child . render ( local_vars_copy , global_vars ) rendered += child_rendered if self . flag_break or self . flag_continue : self . flag_continue = False break if self . flag_break : break value = render_segment ( self . parsed , local_vars_copy , global_vars ) if not value0 or not self . flag_break : # while ... else rendered += self . _render_next ( local_vars , global_vars , True ) return rendered","title":"liquid.python.tags.tag_while"},{"location":"api/source/liquid.python.tags.transformer/","text":"SOURCE CODE liquid.python.tags. transformer DOCS \"\"\"The segments and transformer for liquidpy in python mode\"\"\" # pylint: disable=relative-beyond-top-level from functools import partialmethod from lark import v_args , Token from ...config import LIQUID_FILTERS_ENVNAME from ...tags.transformer import ( render_segment , TagSegment , TagSegmentComparison , TagSegmentVar as TagSegmentVarStandard , TagTransformer as TagTransformerStandard ) from ...utils import NOTHING from ...filters import EmptyDrop class TagSegmentVar ( TagSegmentVarStandard ): DOCS \"\"\"Varaible segment in python mode. There will be no EmptyDrop object as rendered\"\"\" def render ( self , local_vars , global_vars ): DOCS \"\"\"Get the value of a variable from envs\"\"\" var = super () . render ( local_vars , global_vars ) if isinstance ( var , EmptyDrop ): varname = str ( self . data [ 0 ]) return local_vars . get ( varname , global_vars . get ( varname )) return var class TagSegmentIfelse ( TagSegment ): DOCS \"\"\"The ternary operation in python: `A if cond else B`\"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any # pylint: disable=unused-argument \"\"\"Render the segment with the given envs\"\"\" cond = render_segment ( self . data [ 1 ], local_vars , global_vars ) if cond : return render_segment ( self . data [ 0 ], local_vars , global_vars ) return render_segment ( self . data [ 2 ], local_vars , global_vars ) class TagSegmentOr ( TagSegment ): DOCS \"\"\"Or statement in python\"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" for data in self . data : data = render_segment ( data , local_vars , global_vars ) if data : return data return False class TagSegmentAnd ( TagSegment ): DOCS \"\"\"And statement in python\"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" lastdata = None for data in self . data : data = render_segment ( data , local_vars , global_vars ) if not data : return data lastdata = data return lastdata class TagSegmentNot ( TagSegment ): DOCS \"\"\"Not statement in python\"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" return not render_segment ( self . data [ 0 ], local_vars , global_vars ) class TagSegmentGetAttr ( TagSegment ): DOCS \"\"\"Getattr operation in python\"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" obj = render_segment ( self . data [ 0 ], local_vars , global_vars ) try : return getattr ( obj , self . data [ 1 ]) except AttributeError as exc : try : return obj [ self . data [ 1 ]] except ( KeyError , TypeError ): raise AttributeError ( f ' { type ( obj ) . __name__ !r} object has ' f 'no attribute { self . data [ 1 ] !r} ' ) . with_traceback ( exc . __traceback__ ) from None class TagSegmentGetItem ( TagSegment ): DOCS \"\"\"Getitem operation in python\"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" return render_segment ( self . data [ 0 ], local_vars , global_vars )[ render_segment ( self . data [ 1 ], local_vars , global_vars ) ] class TagSegmentExpr ( TagSegment ): DOCS \"\"\"Expressions in python\"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" sign = str ( self . data [ 0 ]) ret = render_segment ( self . data [ 1 ], local_vars , global_vars ) for data in self . data [ 2 :]: data = render_segment ( data , local_vars , global_vars ) if sign == '|' : ret |= data elif sign == '^' : ret ^= data elif sign == '&' : ret &= data elif sign == '<<' : ret <<= data elif sign == '>>' : ret >>= data elif sign == '+' : ret += data elif sign == '-' : ret -= data elif sign == '*' : ret *= data elif sign == '@' : # pragma: no cover ret @= data elif sign == '/' : ret /= data elif sign == '%' : ret %= data elif sign == '//' : ret //= data return ret class TagSegmentPower ( TagSegment ): DOCS \"\"\"Power expression in python\"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" data1 = render_segment ( self . data [ 0 ], local_vars , global_vars ) data2 = render_segment ( self . data [ 1 ], local_vars , global_vars ) return data1 ** data2 class TagSegmentFactor ( TagSegment ): DOCS \"\"\"Factor expression in python\"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" factor_op , factor = self . data factor = render_segment ( factor , local_vars , global_vars ) if factor_op == '-' : return - factor if factor_op == '~' : return ~ factor return factor class TagSegmentFuncCall ( TagSegment ): DOCS \"\"\"Function call in python We simplified the function call in python, no start arguments (*args) nor keyword arguments (**kwargs) allowed. \"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" func = render_segment ( self . data [ 0 ], local_vars , global_vars ) if self . data [ 1 ] is None : return func () args , kwargs = render_segment ( self . data [ 1 ], local_vars , global_vars ) return func ( * args , ** kwargs ) class TagSegmentTuple ( TagSegment ): DOCS \"\"\"Tuple literals in python\"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" if not self . data or self . data [ 0 ] is NOTHING : return () return tuple ( render_segment ( data , local_vars , global_vars ) for data in self . data [ 0 ]) class TagSegmentList ( TagSegment ): DOCS \"\"\"List literals in python\"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" if not self . data or self . data [ 0 ] is NOTHING : return [] return list ( render_segment ( data , local_vars , global_vars ) for data in self . data [ 0 ]) class TagSegmentSet ( TagSegment ): DOCS \"\"\"Set literals in python\"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" return set ( render_segment ( data , local_vars , global_vars ) for data in self . data ) class TagSegmentDict ( TagSegment ): DOCS \"\"\"Dict literals in python\"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" return { render_segment ( key , local_vars , global_vars ): render_segment ( val , local_vars , global_vars ) for key , val in self . data } class TagSegmentSlice ( TagSegment ): DOCS \"\"\"Slice objects in python\"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" if len ( self . data ) == 1 : return render_segment ( self . data [ 0 ], local_vars , global_vars ) return slice ( * ( render_segment ( data , local_vars , global_vars ) for data in self . data )) class TagSegmentLambda ( TagSegment ): DOCS \"\"\"Lambda objects in python\"\"\" def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" arglist , body = self . data al_args , al_kwargs = arglist . render ( local_vars , global_vars , as_is = True ) if arglist else ([], {}) al_kwargs_keys = list ( al_kwargs . keys ()) len_al_args = len ( al_args ) def lambdafunc ( * args , ** kwargs ): local_vars_inside = local_vars . copy () local_vars_inside . update ( al_kwargs ) local_vars_inside . update ( kwargs ) for i , arg in enumerate ( args ): if i < len_al_args : local_vars_inside [ al_args [ i ]] = arg else : key = al_kwargs_keys [ i - len_al_args ] if key in kwargs : raise TypeError ( f 'Argument { key !r} got multiple values' ) local_vars_inside [ key ] = arg return render_segment ( body , local_vars_inside , global_vars ) return lambdafunc class TagSegmentFilter ( TagSegment ): DOCS \"\"\"Filter segment\"\"\" # pylint: disable=no-self-use def _no_such_filter ( self , name_token , exc_wrapper = KeyError ): error = exc_wrapper ( f \"No such filter: { str ( name_token ) !r} \" ) try : error . lineno = name_token . line error . colno = name_token . column except AttributeError : pass return error def _get_filter_by_name ( self , local_vars , global_vars , name_token , complex = False ): # pylint: disable=redefined-builtin if not complex : filtname = str ( name_token ) filter_func = global_vars [ LIQUID_FILTERS_ENVNAME ] . get ( filtname , local_vars . get ( filtname , global_vars . get ( filtname , NOTHING ) ) ) if filter_func is NOTHING : raise self . _no_such_filter ( name_token ) return filter_func try : filter_func = render_segment ( name_token , local_vars , global_vars ) except Exception as exc : raise self . _no_such_filter ( name_token , type ( exc )) from None return filter_func def _render_lambda ( self , local_vars , global_vars ): return self . data [ 0 ] . render ( local_vars , global_vars ) def _render_ternary ( self , local_vars , global_vars ): # ternary condfilter , truth , falsity = self . data def filter_ternary ( base ): cond = ( condfilter . render ( local_vars , global_vars )( base ) if condfilter else base ) if cond : return ( truth . render ( local_vars , global_vars )( base ) if isinstance ( truth , TagSegmentFilter ) else base if truth is None else render_segment ( truth , local_vars , global_vars )) return ( falsity . render ( local_vars , global_vars )( base ) if isinstance ( falsity , TagSegmentFilter ) else base if falsity is None else render_segment ( falsity , local_vars , global_vars )) return filter_ternary def _render_normal ( self , # pylint: disable=too-many-arguments local_vars , global_vars , filter_name , filter_arg , filter_type ): if filter_arg is None : filter_args , filter_kwargs = [], {} else : local_vars_copy = local_vars . copy () local_vars_copy [ '_' ] = NOTHING filter_args , filter_kwargs = filter_arg . render ( local_vars_copy , global_vars ) filter_func = self . _get_filter_by_name ( local_vars , global_vars , filter_name , filter_type == 'complex' ) def filter_function ( base ): args = filter_args if NOTHING in args : args [ args . index ( NOTHING )] = base else : args . insert ( 0 , base ) return filter_func ( * args , ** filter_kwargs ) return filter_function def _render_other ( self , # pylint: disable=too-many-arguments local_vars , global_vars , filter_name , filter_arg , filter_type ): if filter_arg is None : filter_args , filter_kwargs = [], {} else : filter_args , filter_kwargs = filter_arg . render ( local_vars , global_vars ) filtname = str ( filter_name ) def filter_function ( base ): if filter_type == 'dot' : try : filter_func = getattr ( base , filtname ) except AttributeError : raise self . _no_such_filter ( filter_name , AttributeError ) from None return filter_func ( * filter_args , ** filter_kwargs ) if filter_type == 'subscript' : try : filter_func = base [ filtname ] except ( KeyError , TypeError ) as exc : raise self . _no_such_filter ( filter_name , type ( exc ) ) from None return filter_func ( * filter_args , ** filter_kwargs ) # start, keyword subtype = 'normal' subname = filter_name if isinstance ( filter_name , tuple ): subname , subtype = filter_name filter_func = self . _get_filter_by_name ( local_vars , global_vars , subname , subtype == 'complex' ) if filter_type == 'star' : return filter_func ( * base , * filter_args , ** filter_kwargs ) return filter_func ( * filter_args , ** base , ** filter_kwargs ) return filter_function def render ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"render the segment\"\"\" if len ( self ) == 1 : # lambda return self . _render_lambda ( local_vars , global_vars ) if len ( self ) == 2 : # varname: arguments filter_name , filter_arg = self . data filter_type = 'normal' if isinstance ( filter_name , tuple ): filter_name , filter_type = filter_name if filter_type in ( 'normal' , 'complex' ): return self . _render_normal ( local_vars , global_vars , filter_name , filter_arg , filter_type ) return self . _render_other ( local_vars , global_vars , filter_name , filter_arg , filter_type ) return self . _render_ternary ( local_vars , global_vars ) @v_args ( inline = True ) class TagTransformer ( TagTransformerStandard ): DOCS \"\"\"Transformer for python grammar\"\"\" # pylint: disable=no-self-use def test ( self , value , cond = NOTHING , false_value = NOTHING ): DOCS \"\"\"The rule test: or_test (\"if\" or_test \"else\" test)? | lambdef\"\"\" if cond is NOTHING and false_value is NOTHING : return value return TagSegmentIfelse ( value , cond , false_value ) # pylint: disable=signature-differs, arguments-differ def comparison ( self , expr , * op_and_exprs ): DOCS \"\"\"The rule comparison: expr (_comp_op expr)*\"\"\" ret = expr op = '' i = 0 while i < len ( op_and_exprs ): if isinstance ( op_and_exprs [ i ], Token ): op += op_and_exprs [ i ] . value if isinstance ( op_and_exprs [ i + 1 ], Token ): op += op_and_exprs [ i + 1 ] . value expr2 = op_and_exprs [ i + 2 ] i += 3 else : expr2 = op_and_exprs [ i + 1 ] i += 2 ret = TagSegmentComparison ( ret , op , expr2 ) op = '' return ret def term ( self , one , * more ): DOCS \"\"\"The rule term: factor (_mul_op factor)*\"\"\" if not more : return one return TagSegmentExpr ( more [ 0 ], one , * ( mor for i , mor in enumerate ( more ) if i % 2 ) ) def factor ( self , factor_op_or_power , factor = NOTHING ): DOCS \"\"\"The rule factor: _factor_op factor | power\"\"\" if factor is NOTHING : return factor_op_or_power return TagSegmentFactor ( factor_op_or_power , factor ) def power ( self , atom_expr , factor = NOTHING ): DOCS \"\"\"The rule power: atom_expr (\"**\" factor)?\"\"\" if factor is NOTHING : return atom_expr return TagSegmentPower ( atom_expr , factor ) def dictmarker ( self , * tests ): DOCS \"\"\"The dictmarker rule: dictmarker: test \":\" test (\",\" test \":\" test)* [\",\"] \"\"\" ret = [] for i in range ( 0 , len ( tests ), 2 ): ret . append (( tests [ i ], tests [ i + 1 ])) return ret def atom_dict ( self , marker = NOTHING ): DOCS \"\"\"The rule atom_dict: \"{\" (dictmarker|testlist_comp)? \"}\" \"\"\" if marker is NOTHING : return {} if isinstance ( marker [ 0 ], tuple ) and len ( marker [ 0 ]) == 2 : return TagSegmentDict ( * marker ) return TagSegmentSet ( * marker ) def atom_string ( self , * strings ): DOCS \"\"\"The rule atom_string: string+ \"\"\" return '' . join ( strings ) def _filter_type ( self , var , ftype ): return ( var , ftype ) def _one_or_more ( self , one , * more , sign = None , segment = None ): if not more : return one if sign is None : return segment ( one , * more ) return segment ( sign , one , * more ) _passby = TagTransformerStandard . _passby _passby_segment = TagTransformerStandard . _passby_segment _passby_single_segment = TagTransformerStandard . _passby_single_segment or_test = partialmethod ( _one_or_more , segment = TagSegmentOr ) and_test = partialmethod ( _one_or_more , segment = TagSegmentAnd ) expr = partialmethod ( _one_or_more , sign = '|' , segment = TagSegmentExpr ) xor_expr = partialmethod ( _one_or_more , sign = '^' , segment = TagSegmentExpr ) and_expr = partialmethod ( _one_or_more , sign = '&' , segment = TagSegmentExpr ) funccall = partialmethod ( _passby_segment , segment = TagSegmentFuncCall ) get_item = partialmethod ( _passby_segment , segment = TagSegmentGetItem ) get_attr = partialmethod ( _passby_segment , segment = TagSegmentGetAttr ) atom_tuple = partialmethod ( _passby_single_segment , segment = TagSegmentTuple ) atom_list = partialmethod ( _passby_single_segment , segment = TagSegmentList ) subscript = partialmethod ( _passby_segment , segment = TagSegmentSlice ) not_ = partialmethod ( _passby_segment , segment = TagSegmentNot ) test_filter = partialmethod ( _passby_segment , segment = TagSegmentFilter ) lambdef = partialmethod ( _passby_segment , segment = TagSegmentLambda ) var = partialmethod ( _passby_segment , segment = TagSegmentVar ) shift_expr = arith_expr = term testlist_comp = _passby dot_filter = partialmethod ( _filter_type , ftype = 'dot' ) star_filter = partialmethod ( _filter_type , ftype = 'star' ) keyword_filter = partialmethod ( _filter_type , ftype = 'keyword' ) subscript_filter = partialmethod ( _filter_type , ftype = 'subscript' ) complex_filter = partialmethod ( _filter_type , ftype = 'complex' )","title":"liquid.python.tags.transformer"},{"location":"api/source/liquid.tags.grammar/","text":"SOURCE CODE liquid.tags. grammar DOCS \"\"\"Grammar utilities for lark grammar. Here we opens opptunities to operate the grammar, including add, remove and update \"\"\" from pathlib import Path from copy import deepcopy from diot import OrderedDiot class Grammar : DOCS \"\"\"Manipulate lark grammar Args: grammar: The grammar. Could be a grammar string or a path to grammar file. Attributes: grammar: The loaded grammar \"\"\" def __init__ ( self , grammar ): # type: (Union[str, Path]) -> None self . grammar = Grammar . _load ( grammar ) @staticmethod def _load ( grammar ): # type: (Union[str, Path]) -> OrderedDiot \"\"\"Load the base grammar in a very simple way. Only name and its following strings \"\"\" try : if Path ( grammar ) . is_file (): grammar_lines = open ( grammar ) else : raise OSError except OSError : # filename too long grammar_lines = grammar . splitlines () ret = OrderedDiot () name = None for line in grammar_lines : line = line . strip () if not line or line . startswith ( '//' ): continue if line [ 0 ] == '|' : ret [ name ] . assignment . append ( line [ 1 :] . strip ()) elif line [ 0 ] == '%' : keyword , content = line . split ( maxsplit = 1 ) content = ' ' . join ( content . strip () . split ()) ret . setdefault ( keyword , { 'modifier' : None , 'assignment' : []}) ret [ keyword ] . assignment . append ( content ) else : modifier = None if line [ 0 ] in ( '!' , '?' ): modifier = line [ 0 ] currname , currassign = line [ 1 :] . split ( ':' , 1 ) else : currname , currassign = line . split ( ':' , 1 ) currname = currname . strip () currassign = currassign . strip () ret [ currname ] = { 'modifier' : modifier , 'assignment' : [ currassign ] if currassign else [] } name = currname try : grammar_lines . close () except AttributeError : pass return ret def copy ( self ): DOCS # type: () -> Grammar \"\"\"Copy the grammar object\"\"\" ret = Grammar ( '' ) ret . grammar = deepcopy ( self . grammar ) return ret def update ( self , other ): DOCS # type: (Union[str, Path]) -> None \"\"\"Merge another grammar Rule: - Existing rules will be extended in the way of rule: subrule -> rule: subrule | subrule2 - Non-existing rules/terminals will be added - Unimported statement will be added Args: other: The other grammar \"\"\" other_grammar = ( other if isinstance ( other , Grammar ) else self . _load ( other )) for name , content in other_grammar . items (): if ( name [ 0 ] == '%' and name in self . grammar and content . assignment [ 0 ] in self . grammar [ name ] . assignment [ 0 ]): continue if name in self . grammar : assert ( not content . modifier or content . modifier == self . grammar [ name ] . modifier ), ( \"Grammar rule with inconsistent modifiers: \" f \" { name } ( { self . grammar [ name ] . modifier } , \" f \" { content . modifier } )\" ) self . grammar [ name ] . assignment . extend ( content . assignment ) else : self . grammar [ name ] = content def __str__ ( self ): DOCS # type: () -> str \"\"\"Dump the grammar for parser\"\"\" dumped = [] dumped_append = dumped . append for name , content in self . grammar . items (): if name [ 0 ] == '%' : for assign in content . assignment : dumped_append ( f \" { name } { assign } \" ) else : dumped_append ( f \" { content . modifier or '' }{ name } : \" f \" { content . assignment [ 0 ] } \" ) for assign in content . assignment [ 1 :]: dumped_append ( f \" | { assign } \" ) dumped_append ( \"\" ) return ' \\n ' . join ( dumped ) + ' \\n ' def replace ( self , rule_or_terminal , replacement ): DOCS # type: (str, str) -> None \"\"\"Replace a rule or a terminal with a replacement Args: rule_or_terminal: The rule or terminal name replacement: The replacement string for the rule or terminal \"\"\" if rule_or_terminal not in self . grammar : self . add ( rule_or_terminal , replacement ) self . grammar [ rule_or_terminal ] . assignment = [ replacement ] def add_to ( self , rule , sub_rule ): DOCS # type: (str, str) \"\"\"Add a sub-rule to a rule The rule must be all alternatives (concatenated with \"|\") or an empty rule Args: rule: The rule name sub_rule: The sub-rule \"\"\" self . grammar [ rule ] . assignment . append ( sub_rule ) def add ( self , rule_or_terminal , assignment , modifier = None ): DOCS # type: (str, str, Optional[str]) -> None \"\"\"Add a new rule or terminal Args: rule_or_terminaL: The rule or terminal name assignment: The assignment for the rule or terminal modifier: The modifier for the rule or terminal \"\"\" self . grammar [ rule_or_terminal ] = { 'modifier' : modifier , 'assignment' : [ assignment ] }","title":"liquid.tags.grammar"},{"location":"api/source/liquid.tags.manager/","text":"SOURCE CODE liquid.tags. manager DOCS \"\"\"The tag manager Attributes: tag_manager: The tag manager \"\"\" from ..utils import Singleton from ..exceptions import LiquidTagRegistryException class TagManager ( Singleton ): DOCS \"\"\"The tag manager Attributes: INSTANCE: The instance of this singleton class tags: The tags database \"\"\" INSTANCE = None # type: TagManager tags = {} # type: Dict[str, Tag] def register ( self , tag_class_or_alias = None , mode = 'standard' ): DOCS # type: (Union[Type[Tag], str], bool) -> Callable \"\"\"Register a tag This can be worked as a decorator Args: tag_class_or_alias: The tag class or the alias for the tag class to decorate mode: Whether do it for given mode Returns: The decorator or the decorated class \"\"\" # if mode == 'jekyll': # from .jekyll.tags import tag_manager as tmgr # return tmgr.register(tag_class_or_alias) if mode == 'python' : from ..python.tags import tag_manager as tmgr return tmgr . register ( tag_class_or_alias ) def decorator ( tag_class ): \"\"\"The decorator for the tag class\"\"\" name = tag_class . __name__ if name . startswith ( 'Tag' ): name = name [ 3 :] # keep all-uppercase names, they are special tags # like LITERAL, COMMENT, OUTPUT if not name . isupper (): name = name . lower () name = [ name ] if tag_class_or_alias and tag_class is not tag_class_or_alias : names = tag_class_or_alias if isinstance ( names , str ): names = ( alias . strip () for alias in names . split ( ',' )) name = names for nam in name : self . __class__ . tags [ nam ] = tag_class return tag_class if callable ( tag_class_or_alias ): return decorator ( tag_class_or_alias ) return decorator def unregister ( self , tagname , mode = 'standard' ): DOCS # type: (str, bool) -> Type[Tag] \"\"\"Unregister a tag Args: tagname: The name of the tag to unregister mode: Whether do it for given mode Returns: The tag class unregistered. It can be used to be re-registered \"\"\" # if mode == 'jekyll': # from .jekyll.tags import tag_manager as tmgr # return tmgr.unregister(tagname) if mode == 'python' : from ..python.tags import tag_manager as tmgr return tmgr . unregister ( tagname ) try : return self . tags . pop ( tagname ) except KeyError : raise LiquidTagRegistryException ( f 'No such tag: { tagname } ' ) from None def get ( self , name ): DOCS # type: (str) -> Optional[Tag] \"\"\"Get the tag class Args: name: The name of the tag Returns: The tag class or None if name does not exist \"\"\" tagname = name [ 3 :] if name . startswith ( 'end' ) else name # type: str if tagname not in self . tags : return None return self . tags [ tagname if tagname == name else 'END' ] # pylint: disable=invalid-name tag_manager = TagManager () # type: TagManager","title":"liquid.tags.manager"},{"location":"api/source/liquid.tags/","text":"SOURCE CODE liquid. tags DOCS \"\"\"All stuff about liquidpy tags\"\"\" import pkgutil from .manager import tag_manager from .tag import Tag # load all builtin tags for _ , modname , _ in pkgutil . walk_packages ( __path__ ): if modname . startswith ( 'tag_' ): __import__ ( f ' { __name__ } . { modname } ' )","title":"liquid.tags"},{"location":"api/source/liquid.tags.tag/","text":"SOURCE CODE liquid.tags. tag DOCS \"\"\"Basics for all tags\"\"\" import re from pathlib import Path from lark import LarkError from .grammar import Grammar from .transformer import TagTransformer from ..config import LIQUID_LOG_INDENT from ..utils import shorten , logger , RequiredTags , get_tag_parser from ..exceptions import LiquidSyntaxError , LiquidRenderError class Tag : # pylint: disable=too-many-instance-attributes DOCS \"\"\"The base class for all tags. Subclass should provide `start`, `grammar`, `transformer`, `base_grammar` via `__init_subclass__` to initialize a PARSER for the tag. If start is None, meaning no parser needed for this tag. Attributes: VOID: whether the tag is void, meaning True if there is no children allow otherwise False ELDER_TAGS: Prior tags pattern, used to valiate if this tag is in the right position. This should be a pyparsing object able to match the prior tags This is a list since a tag can be with multiple tags, For example, \"else\" with \"if\", \"for\" and \"case\" PARENT_TAGS: Parent tags where this tags allows to be put in YONGER_TAGS: A flag to tell whether a yonger sibling tag is allowed to be followed. SECURE: Is this tag secure? An insecure tag is not allowed in strict mode RAW: Whether all content should be treated as raw PARSER: Parser to parse the content BASE_GRAMMAR: The base grammar parsing_self: Whether this tag needs further parsing, or just hold it parsing_children: Whether we should parse then children, or just hold it name: The name that this tag hits (since a tag can have aliases) content: The content of the tag context: The context of the tag open_compact: Whether it is compact tag for open tag close_compact: Whether it is compact tag for close tag parser: The parser of the tag children: The children of the tag parent: The parent of the tag prev: The previous tag of this tag next: The next tag of this tag Args: hitname: The name that this tag hits (since a tag can have aliases) content: The content of the tag context: The context of the tag open_compact: Whether it is compact tag for open tag close_compact: Whether it is compact tag for close tag parser: The parser of the tag \"\"\" __slots__ = ( 'name' , 'content' , 'context' , 'open_compact' , 'close_compact' , 'parser' , 'children' , 'parent' , 'parsed' , 'prev' , 'next' , 'parsing_self' , 'parsing_children' ) VOID = False ELDER_TAGS = () PARENT_TAGS = () YONGER_TAGS = True SECURE = True RAW = False START = None GRAMMAR = None TRANSFORMER = TagTransformer () BASE_GRAMMAR = Grammar ( Path ( __file__ ) . parent / 'grammar.lark' ) PARSING_SELF = True PARSING_CHILDREN = True def __init__ ( self , # pylint: disable=too-many-arguments hitname , content , context , open_compact , close_compact , parser ): # type: (str, str, Diot, bool, bool, \"Parser\") -> None self . name = hitname self . content = content self . context = context self . open_compact = open_compact self . close_compact = close_compact self . parser = parser self . children = [] # Parent, previous and next tag object self . parent = self . prev = self . next = None self . parsed = None self . parsing_self = self . __class__ . PARSING_SELF self . parsing_children = self . __class__ . PARSING_CHILDREN def __init_subclass__ ( cls , use_parser = False ): DOCS # type: (bool) -> None \"\"\"Initialize a parser for subclass If use_parser is False, always try to generate a new parser for the subclass, otherwise, use the parent class's parser \"\"\" if use_parser : # let it inherit return if not cls . START : cls . PARSER = None else : cls . PARSER = get_tag_parser ( cls . START , cls . GRAMMAR , cls . TRANSFORMER , cls . BASE_GRAMMAR ) # pylint: disable=inconsistent-return-statements def parse ( self , force = False ): DOCS # type: (bool) -> Optional[bool] \"\"\"Parse the content of the tag\"\"\" if self . parsed is not None : return if not self . PARSER or ( not force and not self . parsing_self ): return try : self . parsed = self . PARSER . parse ( self . content ) return True except LarkError as lkerr : try : self . context . lineno += lkerr . line - 1 self . context . colno += lkerr . column - 1 except AttributeError : # pragma: no cover pass lkerr = re . sub ( r ' at line \\d+, column \\d+\\.' , '' , str ( lkerr )) raise LiquidSyntaxError ( f 'Syntax error ( { self . context . name } : ' f 'line { self . context . lineno + 1 } , ' f 'column { self . context . colno + 1 } ): { lkerr } ' , self . context , self . parser ) from None def parse_children ( self , base_level ): DOCS \"\"\"Parse the children if they are hold previouly\"\"\" for child in self . children : child . context . level = base_level + 1 child . parse ( force = True ) child . parse_children ( base_level + 1 ) def __repr__ ( self ): DOCS # type: () -> str \"\"\"The representation of the tag\"\"\" return ( f \"< { self . __class__ . __name__ } \" f \"( { shorten ( self . content , 30 , placeholder = ' [...]' ) !r} , \" f \"line { self . context . lineno + 1 } , \" f \"column { self . context . colno + 1 } )>\" ) def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> Any # pylint: disable=unused-argument \"\"\"A function for sub-classes to implement We don't have to handle local/global envs, as it is handled by `render`. Here we only need to take care of the rendering \"\"\" return self . content # pragma: no cover @property DOCS def parent_required ( self ): # type: () -> bool \"\"\"Whether this tag is requiring a parent tag\"\"\" return isinstance ( self . PARENT_TAGS , RequiredTags ) @property DOCS def elder_required ( self ): # type: () -> bool \"\"\"Whether this tag is requiring an elder tag\"\"\" return isinstance ( self . ELDER_TAGS , RequiredTags ) @property DOCS def eldest ( self ): # type: () -> Optional[Tag] \"\"\"Find eldest tag\"\"\" elder = self . prev if not elder : return None while elder : if not elder . prev : return elder elder = elder . prev return None # pragma: no cover @property DOCS def closest_parent ( self ): # type: () -> Optional[Tag] \"\"\"Find the closest parent\"\"\" parent = self . parent while parent : if parent . name in self . PARENT_TAGS : return parent parent = parent . parent return None # pragma: no cover def is_elder ( self , tag ): DOCS # type: (Tag) -> bool \"\"\"Check if tag can be an elder of this tag\"\"\" return self . ELDER_TAGS and tag . name in self . ELDER_TAGS def is_parent ( self , tag ): DOCS # type: (Tag) -> bool \"\"\"Check if tag can be a parent of this tag\"\"\" # If I don't require a parent, any un-VOID tag can be my parent if not self . parent_required : return True # pragma: no cover return tag . name in self . PARENT_TAGS def check_parents ( self ): DOCS # type: () -> bool \"\"\"Check if we have valid direct or indirect parents This is done after parent and prev have been assigned For example, `continue` can be in `if`. We need to check if it parent `for` some where like this: ```liquid {% for ... %} {% if ... %} {% continue %} {% endif %} {% endfor %} ``` \"\"\" # I don't require any parents # or I optionally require some # pylint: disable=unsupported-membership-test if not self . parent_required : return True # Checking for direct parents? TODO? if not self . parent : return False # pragma: no cover parent = self . parent while parent : if self . is_parent ( parent ): return True parent = parent . parent return False def check_elders ( self ): DOCS # type: () -> bool \"\"\"Check if required elders are placed\"\"\" if not self . elder_required : return True return self . prev and self . is_elder ( self . prev ) def _render_children ( self , local_vars , global_vars ): # type: (dict, dict) -> str \"\"\"Render the children This will be done recursively to render the whole template \"\"\" rendered = '' for child in self . children : # local vars updated child_rendered , local_vars = child . render ( local_vars , global_vars ) rendered += child_rendered return rendered def _render_next ( self , local_vars , global_vars , from_elder ): \"\"\"Render my next sibling\"\"\" if not self . next : return '' return self . next . render ( local_vars , global_vars , from_elder )[ 0 ] def render ( self , local_vars , global_vars , from_elder = False ): DOCS # type: (dict, dict, bool) -> Tuple[str, dict] \"\"\"Render the tag Args: local_vars: The local variables global_vars: The global variables from_elder: Whether the render is called from the elder tag If I have elder sibling tag, I can't run independently I am controlled by it Returns: The rendered string and local variables (maybe modified) \"\"\" if self . prev and not from_elder : return '' , local_vars logger . debug ( ' %s Rendering %r ' , ( self . context . level ) * LIQUID_LOG_INDENT , self ) try : rendered = self . _render ( local_vars , global_vars ) except Exception as exc : if hasattr ( exc , 'lineno' ): colno = getattr ( exc , 'colno' , 1 ) if exc . lineno > 1 : self . context . lineno += exc . lineno - 1 self . context . colno = colno - 1 else : self . context . colno += colno - 1 raise LiquidRenderError ( f 'KeyError: { exc } ' if isinstance ( exc , KeyError ) else str ( exc ), self . context , self . parser ) . with_traceback ( exc . __traceback__ ) from None else : return str ( rendered ), local_vars","title":"liquid.tags.tag"},{"location":"api/source/liquid.tags.tag__end/","text":"SOURCE CODE liquid.tags. tag__end DOCS \"\"\"The end tag ```liquid {% endxxx %} ``` \"\"\" from .manager import tag_manager from .tag import Tag @tag_manager . register class TagEND ( Tag ): DOCS \"\"\"End tag: '{% endxxx %}'\"\"\"","title":"liquid.tags.tag__end"},{"location":"api/source/liquid.tags.tag__literal/","text":"SOURCE CODE liquid.tags. tag__literal DOCS \"\"\"The literal tag\"\"\" from .manager import tag_manager from .tag import Tag from ..utils import logger from ..config import LIQUID_LOG_INDENT @tag_manager . register class TagLITERAL ( Tag ): DOCS \"\"\"The literal tag\"\"\" VOID = True # pylint: disable=unused-argument def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str content = self . content if self . open_compact : content = content . lstrip () if self . close_compact : content = content . rstrip () return content def render ( self , local_vars , global_vars , from_elder = False ): DOCS # type: (dict, dict, bool) -> Tuple[str, dict] \"\"\"Render the literals\"\"\" logger . debug ( '[dim italic] %s Rendering %r [/dim italic]' , ( self . context . level ) * LIQUID_LOG_INDENT , self , extra = { \"markup\" : True }) return str ( self . _render ( local_vars , global_vars )), local_vars","title":"liquid.tags.tag__literal"},{"location":"api/source/liquid.tags.tag__output/","text":"SOURCE CODE liquid.tags. tag__output DOCS \"\"\"The output tag ```liquid {{ ... }} ``` \"\"\" from .manager import tag_manager from .tag import Tag @tag_manager . register class TagOUTPUT ( Tag ): DOCS \"\"\"The output tag\"\"\" VOID = True START = 'output' def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str rendered = self . parsed . render ( local_vars , global_vars ) return str ( rendered ) if rendered is not None else ''","title":"liquid.tags.tag__output"},{"location":"api/source/liquid.tags.tag__root/","text":"SOURCE CODE liquid.tags. tag__root DOCS \"\"\"The root tag\"\"\" from .manager import tag_manager from .tag import Tag from ..config import LIQUID_LOG_INDENT from ..utils import logger from ..exceptions import LiquidSyntaxError @tag_manager . register class TagROOT ( Tag ): DOCS \"\"\"The root tag as a container of all child tags\"\"\" def parse ( self , force = False ): # pylint: disable=unused-argument DOCS # type: (bool) -> None \"\"\"Exclude block tags from parsing, until they are replaced\"\"\" if not self . parser . visitor . has_mother : return root_children = [] # pylint: disable=access-member-before-definition for child in self . children : if child . name in ( 'LITERAL' , 'block' ): continue if child is self or child . name in ( 'extends' , 'config' , 'comment' ): root_children . append ( child ) else : # don't put block back in, they replace mother's # and don't need to be rendered by current parser # (will be rendered mother parser) raise LiquidSyntaxError ( f 'Tag not allowed in a sub-template: { self !r} ' , child . context , child . parser ) # pylint: disable=attribute-defined-outside-init self . children = root_children def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str return self . _render_children ( local_vars , global_vars ) # pylint: disable=unused-argument def render ( self , local_vars , global_vars , from_elder = False ): DOCS # type: (dict, dict, bool) -> Tuple[str, dict] \"\"\"Render the children of root\"\"\" logger . debug ( ' %s - RENDERING %r ' , ( self . context . level ) * LIQUID_LOG_INDENT , self ) # get logger back self . parser . config . update_logger () return str ( self . _render ( local_vars , global_vars )), local_vars","title":"liquid.tags.tag__root"},{"location":"api/source/liquid.tags.tag_assign/","text":"SOURCE CODE liquid.tags. tag_assign DOCS \"\"\"Tag assign ```liquid {% assign x = 1 %} {% assign x = x | plus: 1 %} ``` \"\"\" from lark import v_args from .manager import tag_manager from .tag import Tag from .transformer import TagTransformer @v_args ( inline = True ) class TagAssignTransformer ( TagTransformer ): DOCS \"\"\"The transformer for tag assign\"\"\" # pylint: disable=no-self-use def tag_assign ( self , varname , output ): DOCS # type: (str, Tree) -> Tuple[str, Tree] \"\"\"Transform the tag_assign rule\"\"\" return str ( varname ), output @tag_manager . register class TagAssign ( Tag ): DOCS \"\"\"The assign tag\"\"\" VOID = True # type: bool START = 'tag_assign' # type: str GRAMMAR = 'tag_assign: var \"=\" output' # type: str TRANSFORMER = TagAssignTransformer () # type: TagAssignTransformer def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str varname , output = self . parsed output = output . render ( local_vars , global_vars ) local_vars [ varname ] = global_vars [ varname ] = output return ''","title":"liquid.tags.tag_assign"},{"location":"api/source/liquid.tags.tag_block/","text":"SOURCE CODE liquid.tags. tag_block DOCS \"\"\"Tag block ```liquid {% block block1 %} ... {% endblock %} ``` \"\"\" from .manager import tag_manager from .tag_capture import TagCapture @tag_manager . register class TagBlock ( TagCapture , use_parser = True ): DOCS \"\"\"The block tag\"\"\" PARSING_CHILDREN = False def __repr__ ( self ): DOCS # type: () -> str \"\"\"The representation of the tag\"\"\" compact = ( 'both' if self . open_compact and self . close_compact else 'left' if self . open_compact else 'right' if self . close_compact else 'none' ) # type: str return ( f \"< { self . __class__ . __name__ } \" f \"(' { self . context . name } :: { self . content } ', \" f \"compact ' { compact } ', \" f \"line { self . context . lineno + 1 } , \" f \"column { self . context . colno + 1 } )>\" ) def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str return self . _render_children ( local_vars , global_vars )","title":"liquid.tags.tag_block"},{"location":"api/source/liquid.tags.tag_break/","text":"SOURCE CODE liquid.tags. tag_break DOCS \"\"\"The break tag ```liquid {% for ... %} {% break %} {% endfor %} ``` \"\"\" from .manager import tag_manager from .tag import Tag from ..utils import RequiredTags from ..exceptions import LiquidSyntaxError @tag_manager . register class TagBreak ( Tag ): DOCS \"\"\"Class for tag break\"\"\" VOID = True PARENT_TAGS = RequiredTags ( 'for' ) # pylint: disable=unused-argument def parse ( self , force = False ): DOCS # type: (bool) -> None \"\"\"Make sure no extra content for this tag\"\"\" if self . content : raise LiquidSyntaxError ( f \"No content allow for tag: { self !r} \" , self . context , self . parser ) def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str self . closest_parent . flag_break = True return ''","title":"liquid.tags.tag_break"},{"location":"api/source/liquid.tags.tag_capture/","text":"SOURCE CODE liquid.tags. tag_capture DOCS \"\"\"Tag capture ```liquid {% capture my_variable %} I am being captured. {% endcapture %} ``` \"\"\" from .manager import tag_manager from .tag import Tag @tag_manager . register class TagCapture ( Tag ): DOCS \"\"\"The capture tag\"\"\" START = 'varname' # type: str def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str var = str ( self . parsed ) child = self . _render_children ( local_vars , global_vars ) local_vars [ var ] = global_vars [ var ] = child return ''","title":"liquid.tags.tag_capture"},{"location":"api/source/liquid.tags.tag_case/","text":"SOURCE CODE liquid.tags. tag_case DOCS \"\"\"Tag case ```liquid {% assign handle = \"cake\" %} {% case handle %} {% when \"cake\" %} This is a cake {% when \"cookie\" %} This is a cookie {% else %} This is not a cake nor a cookie {% endcase %} ``` \"\"\" from .manager import tag_manager from .tag__output import TagOUTPUT from ..exceptions import LiquidSyntaxError @tag_manager . register class TagCase ( TagOUTPUT , use_parser = True ): DOCS \"\"\"The case class\"\"\" VOID = False # type: str def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . data = None def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str self . data = self . parsed . render ( local_vars , global_vars ) rendered = '' for child in self . children : child_rendered , _ = child . render ( local_vars , global_vars ) rendered += child_rendered if child . name == 'when' : return rendered raise LiquidSyntaxError ( f 'No children found in tag: { self !r} ' , self . context , self . parser )","title":"liquid.tags.tag_case"},{"location":"api/source/liquid.tags.tag_comment/","text":"SOURCE CODE liquid.tags. tag_comment DOCS \"\"\"Tag comment ```liquid {% comment %} ... {% endcomment %} ``` \"\"\" from .manager import tag_manager from .tag import Tag @tag_manager . register class TagComment ( Tag ): DOCS \"\"\"The comment tag\"\"\" # pylint: disable=unused-argument def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str return ''","title":"liquid.tags.tag_comment"},{"location":"api/source/liquid.tags.tag_config/","text":"SOURCE CODE liquid.tags. tag_config DOCS \"\"\"Tag config ```liquid {% config %} ``` \"\"\" from lark import v_args from .manager import tag_manager from .tag import Tag from .transformer import TagTransformer from ..utils import find_dir from ..exceptions import LiquidRenderError @v_args ( inline = True ) class TagConfigTransformer ( TagTransformer ): DOCS \"\"\"The transformer for tag config\"\"\" # pylint: disable=no-self-use def tag_config ( self , * items ): DOCS \"\"\"Transform the tag_config rule\"\"\" return dict ( items ) def config_item ( self , varname , constant = True ): DOCS \"\"\"Transform the tag_config rule\"\"\" return varname , constant @tag_manager . register class TagConfig ( Tag ): DOCS \"\"\"The config tag\"\"\" VOID = True SECURE = False START = 'tag_config' GRAMMAR = ''' tag_config: config_item+ config_item: var (\"=\" constant)? ''' TRANSFORMER = TagConfigTransformer () def parse ( self , force = False ): DOCS # type: (bool) -> None \"\"\"Parse the configurations\"\"\" super () . parse ( force = force ) config = self . parser . config . copy () # vname is token for vname , value in self . parsed . items (): varname = str ( vname ) if varname not in config : if vname . line > 1 : self . context . lineno += vname . line - 1 self . context . colno = vname . column - 1 else : self . context . colno += vname . column - 1 raise LiquidRenderError ( f \"No such configuration item: { varname !r} \" , self . context , self . parser ) if varname == 'strict' : raise LiquidRenderError ( \"Configuration item 'strict' is not allowed to \" \"be modified by 'config' tag.\" , self . context , self . parser ) if varname == 'debug' : config . debug = value config . update_logger () elif varname in ( 'extends_dir' , 'include_dir' ): directory = find_dir ( value , self . context . path ) if not directory : if vname . line > 1 : self . context . lineno += vname . line - 1 self . context . colno = vname . column - 1 else : self . context . colno += vname . column - 1 raise LiquidRenderError ( f \"Cannot find the directory for { varname !r} \" , self . context , self . parser ) config [ varname ] = config [ varname ][:] + [ directory ] else : config [ varname ] = value self . parser . config = config # pylint: disable=unused-argument def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str return ''","title":"liquid.tags.tag_config"},{"location":"api/source/liquid.tags.tag_continue/","text":"SOURCE CODE liquid.tags. tag_continue DOCS \"\"\"The continue tag ```liquid {% for ... %} {% continue %} {% endfor %} ``` \"\"\" from .manager import tag_manager from .tag_break import TagBreak @tag_manager . register class TagContinue ( TagBreak ): DOCS \"\"\"Class for tag continue\"\"\" def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str self . closest_parent . flag_continue = True return ''","title":"liquid.tags.tag_continue"},{"location":"api/source/liquid.tags.tag_cycle/","text":"SOURCE CODE liquid.tags. tag_cycle DOCS \"\"\"Tag cycle ```liquid {% for <loop> <args> %} ... {% cycle \"one\", \"two\", \"three\" %} ... {% endfor %} ``` \"\"\" from lark import v_args from .manager import tag_manager from .tag import Tag from .transformer import TagTransformer , render_segment from ..utils import RequiredTags from ..exceptions import LiquidRenderError @v_args ( inline = True ) class TagCycleTransformer ( TagTransformer ): DOCS \"\"\"The transformer for tag cycle\"\"\" # pylint: disable=no-self-use def tag_cycle ( self , group , args = None ): DOCS \"\"\"Transformer for tag for\"\"\" return [ group , args , 0 ] @tag_manager . register class TagCycle ( Tag ): DOCS \"\"\"The cycle tag\"\"\" VOID = True PARENT_TAGS = RequiredTags ( 'for' ) START = 'tag_cycle' GRAMMAR = 'tag_cycle: [(constant|var) \":\"] arguments' TRANSFORMER = TagCycleTransformer () def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . _group = None self . _args = None def group ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> str \"\"\"Get the group of the cycle\"\"\" if self . _group is None : self . _group = render_segment ( self . parsed [ 0 ], local_vars , global_vars ) return self . _group def args ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> str \"\"\"Get the args of the cycle\"\"\" if self . _args is None : args , kwargs = self . parsed [ 1 ] . render ( local_vars , global_vars ) if kwargs : raise LiquidRenderError ( \"No keyword arguments allowed.\" , self . context , self . parser ) self . _args = args return self . _args def get_value ( self , local_vars , global_vars ): DOCS # type: (dict, dict) -> str \"\"\"Get current value of the cycle, and increment the cursor\"\"\" args = self . args ( local_vars , global_vars ) at = self . parsed [ 2 ] # pylint: disable=invalid-name ret = args [ at % len ( args )] self . parsed [ 2 ] = at + 1 return str ( ret ) def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str parent = self . closest_parent group = self . group ( local_vars , global_vars ) args = self . args ( local_vars , global_vars ) if group not in parent . cycles : parent . cycles [ group ] = self elif parent . cycles [ group ] . args ( local_vars , global_vars ) != args : raise LiquidRenderError ( 'Different arguments for cycle under ' f 'the same group: { group } ' , self . context , self . parser ) return self . get_value ( local_vars , global_vars )","title":"liquid.tags.tag_cycle"},{"location":"api/source/liquid.tags.tag_decrement/","text":"SOURCE CODE liquid.tags. tag_decrement DOCS \"\"\"Tag decrement ```liquid {% decrement my_counter %} {% decrement my_counter %} {% decrement my_counter %} ``` \"\"\" from .manager import tag_manager from .tag_capture import TagCapture @tag_manager . register class TagDecrement ( TagCapture , use_parser = True ): DOCS \"\"\"The decrement tag'\"\"\" VOID = True def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str # Variables created through the increment tag are independent # from variables created through assign or capture. var = f '__decremental__ { self . parsed } ' value = local_vars . get ( var , - 1 ) local_vars [ var ] = value - 1 return str ( value )","title":"liquid.tags.tag_decrement"},{"location":"api/source/liquid.tags.tag_else/","text":"SOURCE CODE liquid.tags. tag_else DOCS \"\"\"Else tag in following situations ```liquid // in if {% if ... %} ... [{% elsif ... %}] ... {% else %} ... {% endif %} // in case / when {% case x %} {% when ... %} ... {% when ... %} ... {% else %} ... {% endcase %} // in for {% for ... %} ... {% else %} ... {% endfor %} ``` \"\"\" from .manager import tag_manager from .tag import Tag from ..utils import OptionalTags , RequiredTags from ..exceptions import LiquidSyntaxError @tag_manager . register class TagElse ( Tag ): DOCS \"\"\"Class for tag else\"\"\" # else can be in case # '' indicates parent is not required PARENT_TAGS = OptionalTags ( 'case' ) ELDER_TAGS = RequiredTags ( 'if' , 'unless' , 'when' , 'for' , 'elsif' ) def parse ( self , force = False ): DOCS # type: (bool) -> None \"\"\"No extra content allowed for standard else tag\"\"\" if self . content : raise LiquidSyntaxError ( f \"No content allow for tag: { self !r} \" , self . context , self . parser ) def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str return self . _render_children ( local_vars , global_vars )","title":"liquid.tags.tag_else"},{"location":"api/source/liquid.tags.tag_elsif/","text":"SOURCE CODE liquid.tags. tag_elsif DOCS \"\"\"Elsif tag ```liquid {% if ... %} ... {% elsif ... %} ... [{% else %}] ... {% endif %} ``` \"\"\" from .manager import tag_manager from .tag_if import TagIf from ..utils import RequiredTags @tag_manager . register class TagElsif ( TagIf , use_parser = True ): DOCS \"\"\"Class for tag elsif\"\"\" # else can be in case # '' indicates parent is not required ELDER_TAGS = RequiredTags ( 'if' , 'unless' , 'elsif' )","title":"liquid.tags.tag_elsif"},{"location":"api/source/liquid.tags.tag_extends/","text":"SOURCE CODE liquid.tags. tag_extends DOCS \"\"\"Tag extends ```liquid {% extends ... %} ``` \"\"\" from diot import Diot from .manager import tag_manager from .tag import Tag from ..utils import template_meta , find_template from ..exceptions import LiquidSyntaxError , LiquidRenderError @tag_manager . register class TagExtends ( Tag ): DOCS \"\"\"The extends tag\"\"\" __slots__ = Tag . __slots__ + ( 'block_parsed' , ) VOID = True def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . parser . visitor . has_mother = True self . block_parsed = False def parse ( self , force = False ): # pylint: disable=unused-argument DOCS # type: (bool) -> None if self . parent . name != 'ROOT' : raise LiquidSyntaxError ( f 'Must be first-level tag: { self !r} ' , self . context , self . parser ) content = self . content # allows path to be quoted if len ( content ) > 2 and ( content [: 1 ] == content [ - 1 :] == '\"' or content [: 1 ] == content [ - 1 :] == \"'\" ): content = content [ 1 : - 1 ] try : mother = find_template ( content , self . context . path , self . parser . config . extends_dir ) if not mother or not mother . is_file (): raise OSError except OSError : raise LiquidSyntaxError ( 'Mother template does not exist.' , self . context , self . parser ) from None meta = template_meta ( mother ) # pylint: disable=attribute-defined-outside-init self . parsed = self . parser . __class__ ( meta , self . parser . config , Diot ( name = meta . name , path = meta . path , stream = meta . stream , lineno = 0 , colno = 0 , level = self . context . level + 1 ) ) self . parsed . parse () self . parsed . parent = self . parser # get the logger back self . parsed . config . update_logger () def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str \"\"\"make sure the template is in the format of: {% extends ... %} {% block 1 %}...{% endblock %} {% block 2 %}...{% endblock %} there are no other tags other than a config/comment tag \"\"\" # replace mother's blocks with self.parser's if not self . block_parsed : for blockname , block in self . parser . visitor . blocks . items (): # block: current_block (replacement) # mother_block: mother's block (to replace) if blockname not in self . parsed . visitor . blocks : raise LiquidRenderError ( f 'Block { blockname !r} does not exist ' 'in mother template' , block . context , block . parser ) mother_blocks = self . parsed . visitor . blocks mother_block = mother_blocks [ blockname ] # get the children of the block's parent siblings = mother_block . parent . children # get the index of the block in parent's children block_index = siblings . index ( mother_block ) # use the compacts of mother blocks block . open_compact = mother_block . open_compact block . close_compact = mother_block . close_compact # replace it with current block siblings [ block_index ] = block mother_blocks [ blockname ] = block # update the level to align with mother's logging structure block . context . level = mother_block . context . level self . block_parsed = True for blockname , block in self . parsed . visitor . blocks . items (): block . parse_children ( base_level = block . context . level ) return self . parsed . visitor . root . render ( local_vars , global_vars )[ 0 ]","title":"liquid.tags.tag_extends"},{"location":"api/source/liquid.tags.tag_for/","text":"SOURCE CODE liquid.tags. tag_for DOCS \"\"\"Tag for ```liquid {% for <loop> <args> %} ... {% endfor %} ``` \"\"\" from collections import namedtuple from lark import v_args from .manager import tag_manager from .tag import Tag from .transformer import TagTransformer , render_segment ForLoop = namedtuple ( # pylint: disable=invalid-name 'ForLoop' , [ 'first' , 'index' , 'index0' , 'last' , 'length' , 'rindex' , 'rindex0' ] ) @v_args ( inline = True ) class TagForTransformer ( TagTransformer ): DOCS \"\"\"The transformer for tag for\"\"\" # pylint: disable=no-self-use def for_limit_arg ( self , arg ): DOCS \"\"\"Transformer for for_limit_arg\"\"\" return ( 'limit' , arg ) def for_offset_arg ( self , arg ): DOCS \"\"\"Transformer for for_offset_arg\"\"\" return ( 'offset' , arg ) def for_reversed_arg ( self ): DOCS \"\"\"Transformer for for_reversed_arg\"\"\" return ( 'reversed' , True ) def tag_for ( self , varname , atom , * args ): DOCS \"\"\"Transformer for tag for\"\"\" return str ( varname ), atom , args @tag_manager . register class TagFor ( Tag ): DOCS \"\"\"The for tag Attributes: flag_break: The flag for break statement flag_continue: The flag for continue statement cycles: The cycle object for cycle tags \"\"\" __slots__ = Tag . __slots__ + ( 'flag_break' , 'flag_continue' , 'cycles' ) START = 'tag_for' GRAMMAR = ''' tag_for: varname \"in\" atom for_args* ?for_args: for_limit_arg | for_offset_arg | for_reversed_arg for_limit_arg: \"limit\" \":\" (number|var) for_offset_arg: \"offset\" \":\" (number|var) for_reversed_arg: \"reversed\" ''' TRANSFORMER = TagForTransformer () def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . flag_break = False # type: bool self . flag_continue = False # type: bool self . cycles = {} # type: Dict[str, TagCycle] def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str # pylint: disable=too-many-locals rendered = '' varname , atom , args = self . parsed obj = render_segment ( atom , local_vars , global_vars ) forargs = { 'limit' : None , 'offset' : None , 'reversed' : False } for argname , argvalue in args : argvalue = render_segment ( argvalue , local_vars , global_vars ) forargs [ str ( argname )] = argvalue # parameters if forargs [ 'limit' ] is not None and forargs [ 'offset' ] is not None : obj = obj [ forargs [ 'offset' ] : ( forargs [ 'offset' ] + forargs [ 'limit' ]) ] elif forargs [ 'offset' ] is not None : obj = obj [ forargs [ 'offset' ]:] elif forargs [ 'limit' ] is not None : obj = obj [: forargs [ 'limit' ]] if forargs [ 'reversed' ]: obj = reversed ( obj ) # make it avaiable for generators obj = list ( obj ) forlen = len ( obj ) local_vars_inside = local_vars . copy () for i , var in enumerate ( obj ): local_vars_inside [ varname ] = var # forloop object local_vars_inside [ 'forloop' ] = ForLoop ( first = i == 0 , index = i + 1 , index0 = i , last = i == forlen - 1 , length = forlen , rindex = forlen - i , rindex0 = forlen - i - 1 ) for child in self . children : child_rendered , _ = child . render ( local_vars_inside , global_vars ) rendered += child_rendered if self . flag_break or self . flag_continue : self . flag_continue = False break if self . flag_break : break if not obj : rendered += self . _render_next ( local_vars , global_vars , True ) return rendered","title":"liquid.tags.tag_for"},{"location":"api/source/liquid.tags.tag_if/","text":"SOURCE CODE liquid.tags. tag_if DOCS \"\"\"Tag if ```liquid {% if condition %} ... {% endif %} ``` \"\"\" from .manager import tag_manager from .tag import Tag from .transformer import render_segment from ..filters import EmptyDrop @tag_manager . register class TagIf ( Tag ): DOCS \"\"\"Tag if\"\"\" START = 'test' def _render_expr ( self , local_vars , global_vars ): # type: (dict, dict) -> bool expr = render_segment ( self . parsed , local_vars , global_vars ) # Strings, even when empty, are truthy. # See: https://shopify.github.io/liquid/basics/truthy-and-falsy/#truthy if isinstance ( expr , str ): expr = True elif ( isinstance ( expr , ( int , float )) and expr is not True and expr is not False ): expr = True elif isinstance ( expr , EmptyDrop ): expr = False return bool ( expr ) def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str rendered = '' expr = self . _render_expr ( local_vars , global_vars ) from_elder = True if expr : rendered += self . _render_children ( local_vars , global_vars ) # don't go next from_elder = False rendered += self . _render_next ( local_vars , global_vars , from_elder ) return rendered","title":"liquid.tags.tag_if"},{"location":"api/source/liquid.tags.tag_include/","text":"SOURCE CODE liquid.tags. tag_include DOCS \"\"\"Tag include ```liquid {% include ... %} ``` \"\"\" from diot import Diot from lark import v_args from .manager import tag_manager from .tag import Tag from .transformer import TagTransformer , render_segment from ..utils import template_meta , find_template from ..exceptions import LiquidSyntaxError @v_args ( inline = True ) class TagIncludeTransformer ( TagTransformer ): DOCS \"\"\"The transformer for tag include\"\"\" # pylint: disable=no-self-use def include_item ( self , varname , test ): DOCS \"\"\"Transform include_item rule\"\"\" return ( str ( varname ), test ) def tag_include ( self , path , * items ): DOCS \"\"\"Transform tag_include\"\"\" return ( path , items ) @tag_manager . register class TagInclude ( Tag ): DOCS \"\"\"The extends tag\"\"\" VOID = True START = 'tag_include' GRAMMAR = \"\"\" tag_include: (string|/[^ \\\\ s]+/) (include_item)* include_item: varname \"=\" test \"\"\" TRANSFORMER = TagIncludeTransformer () def parse ( self , force = False ): DOCS # type: (bool) -> None \"\"\"Parse the include template\"\"\" if not super () . parse ( force ): return path = self . parsed [ 0 ] # pylint: disable=access-member-before-definition path = str ( path ) try : include_template = find_template ( path , self . context . path , self . parser . config . include_dir ) if not include_template or not include_template . is_file (): raise OSError except OSError : raise LiquidSyntaxError ( f 'Cannot find template: { path !r} ( { self !r} )' , self . context , self . parser ) from None meta = template_meta ( include_template ) inc_parser = self . parser . __class__ ( meta , self . parser . config , Diot ( name = meta . name , stream = meta . stream , path = meta . path , colno = 0 , lineno = 0 , level = self . context . level + 1 ) ) inc_parser . parse () inc_parser . parent = self . parser inc_parser . config . update_logger () # pylint: disable=attribute-defined-outside-init self . parsed = inc_parser , self . parsed [ 1 ] def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str inc_parser , items = self . parsed items = dict ( items ) for varname , value in items . items (): items [ varname ] = render_segment ( value , local_vars , global_vars ) local_vars_copy = local_vars . copy () local_vars_copy [ 'include' ] = items return inc_parser . visitor . root . render ( local_vars_copy , global_vars )[ 0 ]","title":"liquid.tags.tag_include"},{"location":"api/source/liquid.tags.tag_increment/","text":"SOURCE CODE liquid.tags. tag_increment DOCS \"\"\"Tag increment ```liquid {% increment my_counter %} {% increment my_counter %} {% increment my_counter %} ``` \"\"\" from .manager import tag_manager from .tag_capture import TagCapture @tag_manager . register class TagIncrement ( TagCapture , use_parser = True ): DOCS \"\"\"The increment tag\"\"\" VOID = True def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str # Variables created through the increment tag are independent # from variables created through assign or capture. var = f '__incremental__ { self . parsed } ' value = local_vars . get ( var , 0 ) local_vars [ var ] = value + 1 return str ( value )","title":"liquid.tags.tag_increment"},{"location":"api/source/liquid.tags.tag_raw/","text":"SOURCE CODE liquid.tags. tag_raw DOCS \"\"\"Tag raw ```liquid {% raw %} ... {% endraw %} ``` \"\"\" from .manager import tag_manager from .tag import Tag from ..exceptions import LiquidSyntaxError @tag_manager . register class TagRaw ( Tag ): DOCS \"\"\"The raw tag\"\"\" RAW = True def parse ( self , force = False ): DOCS # type: (bool) -> None \"\"\"No extra content allowed for standard else tag\"\"\" if self . content : raise LiquidSyntaxError ( f \"No content allow for tag: { self !r} \" , self . context , self . parser ) def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str return self . _render_children ( local_vars , global_vars )","title":"liquid.tags.tag_raw"},{"location":"api/source/liquid.tags.tag_tablerow/","text":"SOURCE CODE liquid.tags. tag_tablerow DOCS \"\"\"Tag tabrow ```liquid <table> {% tablerow product in collection.products %} {{ product.title }} {% endtablerow %} </table> ``` \"\"\" from collections import namedtuple from lark import v_args from .manager import tag_manager from .tag import Tag from .tag_for import TagForTransformer from .transformer import render_segment TablerowObject = namedtuple ( # pylint: disable=invalid-name 'TablerowObject' , [ 'itername' , 'obj' , 'limit' , 'offset' , 'cols' ] ) # type: NamedTuple @v_args ( inline = True ) class TagTablerowTransformer ( TagForTransformer ): DOCS \"\"\"The transformer for tablerow tag\"\"\" # pylint: disable=no-self-use def tablerow_cols_arg ( self , token ): DOCS \"\"\"Transform rule: tablerow_cols_arg\"\"\" return ( 'cols' , token ) def tag_tablerow ( self , varname , atom , * args ): DOCS \"\"\"Transform rule: tag_tablerow\"\"\" return str ( varname ), atom , args @tag_manager . register class TagTablerow ( Tag ): DOCS \"\"\"The tablerow tag\"\"\" GRAMMAR = ''' tag_tablerow: NAME \"in\" atom tablerow_args* ?tablerow_args: for_limit_arg | for_offset_arg | tablerow_cols_arg for_limit_arg: \"limit\" \":\" (number|var) for_offset_arg: \"offset\" \":\" (number|var) tablerow_cols_arg: \"cols\" \":\" (number|var) ''' TRANSFORMER = TagTablerowTransformer () START = 'tag_tablerow' def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str # pylint: disable=too-many-locals rendered = '' itername , expr , args = self . parsed obj = expr . render ( local_vars , global_vars ) args = dict ( args ) limit = args . get ( 'limit' , None ) if limit : limit = render_segment ( limit , local_vars , global_vars ) offset = args . get ( 'offset' , None ) if offset : offset = render_segment ( offset , local_vars , global_vars ) cols = args . get ( 'cols' , None ) if cols : cols = render_segment ( cols , local_vars , global_vars ) if offset is not None and limit is not None : obj = obj [ offset : ( offset + limit )] elif offset is not None : obj = obj [ offset :] elif limit is not None : obj = obj [: limit ] # make it avaiable for generators obj = list ( obj ) lenobj = len ( obj ) cols = cols or lenobj # chunks rows = [ obj [ i : i + cols ] for i in range ( 0 , lenobj , cols )] local_vars_inside = local_vars . copy () for i , row in enumerate ( rows ): rendered += f '<tr class=\"row { i + 1 } \">' for j , col in enumerate ( row ): local_vars_inside [ itername ] = col rendered += f '<td class=\"col { j + 1 } \">' rendered += self . _render_children ( local_vars_inside , global_vars ) rendered += '</td>' rendered += '</tr>' return rendered","title":"liquid.tags.tag_tablerow"},{"location":"api/source/liquid.tags.tag_unless/","text":"SOURCE CODE liquid.tags. tag_unless DOCS \"\"\"Tag unless ```liquid {% unless condition %} ... {% endunless %} ``` \"\"\" from .manager import tag_manager from .tag_if import TagIf @tag_manager . register class TagUnless ( TagIf , use_parser = True ): DOCS \"\"\"The unless tag\"\"\" def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str rendered = '' expr = self . _render_expr ( local_vars , global_vars ) # from_elder = True if not expr : # don't go next # from_elder = False rendered += self . _render_children ( local_vars , global_vars ) # {% else %} not supported in standard mode # if self.next: # rendered += self._render_next(local_vars, global_vars, from_elder) return rendered","title":"liquid.tags.tag_unless"},{"location":"api/source/liquid.tags.tag_when/","text":"SOURCE CODE liquid.tags. tag_when DOCS \"\"\"Tag when (in case) ```liquid {% assign handle = \"cake\" %} {% case handle %} {% when \"cake\" %} This is a cake {% when \"cookie\" %} This is a cookie {% else %} This is not a cake nor a cookie {% endcase %} ``` \"\"\" from .manager import tag_manager from .tag__output import TagOUTPUT from ..utils import RequiredTags , OptionalTags @tag_manager . register class TagWhen ( TagOUTPUT , use_parser = True ): DOCS \"\"\"The when tag\"\"\" VOID = False PARENT_TAGS = RequiredTags ( 'case' ) ELDER_TAGS = OptionalTags ( 'when' ) def _render ( self , local_vars , global_vars ): # type: (dict, dict) -> str data = self . PARSER . parse ( self . content ) . render ( local_vars , global_vars ) if data == self . closest_parent . data : return self . _render_children ( local_vars , global_vars ) return self . _render_next ( local_vars , global_vars , True )","title":"liquid.tags.tag_when"},{"location":"api/source/liquid.tags.transformer/","text":"SOURCE CODE liquid.tags. transformer DOCS \"\"\"The transformer for tag segments\"\"\" import ast from abc import ABC , abstractmethod from functools import partialmethod from collections import OrderedDict from lark import v_args , Transformer from ..config import LIQUID_FILTERS_ENVNAME from ..filters import EmptyDrop from ..utils import NOTHING from ..exceptions import LiquidNameError def render_segment ( tagseg , local_vars , global_vars ): DOCS # type: (dict, dict) -> Any \"\"\"Try to render a segment If it is a tagseg object, render it with the envs, otherwise, return the value itself Args: local_vars: The local variables global_vars: The global_vars Returns: The rendered value \"\"\" if isinstance ( tagseg , TagSegment ): return tagseg . render ( local_vars , global_vars ) return tagseg class TagSegment ( ABC ): DOCS \"\"\"Base class for segment classes The parsed objects for the syntax inside a tag Attributes: data: The data to parser \"\"\" __slots__ = ( '_data' , ) def __init__ ( self , * data ): # type: (*Any) \"\"\"Initialize the object Args: data: The data of the parsed object \"\"\" self . _data = data @property DOCS def data ( self ): \"\"\"Get the data\"\"\" return self . _data def __len__ ( self ): return len ( self . _data ) def __repr__ ( self ): return f '< { self . __class__ . __name__ } (data= { self . data !r} )>' @abstractmethod DOCS def render ( self , local_vars , global_vars ): # type: (dict, dict) -> Any # pylint: disable=unused-argument \"\"\"Render the segment with the given envs\"\"\" class TagSegmentVar ( TagSegment ): DOCS \"\"\"segment for variables\"\"\" __slots__ = ( '_data' , 'line' , 'column' ) def __init__ ( self , * data ): # type: (Any) -> None \"\"\"Initialize the object Args: data: The data of the parsed object \"\"\" super () . __init__ ( * data ) try : self . line = data [ 0 ] . line self . column = data [ 0 ] . column except AttributeError : pass def __str__ ( self ): return str ( self . data [ 0 ]) def render ( self , local_vars , global_vars ): DOCS \"\"\"Get the value of a variable from envs\"\"\" vname_token = self . data [ 0 ] varname = str ( vname_token ) if varname in local_vars : var = local_vars [ varname ] else : try : var = global_vars [ varname ] except KeyError : error = LiquidNameError ( f 'Variable not defined: { varname !r} .' ) error . lineno = vname_token . line error . colno = vname_token . column raise error from None if isinstance ( var , ( tuple , list )) and len ( var ) == 0 : return EmptyDrop () return var class TagSegmentComparison ( TagSegment ): DOCS \"\"\"Comparison segment\"\"\" def render ( self , local_vars , global_vars ): DOCS \"\"\"Render the segment\"\"\" # pylint: disable=too-many-return-statements left , op , right = self . data left = render_segment ( left , local_vars , global_vars ) right = render_segment ( right , local_vars , global_vars ) if op == \"<\" : return left < right if op == \">\" : return left > right if op == \"==\" : return left == right if op == \">=\" : return left >= right if op == \"<=\" : return left <= right if op in ( \"<>\" , \"!=\" ): return left != right if op == \"in\" : return left in right if op == \"notin\" : return left not in right if op == \"is\" : return left is right if op == \"isnot\" : return left is not right if op == \"contains\" : return right in left return None # pragma: no cover class TagSegmentGetItem ( TagSegment ): DOCS \"\"\"segment for `obj[subscript]`\"\"\" def render ( self , local_vars , global_vars ): DOCS \"\"\"Try to get the value of the getitem operation\"\"\" obj , subscript = self . data obj = render_segment ( obj , local_vars , global_vars ) subscript = render_segment ( subscript , local_vars , global_vars ) try : return obj [ subscript ] except KeyError : return EmptyDrop () class TagSegmentGetAttr ( TagSegment ): DOCS \"\"\"segment for `obj.attr`\"\"\" def render ( self , local_vars , global_vars ): DOCS \"\"\"Try to get the value of the getattr operation\"\"\" obj , attr = self . data obj = render_segment ( obj , local_vars , global_vars ) attr = str ( attr ) try : return getattr ( obj , attr ) except AttributeError as attre : # support size query in liquid try : if attr == 'size' : return len ( obj ) if attr == 'first' : return obj [ 0 ] if attr == 'last' : return obj [ - 1 ] return obj [ attr ] except ( KeyError , TypeError ): raise attre from None class TagSegmentRange ( TagSegment ): DOCS \"\"\"segment for range\"\"\" def render ( self , local_vars , global_vars ): DOCS \"\"\"Render the range segment\"\"\" start , end = self . data start = render_segment ( start , local_vars , global_vars ) end = render_segment ( end , local_vars , global_vars ) return list ( range ( int ( start ), int ( end ) + 1 )) class TagSegmentOutput ( TagSegment ): DOCS \"\"\"Output inside {{ ... }}\"\"\" def render ( self , local_vars , global_vars ): DOCS \"\"\"Render the output segment\"\"\" base = render_segment ( self . data [ 0 ], local_vars , global_vars ) if len ( self ) == 1 : return base # filter_name is Token for filter_func in self . data [ 1 :]: base = filter_func . render ( local_vars , global_vars )( base ) return base class TagSegmentArguments ( TagSegment ): DOCS \"\"\"Arguments segment\"\"\" # pylint: disable=arguments-differ def render ( self , local_vars , global_vars , as_is = False ): DOCS # type: (dict, dict, bool) -> Tuple[List[str], Dict[str, Any]] \"\"\"Render the segment Args: as_is: Whether render the non-keyword arguments as-is or treat them as variables Returns: Rendered non-keyword and keyword arguments \"\"\" args = [] kwargs = OrderedDict () for test1 , test2 in self . data : test1name = str ( test1 ) if test2 is NOTHING : args . append ( test1name if as_is else render_segment ( test1 , local_vars , global_vars )) else : kwargs [ test1name ] = render_segment ( test2 , local_vars , global_vars ) return args , kwargs class TagSegmentLogical ( TagSegment ): DOCS \"\"\"Logical segment\"\"\" def render ( self , local_vars , global_vars ): DOCS test1 , and_or , test2 = self . data test1 = render_segment ( test1 , local_vars , global_vars ) test2 = render_segment ( test2 , local_vars , global_vars ) if and_or == 'and' : return test1 and test2 return test1 or test2 class TagSegmentFilter ( TagSegment ): DOCS \"\"\"Filter segment\"\"\" def render ( self , local_vars , global_vars ): DOCS filter_name , filter_args = self . data args , kwargs = [], {} if filter_args is not NOTHING : rendered_args = render_segment ( filter_args , local_vars , global_vars ) if rendered_args is not None : args , kwargs = rendered_args filtname = str ( filter_name ) filter_func_orig = global_vars [ LIQUID_FILTERS_ENVNAME ] . get ( filtname , global_vars . get ( filtname , NOTHING ) ) if filter_func_orig is NOTHING : error = KeyError ( f 'No such filter: { filtname !r} ' ) error . lineno = filter_name . line error . colno = filter_name . column raise error def filter_func ( base ): filter_args = [ base ] + args return filter_func_orig ( * filter_args , ** kwargs ) return filter_func @v_args ( inline = True ) class TagTransformer ( Transformer ): DOCS \"\"\"Transform tag segments\"\"\" # pylint: disable=no-self-use def __init__ ( self , visit_tokens = False ): \"\"\"Change visit_tokens default to False\"\"\" # pylint: disable=useless-super-delegation super () . __init__ ( visit_tokens ) def range ( self , token ): DOCS \"\"\"Ranges\"\"\" start , stop = token [ 1 : - 1 ] . split ( '..' , 1 ) try : start = int ( start ) except ( TypeError , ValueError ): start = TagSegmentVar ( start ) try : stop = int ( stop ) except ( TypeError , ValueError ): stop = TagSegmentVar ( stop ) return TagSegmentRange ( start , stop ) def comparison ( self , expr , op = None , expr2 = None ): DOCS \"\"\"rule comparison: comparison: atom (_comp_op atom)?\"\"\" if op is None : return expr return TagSegmentComparison ( expr , op , expr2 ) def varname ( self , vname ): DOCS \"\"\"Keep the token information for tracking\"\"\" return vname def argvalue ( self , test1 , test2 = NOTHING ): DOCS \"\"\"rule argvalue: test (\"=\" test)?\"\"\" return ( test1 , test2 ) def _passby ( self , * args ): return args def _passby_segment ( self , * args , segment = None ): return segment ( * args ) def _passby_single_segment ( self , arg = NOTHING , segment = None ): return segment ( arg ) number = string = lambda _ , data : ast . literal_eval ( str ( data )) get_item = partialmethod ( _passby_segment , segment = TagSegmentGetItem ) get_attr = partialmethod ( _passby_segment , segment = TagSegmentGetAttr ) arguments = partialmethod ( _passby_segment , segment = TagSegmentArguments ) var = partialmethod ( _passby_segment , segment = TagSegmentVar ) output = partialmethod ( _passby_segment , segment = TagSegmentOutput ) logical_test = partialmethod ( _passby_segment , segment = TagSegmentLogical ) test_filter = partialmethod ( _passby_segment , segment = TagSegmentFilter ) const_none = lambda _ : None const_true = lambda _ : True const_false = lambda _ : False","title":"liquid.tags.transformer"},{"location":"api/source/liquid.utils/","text":"SOURCE CODE liquid. utils DOCS \"\"\"Utilities for liquidpy\"\"\" import logging from io import StringIO from pathlib import Path from textwrap import shorten as tw_shorten from collections import namedtuple from rich.logging import RichHandler from rich.syntax import Syntax from rich.console import Console from lark import Lark from .config import ( LIQUID_LOGGER_NAME , LIQUID_EXC_MAX_STACKS , LIQUID_EXC_CODE_CONTEXT ) from .exceptions import LiquidNameError TemplateMeta = namedtuple ( 'TemplateMeta' , [ 'name' , 'path' , 'stream' , 'should_close' ]) class Nothing : DOCS # pylint: disable=too-few-public-methods \"\"\"A unique object to identify a NOTHING other than None Lark transformers sometimes can pass None or nothing when no terminals matched. To distinguish this situation, we need something other than None. \"\"\" def __repr__ ( self ): return 'NOTHING' NOTHING = Nothing () class _PositionalTuple ( tuple ): def __new__ ( cls , * args ): return super () . __new__ ( cls , args ) class OptionalTags ( _PositionalTuple ): DOCS \"\"\"Indicates the arguments are optional\"\"\" class RequiredTags ( _PositionalTuple ): DOCS \"\"\"Indicates the arguments are required\"\"\" class Singleton : DOCS # pylint: disable=too-few-public-methods \"\"\"An abstract base class for signleton classes To prevent the __init__ to run again for initialized object from __new__, we have a property `_initialized` to inidicate whether the object has been initialized already. \"\"\" INSTANCE = None # type: Optional[Type[Singleton]] def __new__ ( cls , * args , ** kwargs ): # pylint: disable=unused-argument if cls . INSTANCE is None : cls . INSTANCE = object . __new__ ( cls ) cls . INSTANCE . _initialized = False return cls . INSTANCE return cls . INSTANCE def __init__ ( self , * args , ** kwargs ): # pylint: disable=access-member-before-definition if not self . _initialized : self . _initialized = True self . _init ( * args , ** kwargs ) def _init ( self , * args , ** kwargs ): \"\"\"Initialize the object here\"\"\" def template_meta ( template ): DOCS # type: (Union[IO, str, Path]) -> NamedTuple \"\"\"Get the metadata of a template This is to try to normalize the template for liquid into the name of the template, the IO object and whether we should close that IO object. The IO object should be closed when a valid path is passed. Args: template: The template Returns: A tuple of the template name, the IO object and whether we should close that IO object \"\"\" if isinstance ( template , str ): path = None # type: Optional[Path] try : path = Path ( template ) if not path . is_file (): raise OSError except OSError : # filename too long or other OSError path = None if not path : return TemplateMeta ( '<string>' , f '<string> ( { shorten ( template , 20 ) } )' , StringIO ( template ), True ) return TemplateMeta ( path . stem , str ( path ), path . open (), True ) if isinstance ( template , Path ): return TemplateMeta ( template . stem , str ( template ), template . open (), True ) # IO object name = '<unknown>' # type: str try : name = template . name except AttributeError : # pragma: no cover pass return TemplateMeta ( name , name , template , False ) def check_name ( names ): DOCS # type: (Iterator[str]) -> None \"\"\"Check whether the name is allowed Raises: LiquidNameError: when names contains name that is not allowed \"\"\" for name in names : if name . startswith ( '__LIQUID' ): raise LiquidNameError ( f 'Name is preserved for liquid: { name !r} ' ) def analyze_leading_spaces ( string ): DOCS # type: (str) -> Tuple[int, int] \"\"\"Analyze the leading spaces of a string Args: string: The string to analyze Returns: A tuple of two integers. Number of new lines and the number spaces that last new line has \"\"\" newline = 0 last_nspaces = 0 for char in string : if not char . isspace (): break if char == ' \\n ' : newline += 1 last_nspaces = 0 last_nspaces += 1 return newline , last_nspaces def shorten ( text , width , placeholder = ' ...' ): DOCS # type: (str, int, str) -> str \"\"\"Wrap textwrap.shorten Since textwrap.shorten('abcdefg', 5, placeholder='.') will return '.' But what we want is 'abcd.' \"\"\" if len ( text ) <= width : return text string_to_check = text [: width - len ( placeholder ) + 1 ] if any ( char . isspace () for char in string_to_check ): return tw_shorten ( text , width , placeholder = placeholder ) return string_to_check [: - 1 ] + placeholder def _exc_stack_code ( context ): # type: (Diot) -> str console = Console ( file = StringIO ()) console . print ( f \" { context . path !r} , line { context . lineno + 1 } , \" f \"column { context . colno + 1 } \" ) stream = context . stream seekable = False if stream . closed : try : if isinstance ( stream , StringIO ): stream = StringIO ( stream . getvalue ()) else : stream = open ( stream . name ) seekable = stream . seekable () except ( AttributeError , FileNotFoundError , IOError , ValueError ): seekable = False else : try : seekable = stream . seekable () except ( AttributeError , ValueError , IOError ): seekable = False if not seekable : console . print ( \" [Stream not seekable]\" ) # pragma: no cover else : stream . seek ( 0 ) line_range = ( max ( 0 , context . lineno - LIQUID_EXC_CODE_CONTEXT ) + 1 , context . lineno + LIQUID_EXC_CODE_CONTEXT + 1 ) code = Syntax ( stream . read (), lexer_name = 'liquid' , line_numbers = True , line_range = line_range , highlight_lines = { context . lineno + 1 }) console . print ( code ) return console . file . getvalue () + \" \\n \" def excmsg_with_context ( msg , context , parser ): DOCS # type: (str, Diot, Parser) -> str \"\"\"Assemble the exception message with context Args: context: The context parser: The parser Returns: The assembled exception message \"\"\" config = parser . config if parser else None if not context or not config : # or not config.debug: return msg stacks = [ context ] for _ in range ( LIQUID_EXC_MAX_STACKS - 1 ): parent = parser . parent if not parent : break stacks . insert ( 0 , parent . context ) msgs = [ msg , '' ] for stack in stacks : msgs . append ( _exc_stack_code ( stack )) return ' \\n ' . join ( msgs ) def get_tag_parser ( start , grammar , transformer , base_grammar = None ): DOCS # type: (Union[str, Path], TagTransformer, str, Optional[Grammar]) -> Lark \"\"\"Get the lark parser for tags Args: start: The start rule name grammar: The new grammar transformer: The transformer for the parser base_grammar: The base grammar Returns: The lark object for parsing \"\"\" if base_grammar and grammar : lark_grammar = base_grammar . copy () lark_grammar . update ( grammar ) elif base_grammar : lark_grammar = base_grammar else : # pragma: no cover from .tags.grammar import Grammar lark_grammar = Grammar ( grammar ) return Lark ( str ( lark_grammar ), parser = 'lalr' , start = start , debug = False , maybe_placeholders = True , # pylint: disable=not-callable transformer = transformer ) def find_template ( path , curr_path , config_paths ): DOCS # type: (str, Optional[Union[str, Path]], List[Union[str, Path]]) # -> Optional[Path] \"\"\"Find the template by given path curr_path will always be the first one to look up. If it is None (template from a string, for example), current working directory will be used. Args: path: The path to look up curr_path: The path where current template is located config_paths: The paths from configuration Returns: The path found either directory. \"\"\" path = Path ( path ) if path . is_absolute (): return path if not curr_path : # pragma: no cover curr_path = Path ( '.' ) else : curr_path = Path ( curr_path ) . parent config_paths = config_paths + [ curr_path ] for cpath in config_paths : thepath = Path ( cpath ) / path if thepath . is_file (): return thepath return None def find_dir ( path , curr_path ): DOCS # type: (str, Optional[Union[str, Path]]) -> Optional[Path] \"\"\"Find the directory by given path If path is relative, find one relative to curr_path. Args: path: The path to look up curr_path: the path where current template is located Returns: The directory found \"\"\" path = Path ( path ) if path . is_absolute (): return path curr_path = Path ( curr_path ) . parent if curr_path else Path ( '.' ) ret = curr_path / path return ret if ret . is_dir () else None # pylint: disable=invalid-name logger = logging . getLogger ( LIQUID_LOGGER_NAME ) logger . addHandler ( RichHandler ( show_time = False , show_path = False ))","title":"liquid.utils"}]}